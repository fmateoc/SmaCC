Object subclass: #SmaCCRewriteServerWorker	instanceVariableNames: 'socket serverStream rewriteFiles remotePrefix localPrefix'	classVariableNames: ''	package: 'SmaCC_Rewrite_Server_Worker'!!SmaCCRewriteServerWorker methodsFor: 'running'!startConnectingTo: aString onPort: anInteger	rewriteFiles := Dictionary new.	socket := [ Socket newTCP		connectTo: (NetNameResolver addressForName: aString) port: anInteger;		yourself ]		on: Error		do: [ :ex | Exit signalFailure: ex messageText ].	serverStream := SocketStream on: socket.	serverStream binary.	serverStream noTimeout.	[ serverStream		nextPut: $0 asInteger;		flush.	self processRequests ]		ensure: [ socket close ]! !!SmaCCRewriteServerWorker methodsFor: 'running'!classNamed: aString	^ Smalltalk at: aString asSymbol! !!SmaCCRewriteServerWorker methodsFor: 'running'!processRequests	[ [ | bytes |	bytes := self readBytes.	[ self processRequest: bytes asString ]		on: Halt		do: [ :ex | 			ex				resignalAs:					(Error new						messageText: ex messageText;						yourself) ] ] repeat ]		on: Error		do: [ :ex | 			((Smalltalk options select: [ :each | '-/' includes: each first ])				collect: [ :each | each copyFrom: 2 to: each size ])				do: [ :each | 					(each sameAs: 'error')						ifTrue: [ ex pass ] ].			Exit signalFailure: ex messageText ]! !!SmaCCRewriteServerWorker methodsFor: 'running'!loadRewrites: aString	[ 	| rewrites |	rewrites := rewriteFiles		at: aString		ifAbsentPut: [ SmaCCRewriteRuleFileParser parseFile: aString ].	rewrites isUpToDate		ifTrue: [ ^ rewrites ].	rewriteFiles removeKey: aString ] repeat! !!SmaCCRewriteServerWorker methodsFor: 'running'!localizeFilename: aString	| newString |	newString := (self remotePrefix notEmpty and: [ aString beginsWith: self remotePrefix ])		ifTrue:			[ self localPrefix , (aString copyFrom: self remotePrefix size + 1 to: aString size) ]		ifFalse: [ aString ].	^ (newString copyReplaceAll: '\' with: FileSystem disk delimiter asString)		copyReplaceAll: '/'		with: FileSystem disk delimiter asString! !!SmaCCRewriteServerWorker methodsFor: 'running'!writeBytes: resultBytes	serverStream		nextPut: (resultBytes size bitAnd: 255);		nextPut: (resultBytes size >> 8 bitAnd: 255);		nextPut: (resultBytes size >> 16 bitAnd: 255);		nextPut: (resultBytes size >> 24 bitAnd: 255);		nextPutAll: resultBytes;		flush! !!SmaCCRewriteServerWorker methodsFor: 'running'!processRequest: aString	| file outputDirectory rewrites inputParser outputParser result resultBytes baseDirectory lineEnding |	aString		splitFirstOn: $;		andThen: $=		do: [ :type :value | 			type = 'FILE'				ifTrue: [ file := self localizeFilename: value ].			type = 'OUTPUTDIRECTORY'				ifTrue: [ outputDirectory := self localizeFilename: value ].			type = 'BASEDIRECTORY'				ifTrue: [ baseDirectory := self localizeFilename: value ].			type = 'REWRITEFILE'				ifTrue: [ rewrites := self loadRewrites: (self localizeFilename: value) ].			type = 'INPUTPARSER'				ifTrue: [ inputParser := self classNamed: value ].			type = 'OUTPUTPARSER'				ifTrue: [ outputParser := self classNamed: value ].			type = 'LINEENDING'				ifTrue: [ lineEnding := value asSymbol ] ].	result := SmaCCRewriteResult new.	SmaCCRewriteProcessor new		rules: rewrites;		parserClass: inputParser;		validationParserClass: outputParser;		outputDirectory: outputDirectory;		baseDirectory: baseDirectory;		lineEnding: lineEnding;		processFile: file usingResult: result.	resultBytes := result asSocketString asByteArray.	self writeBytes: resultBytes! !!SmaCCRewriteServerWorker methodsFor: 'running'!readBytes	^ serverStream		next:			serverStream next + (serverStream next << 8) + (serverStream next << 16)				+ (serverStream next << 24)! !!SmaCCRewriteServerWorker methodsFor: 'accessing'!remotePrefix: aString	remotePrefix := aString! !!SmaCCRewriteServerWorker methodsFor: 'accessing'!localPrefix: aString	localPrefix := aString! !!SmaCCRewriteServerWorker methodsFor: 'accessing'!localPrefix	^ localPrefix ifNil: [ '' ]! !!SmaCCRewriteServerWorker methodsFor: 'accessing'!remotePrefix	^ remotePrefix ifNil: [ '' ]! !CommandLineHandler subclass: #SmaCCRewriteServerWorkerCommandLineHandler	instanceVariableNames: 'server port'	classVariableNames: ''	package: 'SmaCC_Rewrite_Server_Worker'!!SmaCCRewriteServerWorkerCommandLineHandler methodsFor: 'public'!startServer	[ 	| worker |	worker := SmaCCRewriteServerWorker new.	self arguments		do:			[ :each | 			(each beginsWith: 'remote=')				ifTrue: [ worker remotePrefix: (each copyFrom: 8 to: each size) ].			(each beginsWith: 'local=')				ifTrue: [ worker localPrefix: (each copyFrom: 7 to: each size) ] ].	worker startConnectingTo: self server onPort: self port ]		on: Error		do: [ :ex | self stderr nextPutAll: ex messageText ]! !!SmaCCRewriteServerWorkerCommandLineHandler methodsFor: 'public'!port	^ port		ifNil: [ | arg parts |			arg := self serverArgument.			parts := arg substrings: ':'.			port := (parts size = 2 and: [ parts last notEmpty and: [ parts last allSatisfy: [ :each | each isDigit ] ] ])				ifTrue: [ parts last asNumber ]				ifFalse: [ 36rSM ] ]! !!SmaCCRewriteServerWorkerCommandLineHandler methodsFor: 'public'!activate	[ self startServer ] fork! !!SmaCCRewriteServerWorkerCommandLineHandler methodsFor: 'public'!serverArgument	^ self optionAt: 'server' ifAbsent: [ 'localhost' ]! !!SmaCCRewriteServerWorkerCommandLineHandler methodsFor: 'public'!server	^ server		ifNil:			[ server := (self serverArgument substrings: ':') first ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteServerWorkerCommandLineHandler class	instanceVariableNames: ''!!SmaCCRewriteServerWorkerCommandLineHandler class methodsFor: 'accessing'!commandName	^ 'SmaCCServerWorker'! !