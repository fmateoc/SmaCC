Object subclass: #SmaCCString	instanceVariableNames: 'firstSentinel lastSentinel currentId cachedInterval'	classVariableNames: ''	package: 'SmaCC_Source_Editing'!!SmaCCString commentStamp: '' prior: 0!SmaCCString is a special string like object that makes rewriting source code faster. It supports operations to insert and delete text from the middle of strings more efficiently than constructing new strings.Instance Variables:	currentId	<Integer>	the id that is used when constructing new SmaCCIntervals	firstSentinel	<SmaCCStringInterval>	the head of the SmaCCInterval list	lastSentinel	<SmaCCStringInterval>	the tail of the SmaCCInterval list	cachedInterval	<SmaCCStringInterval>	the interval where the last action took place -- most likely it or something nearby will the next thing needed!!SmaCCString methodsFor: '*SmaCC_Debugging_Support'!gtStringIn: aComposite	<gtInspectorPresentationOrder: 0>	aComposite text		title: 'String';		withLineNumbers: true;		display: [ self asString ]! !!SmaCCString methodsFor: '*GT4SmaCC-Inspector'!gtSourceFor: aView	<gtView>	^ aView explicit		priority: 10;		title: 'String';		stencil: [ | editor source |			source := BlRopedRawText string: self asString.			editor := BrEditor new				text: source;				look: BrGlamorousCodeEditorLook new.			editor ]! !!SmaCCString methodsFor: 'private'!isIndex: aIndex equalTo: bIndex	aIndex = bIndex		ifTrue: [ ^ true ].	aIndex class = bIndex class		ifTrue: [ ^ false ].	^ aIndex isInteger		ifTrue: [ bIndex intervalId = 1 and: [ aIndex = bIndex index ] ]		ifFalse:			[ bIndex isInteger				and: [ aIndex intervalId = 1 and: [ aIndex index = bIndex ] ] ]! !!SmaCCString methodsFor: 'private'!allIntervalsDo: aBlock	| current |	current := firstSentinel next.	[ current isSentinel ]		whileFalse: [ aBlock value: current.			current := current next ]! !!SmaCCString methodsFor: 'private'!insertFirst: first last: last at: anInteger	| interval |	interval := self intervalContaining: anInteger.	interval := interval splitAt: (self indexFor: anInteger).	interval previous next: first.	last next: interval.	^ first startIndex! !!SmaCCString methodsFor: 'private'!copyFrom: startIndex to: stopIndex into: aSmaCCString at: anInteger	| startInterval stopInterval current newInterval first last |	startInterval := self intervalContaining: startIndex.	stopInterval := self intervalContaining: stopIndex.	current := startInterval.	last := first := nil.	[ (current isRemoved or: [ current isSentinel ])		ifFalse:			[ newInterval := aSmaCCString newIntervalFor: current string.			newInterval addAllAnnotations: current annotations.			newInterval				start:					(current == startInterval						ifTrue: [ self indexFor: startIndex ]						ifFalse: [ current start ]).			newInterval				stop:					(current == stopInterval						ifTrue: [ self indexFor: stopIndex ]						ifFalse: [ current stop ]).			first isNil				ifTrue: [ first := newInterval ].			last notNil				ifTrue: [ last next: newInterval ].			last := newInterval ].	current ~~ stopInterval ]		whileTrue: [ current isSentinel				ifTrue: [ ^ '' ].			current := current next ].	first isNil		ifTrue: [ ^ aSmaCCString startIndex ].	^ aSmaCCString insertFirst: first last: last at: anInteger! !!SmaCCString methodsFor: 'private'!intervalsDo: aBlock	| current |	current := firstSentinel next.	[ current isSentinel ]		whileFalse:			[ current isRemoved				ifFalse: [ aBlock value: current ].			current := current next ]! !!SmaCCString methodsFor: 'private'!setIntervalId	firstSentinel next		do: [ :each | currentId := currentId max: each id ]! !!SmaCCString methodsFor: 'private'!newIntervalFor: aString	| newInterval |	newInterval := self intervalClass		from: 1		to: aString size		string: aString.	currentId := currentId + 1.	newInterval id: currentId.	^ newInterval! !!SmaCCString methodsFor: 'private'!intervalClass	^ SmaCCStringInterval! !!SmaCCString methodsFor: 'private'!intervalContaining: anIndex	| prev next |	(cachedInterval isNil or: [ cachedInterval isSentinel ])		ifTrue: [ prev := lastSentinel previous.			next := firstSentinel next ]		ifFalse:			[ (cachedInterval containsIndex: anIndex)				ifTrue: [ ^ cachedInterval ].			prev := cachedInterval previous.			next := cachedInterval next ].	[ prev isSentinel not or: [ next isSentinel not ] ]		whileTrue:			[ (prev isSentinel not and: [ prev containsIndex: anIndex ])				ifTrue: [ ^ cachedInterval := prev ].			(next isSentinel not and: [ next containsIndex: anIndex ])				ifTrue: [ ^ cachedInterval := next ].			prev := prev previous.			next := next next ].	^ lastSentinel! !!SmaCCString methodsFor: 'copying'!copyFrom: startIndex to: stopIndex	| result |	result := self class new.	self		copyFrom: startIndex		to: stopIndex		into: result		at: 1.	^ result! !!SmaCCString methodsFor: 'copying'!copy	| new first last current newCurrent |	first := last := nil.	new := self class new.	current := firstSentinel next.	[ current isSentinel ]		whileFalse:			[ newCurrent := current copy.			first isNil				ifTrue: [ first := newCurrent ].			last notNil				ifTrue: [ last next: newCurrent ].			last := newCurrent.			current := current next ].	first notNil		ifTrue: [ new insertFirst: first last: last at: 1 ].	new setIntervalId.	^ new! !!SmaCCString methodsFor: 'copying'!, aString	^ self copy		append: aString;		yourself! !!SmaCCString methodsFor: 'actions'!annotationRangesFor: aSmaCCAnnotation	| ranges startIndex current |	ranges := OrderedCollection new.	startIndex := 1.	current := firstSentinel next.	[ current isSentinel ]		whileFalse:			[ (current isRemoved not				and: [ current annotations includes: aSmaCCAnnotation ])				ifTrue: [ ranges						add: (startIndex to: startIndex + current size - 1) ].			startIndex := startIndex + current size.			current := current next ].	^ ranges! !!SmaCCString methodsFor: 'actions'!annotationsInNewRange: range	| startIndex first last annotations current |	annotations := Set new.	startIndex := 0.	first := range first.	last := range isEmpty		ifTrue: [ first ]		ifFalse: [ range last ].	current := firstSentinel next.	[ current isSentinel ]		whileFalse: [ startIndex > last				ifTrue: [ ^ annotations asOrderedCollection ].			startIndex := startIndex + current size.			startIndex >= first				ifTrue: [ annotations addAll: current annotations ].			current := current next ].	^ annotations asOrderedCollection! !!SmaCCString methodsFor: 'actions'!annotationsInOriginalRange: range	| first last |	first := self intervalContaining: range first.	last := range isEmpty		ifTrue: [ first ]		ifFalse: [ self intervalContaining: range last ].	^ (first annotationsTo: last) ifNil: [ (last annotationsTo: first) ifNil: [ #() ] ]! !!SmaCCString methodsFor: 'accessing'!indexFor: anIndex	^ anIndex isInteger		ifTrue: [ anIndex ]		ifFalse: [ anIndex index ]! !!SmaCCString methodsFor: 'accessing'!stopIndex	^ lastSentinel previous isSentinel		ifTrue: [ 0 ]		ifFalse: [ lastSentinel previous stopIndex ]! !!SmaCCString methodsFor: 'accessing'!startIndex	^ firstSentinel next isSentinel		ifTrue: [ 0 ]		ifFalse: [ firstSentinel next startIndex ]! !!SmaCCString methodsFor: 'accessing'!whitespaceAfterIndex: stopPosition	| stopIndex |	stopIndex := self whitespaceEndIndexAfterIndex: stopPosition.	stopIndex isNil		ifTrue: [ ^ '' ].	^ (self copyFrom: (self basicNextIndex: stopPosition) to: stopIndex)		asString! !!SmaCCString methodsFor: 'accessing'!rule	^ nil! !!SmaCCString methodsFor: 'accessing'!startOfLineWhitespaceStartIndexBeforeIndex: startPosition	| stopIndex currentIndex position |	position := startPosition.	position isNil		ifTrue: [ ^ nil ].	stopIndex := self previousIndex: position.	stopIndex isNil		ifTrue: [ ^ nil ].	currentIndex := stopIndex.	[ currentIndex notNil		and:			[ | char |			char := self at: currentIndex.			char isSeparator				and: [ char ~= Character cr and: [ char ~= Character lf ] ] ] ]		whileTrue: [ currentIndex := self previousIndex: currentIndex ].	^ currentIndex isNil		ifTrue: [ self startIndex ]		ifFalse: [ self basicNextIndex: currentIndex ]! !!SmaCCString methodsFor: 'accessing'!basicPreviousIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex - 1.	^ ((interval containsIndex: newIndex)		and: [ (self indexFor: newIndex) ~= 0 ])		ifTrue: [ newIndex ]		ifFalse:			[ interval previous isSentinel				ifTrue: [ nil ]				ifFalse: [ interval previous stopIndex ] ]! !!SmaCCString methodsFor: 'accessing'!deleteWhitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self whitespaceStartIndexBeforeIndex: startPosition.	(startIndex isNil		or: [ self isIndex: startIndex equalTo: startPosition ])		ifTrue: [ ^ '' ].	^ self		deleteFrom: startIndex		to: (self basicPreviousIndex: startPosition)! !!SmaCCString methodsFor: 'accessing'!stringIndexFor: anIndex	| interval result position |	interval := self intervalContaining: anIndex.	result := (interval isSentinel or: [ interval isRemoved ])		ifTrue: [ 0 ]		ifFalse: [ position := anIndex isInteger				ifTrue: [ anIndex ]				ifFalse: [ anIndex index ].			interval start > position				ifTrue: [ 0 ]				ifFalse: [ interval stop < position						ifTrue: [ interval stop - interval start + 1 ]						ifFalse: [ position - interval start + 1 ] ] ].	[ interval := interval previous.	interval isSentinel ]		whileFalse: [ interval isRemoved				ifFalse: [ result := result + (interval stop - interval start + 1) ] ].	^ result! !!SmaCCString methodsFor: 'accessing'!whitespaceEndIndexAfterIndex: stopPosition	| currentIndex position startIndex stopIndex |	position := stopPosition.	position isNil		ifTrue: [ ^ nil ].	startIndex := self nextIndex: position.	startIndex isNil		ifTrue: [ ^ nil ].	currentIndex := startIndex.	stopIndex := self stopIndex + 1.	[ currentIndex notNil		and:			[ currentIndex ~= stopIndex				and: [ (self at: currentIndex) isSeparator ] ] ]		whileTrue: [ currentIndex := self nextIndex: currentIndex ].	(currentIndex isNil or: [ currentIndex = stopIndex ])		ifTrue: [ ^ self stopIndex ].	[ currentIndex := self basicPreviousIndex: currentIndex.	(self isIndex: stopPosition equalTo: currentIndex)		or: [ (self isRemoved: currentIndex) not ] ] whileFalse.	^ currentIndex! !!SmaCCString methodsFor: 'accessing'!whitespaceStartIndexBeforeIndex: startPosition	| stopIndex currentIndex position |	position := startPosition.	position isNil		ifTrue: [ ^ nil ].	stopIndex := self previousIndex: position.	stopIndex isNil		ifTrue: [ ^ nil ].	currentIndex := stopIndex.	[ currentIndex notNil and: [ (self at: currentIndex) isSeparator ] ]		whileTrue: [ currentIndex := self previousIndex: currentIndex ].	currentIndex isNil		ifTrue: [ ^ self startIndex ].	[ currentIndex := self basicNextIndex: currentIndex.	(self isIndex: startPosition equalTo: currentIndex)		or: [ (self isRemoved: currentIndex) not ] ] whileFalse.	^ currentIndex! !!SmaCCString methodsFor: 'accessing'!originalStopPositionFor: anInteger	| current haltOnNext |	haltOnNext := false.	current := 1.	self		intervalsDo: [ :each | 			haltOnNext				ifTrue: [ each id = 1						ifTrue: [ ^ each start - 1 ] ]				ifFalse: [ (anInteger between: current and: current + each size - 1)						ifTrue: [ each id = 1								ifTrue: [ ^ each start + (anInteger - current) ]								ifFalse: [ haltOnNext := true ] ] ].			current := current + each size ].	self		allIntervalsDo: [ :each | 			each id = 1				ifTrue: [ ^ each string size ] ].	^ 0! !!SmaCCString methodsFor: 'accessing'!rule: aSmaCCRewrite	! !!SmaCCString methodsFor: 'accessing'!newPositionFor: anInteger	| position |	position := 1.	self		allIntervalsDo: [ :each | 			(each containsIndex: anInteger)				ifTrue: [ ^ each isRemoved						ifTrue: [ position ]						ifFalse: [ position + (anInteger - each start) ] ].			position := position + each size ].	^ position! !!SmaCCString methodsFor: 'accessing'!basicNextIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex + 1.	^ (interval containsIndex: newIndex)		ifTrue: [ newIndex ]		ifFalse:			[ interval next isSentinel				ifTrue: [ self stopIndex + 1 ]				ifFalse: [ interval next startIndex ] ]! !!SmaCCString methodsFor: 'accessing'!node	^ nil! !!SmaCCString methodsFor: 'accessing'!addAnnotationTo: aSmaCCStringInterval	! !!SmaCCString methodsFor: 'accessing'!previousIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex - 1.	[ (interval isRemoved not		and:			[ (interval containsIndex: newIndex)				and: [ (self indexFor: newIndex) ~= 0 ] ])		ifTrue: [ ^ newIndex ]		ifFalse:			[ interval previous isSentinel				ifTrue: [ ^ nil ]				ifFalse: [ interval := interval previous.					newIndex := interval stopIndex ] ] ] repeat! !!SmaCCString methodsFor: 'accessing'!startOfLineWhitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self		startOfLineWhitespaceStartIndexBeforeIndex: startPosition.	startIndex isNil		ifTrue: [ ^ '' ].	^ (self		copyFrom: startIndex		to: (self basicPreviousIndex: startPosition)) asString! !!SmaCCString methodsFor: 'accessing'!nextIndex: anIndex	| interval newIndex |	interval := self intervalContaining: anIndex.	newIndex := anIndex + 1.	[ (interval isRemoved not and: [ interval containsIndex: newIndex ])		ifTrue: [ ^ newIndex ]		ifFalse:			[ interval := interval next.			newIndex := interval startIndex.			newIndex isNil				ifTrue: [ ^ self stopIndex + 1 ] ] ] repeat! !!SmaCCString methodsFor: 'accessing'!originalStartPositionFor: anInteger	| current lastGoodIndex |	lastGoodIndex := 1.	current := 1.	self		intervalsDo: [ :each | 			(anInteger between: current and: current + each size - 1)				ifTrue: [ ^ each id = 1						ifTrue: [ each start + (anInteger - current) ]						ifFalse: [ lastGoodIndex ] ].			current := current + each size.			each id = 1				ifTrue: [ lastGoodIndex := each stop + 1 ] ].	^ lastGoodIndex! !!SmaCCString methodsFor: 'accessing'!node: aSmaCCParseNode	! !!SmaCCString methodsFor: 'accessing'!size	| current length |	length := 0.	current := firstSentinel next.	[ current isSentinel ]		whileFalse: [ length := length + current size.			current := current next ].	^ length! !!SmaCCString methodsFor: 'accessing'!asString	| stream |	stream := WriteStream on: (String new: self size).	firstSentinel next do: [ :each | each nextPutOn: stream ].	^ stream contents! !!SmaCCString methodsFor: 'accessing'!whitespaceBeforeIndex: startPosition	| startIndex |	startIndex := self whitespaceStartIndexBeforeIndex: startPosition.	startIndex isNil		ifTrue: [ ^ '' ].	^ (self		copyFrom: startIndex		to: (self basicPreviousIndex: startPosition)) asString! !!SmaCCString methodsFor: 'accessing'!deleteWhitespaceAfterIndex: stopPosition	| stopIndex |	stopIndex := self whitespaceEndIndexAfterIndex: stopPosition.	(stopIndex isNil		or: [ self isIndex: stopIndex equalTo: stopPosition ])		ifTrue: [ ^ '' ].	^ self deleteFrom: (self nextIndex: stopPosition) to: stopIndex! !!SmaCCString methodsFor: 'accessing'!at: anIndex	^ (self intervalContaining: anIndex) string		at: (self indexFor: anIndex)! !!SmaCCString methodsFor: 'initialize-release'!initialize	super initialize.	firstSentinel := self intervalClass from: 1 to: 0 string: ''.	firstSentinel beSentinel.	lastSentinel := self intervalClass from: 1 to: 0 string: ''.	lastSentinel beSentinel.	firstSentinel next: lastSentinel.	currentId := 0! !!SmaCCString methodsFor: 'initialize-release'!on: aString	| firstInterval |	firstInterval := self intervalClass		from: 1		to: aString size		string: aString.	firstInterval id: 1.	currentId := 1.	firstSentinel next: firstInterval.	firstInterval next: lastSentinel! !!SmaCCString methodsFor: 'editing'!deleteFrom: startIndex to: stopIndex	| startInterval atEnd |	startInterval := self intervalContaining: startIndex.	startInterval := startInterval splitAt: (self indexFor: startIndex).	[ atEnd := startInterval containsIndex: stopIndex.	(atEnd and: [ startInterval stop ~= (self indexFor: stopIndex) ])		ifTrue: [ startInterval splitAt: (self indexFor: stopIndex) + 1 ].	cachedInterval := startInterval := self removeInterval: startInterval.	atEnd or: [ startInterval containsIndex: stopIndex ] ]		whileFalse: [ startInterval := startInterval next ]! !!SmaCCString methodsFor: 'editing'!deleteCharacter: anInteger	^ self deleteFrom: anInteger to: anInteger! !!SmaCCString methodsFor: 'editing'!moveFrom: fromIndex to: toIndex before: newIndex	self		moveFrom: fromIndex		to: toIndex		location: newIndex		before: true! !!SmaCCString methodsFor: 'editing'!deleteUpTo: anIndex	self deleteFrom: self startIndex to: anIndex - 1! !!SmaCCString methodsFor: 'editing'!moveFrom: fromIndex to: toIndex location: newIndex before: aBoolean	| startInterval stopInterval newInterval currentInterval afterInterval |	startInterval := self intervalContaining: fromIndex.	startInterval := startInterval splitAt: (self indexFor: fromIndex).	currentInterval := startInterval.	[ currentInterval containsIndex: toIndex ]		whileFalse:			[ currentInterval isSentinel				ifTrue: [ ^ self ].			(currentInterval containsIndex: newIndex)				ifTrue: [ ^ self ].			currentInterval := currentInterval next ].	stopInterval := currentInterval.	(stopInterval containsIndex: newIndex)		ifTrue: [ newIndex < toIndex				ifTrue: [ ^ self ] ].	stopInterval := (stopInterval splitAt: (self indexFor: toIndex) + 1)		previous.	newInterval := self intervalContaining: newIndex.	afterInterval := aBoolean		ifTrue: [ newInterval splitAt: (self indexFor: newIndex) ]		ifFalse:			[ (newInterval containsIndex: newIndex)				ifTrue: [ newInterval splitAt: (self indexFor: newIndex) + 1 ]				ifFalse: [ newInterval next ] ].	startInterval previous next: stopInterval next.	afterInterval previous next: startInterval.	stopInterval next: afterInterval! !!SmaCCString methodsFor: 'editing'!deleteUpToEnd: anIndex	self deleteFrom: anIndex to: self stopIndex! !!SmaCCString methodsFor: 'editing'!moveFrom: fromIndex to: toIndex after: newIndex	self		moveFrom: fromIndex		to: toIndex		location: newIndex		before: false! !!SmaCCString methodsFor: 'editing'!addNewLineWhitespace: aString toInterval: currentInterval from: startIndex to: stopIndex	| start stop stream next location interval whitespaceInterval |	interval := currentInterval.	next := currentInterval next.	start := (currentInterval containsIndex: startIndex)		ifTrue: [ self indexFor: startIndex ]		ifFalse: [ currentInterval start ].	stop := (currentInterval containsIndex: stopIndex)		ifTrue: [ self indexFor: stopIndex ]		ifFalse: [ currentInterval stop ].	stream := ReadStream		on: (currentInterval string copyFrom: start to: stop).	[ stream atEnd ]		whileFalse:			[ | char |			char := stream next.			char = Character cr				ifTrue: [ stream peek = Character lf						ifTrue: [ stream next ] ].			(char = Character lf or: [ char = Character cr ])				ifTrue:					[ location := stream position + start.					interval := location > stop						ifTrue: [ next ]						ifFalse: [ interval splitAt: location ].					whitespaceInterval := self newIntervalFor: aString.					interval previous next: whitespaceInterval.					whitespaceInterval next: interval ] ]! !!SmaCCString methodsFor: 'editing'!append: aString	| position newInterval str |	aString isEmpty		ifTrue: [ ^ self stopIndex ].	str := (aString isKindOf: SmaCCString)		ifTrue: [ aString ]		ifFalse: [ SmaCCString on: aString ].	str		intervalsDo: [ :each | 			newInterval := self newIntervalFor: each string.			newInterval addAllAnnotations: each annotations.			newInterval start: each start.			newInterval stop: each stop.			position isNil				ifTrue: [ position := newInterval startIndex ].			self appendInterval: newInterval ].	^ position! !!SmaCCString methodsFor: 'editing'!addPrefix: aString	^ self insert: aString at: self startIndex! !!SmaCCString methodsFor: 'editing'!removeInterval: startInterval	^ startInterval convertToRemoved! !!SmaCCString methodsFor: 'editing'!insert: aString at: anInteger	| newFirstInterval |	aString isEmpty		ifTrue: [ ^ anInteger ].	(aString isKindOf: SmaCCString)		ifTrue:			[ ^ aString				copyFrom: aString startIndex				to: aString stopIndex				into: self				at: anInteger ]		ifFalse:			[ newFirstInterval := self newIntervalFor: aString.			^ self				insertFirst: newFirstInterval				last: newFirstInterval				at: anInteger ]! !!SmaCCString methodsFor: 'editing'!addNewLineWhitespace: aString from: startIndex to: stopIndex	| currentInterval next |	currentInterval := self intervalContaining: startIndex.	[ currentInterval isSentinel		ifTrue: [ ^ self ].	next := currentInterval next.	currentInterval isRemoved		ifFalse:			[ self				addNewLineWhitespace: aString				toInterval: currentInterval				from: startIndex				to: stopIndex ].	currentInterval containsIndex: stopIndex ]		whileFalse: [ currentInterval := next ]! !!SmaCCString methodsFor: 'editing'!appendInterval: newInterval	newInterval previous: lastSentinel previous.	newInterval next: lastSentinel.	newInterval previous next: newInterval.	^ lastSentinel previous: newInterval! !!SmaCCString methodsFor: 'editing'!replaceFrom: startIndex to: stopIndex with: aString	| newIndex |	newIndex := self insert: aString at: startIndex.	self deleteFrom: startIndex to: stopIndex.	^ newIndex! !!SmaCCString methodsFor: 'testing'!isEmpty	firstSentinel next		do: [ :each | 			each isEmpty				ifFalse: [ ^ false ] ].	^ true! !!SmaCCString methodsFor: 'testing'!isRemoved: anIndex	| interval |	interval := self intervalContaining: anIndex.	^ interval isSentinel or: [ interval isRemoved ]! !!SmaCCString methodsFor: 'testing'!isModified	^ firstSentinel next ~~ lastSentinel previous! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCString class	instanceVariableNames: ''!!SmaCCString class methodsFor: 'instance creation'!on: aString	^ self new		insert: aString at: 0;		yourself! !Magnitude subclass: #SmaCCStringIndex	instanceVariableNames: 'index intervalId'	classVariableNames: ''	package: 'SmaCC_Source_Editing'!!SmaCCStringIndex commentStamp: '' prior: 0!SmaCCStringIndex is used to index into a SmaCCString. When you perform an insert operation into a SmaCCString, you get a SmaCCStringIndex back so you can index into the newly inserted string.Instance Variables:	index	<Integer>	the index in the SmaCCInterval	intervalId	<Integer>	the SmaCCInterval's id!!SmaCCStringIndex methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: intervalId;		nextPut: $,;		print: index;		nextPut: $)! !!SmaCCStringIndex methodsFor: 'arithmetic'!- anInteger	^ self + anInteger negated! !!SmaCCStringIndex methodsFor: 'arithmetic'!+ anInteger	^ self class index: index + anInteger intervalId: intervalId! !!SmaCCStringIndex methodsFor: 'accessing'!intervalId	^ intervalId! !!SmaCCStringIndex methodsFor: 'accessing'!intervalId: anInteger	intervalId := anInteger! !!SmaCCStringIndex methodsFor: 'accessing'!index	^ index! !!SmaCCStringIndex methodsFor: 'accessing'!index: anInteger	index := anInteger! !!SmaCCStringIndex methodsFor: 'comparing'!= anObject	^ self class = anObject class		and:			[ self index = anObject index				and: [ self intervalId = anObject intervalId ] ]! !!SmaCCStringIndex methodsFor: 'comparing'!hash	^ (index hashMultiply bitXor: intervalId) hashMultiply! !!SmaCCStringIndex methodsFor: 'comparing'!< aSmaCCStringIndex	^ self index < aSmaCCStringIndex index! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCStringIndex class	instanceVariableNames: ''!!SmaCCStringIndex class methodsFor: 'instance creation'!index: anInteger intervalId: intervalId	^ self new		index: anInteger;		intervalId: intervalId;		yourself! !Object subclass: #SmaCCStringInterval	instanceVariableNames: 'id start stop next previous string isRemoved'	classVariableNames: ''	package: 'SmaCC_Source_Editing'!!SmaCCStringInterval commentStamp: '' prior: 0!SmaCCStringInterval is a SmaCCInterval that represents a string that is insert into the SmaCCString.Instance Variables:	id	<Integer>	a unique id for the operation	isRemoved	<Boolean>	is this interval removed?	next	<SmaCCStringInterval>	the next interval in the string	previous	<SmaCCStringInterval>	the previous interval in the string	start	<Integer>	the starting location in the string	stop	<Integer>	the ending location in the string	string	<String>	the text that we are inserting -- we are only inserting from the start index to the stop index!!SmaCCStringInterval methodsFor: 'accessing'!stop	^ stop! !!SmaCCStringInterval methodsFor: 'accessing'!annotations	^ #()! !!SmaCCStringInterval methodsFor: 'accessing'!id: anInteger	id := anInteger! !!SmaCCStringInterval methodsFor: 'accessing'!stopIndex	^ SmaCCStringIndex index: stop intervalId: id! !!SmaCCStringInterval methodsFor: 'accessing'!startIndex	self isSentinel		ifTrue: [ ^ nil ].	^ self isEmpty		ifTrue: [ next startIndex ]		ifFalse: [ SmaCCStringIndex index: start intervalId: id ]! !!SmaCCStringInterval methodsFor: 'accessing'!previous	^ previous! !!SmaCCStringInterval methodsFor: 'accessing'!isRemoved: aBoolean	isRemoved := aBoolean! !!SmaCCStringInterval methodsFor: 'accessing'!removedString	^ string copyFrom: start to: stop! !!SmaCCStringInterval methodsFor: 'accessing'!stop: anInteger	stop := anInteger! !!SmaCCStringInterval methodsFor: 'accessing'!next	^ next! !!SmaCCStringInterval methodsFor: 'accessing'!string	^ string! !!SmaCCStringInterval methodsFor: 'accessing'!annotationsTo: lastInterval	| annotations current |	annotations := Set new.	current := self.	[ annotations addAll: current annotations.	current ~~ lastInterval ]		whileTrue: [ current isSentinel				ifTrue: [ ^ nil ].			current := current next ].	^ annotations asOrderedCollection! !!SmaCCStringInterval methodsFor: 'accessing'!start: anInteger	start := anInteger! !!SmaCCStringInterval methodsFor: 'accessing'!id	^ id! !!SmaCCStringInterval methodsFor: 'accessing'!size	self isRemoved		ifTrue: [ ^ 0 ].	^ stop - start + 1 max: 0! !!SmaCCStringInterval methodsFor: 'accessing'!asString	(self isRemoved or: [ self isEmpty ])		ifTrue: [ ^ '' ].	^ string copyFrom: start to: stop! !!SmaCCStringInterval methodsFor: 'accessing'!next: aSmaCCInterval	next := aSmaCCInterval.	aSmaCCInterval previous: self! !!SmaCCStringInterval methodsFor: 'accessing'!start	^ start! !!SmaCCStringInterval methodsFor: 'accessing'!previous: aSmaCCInterval	previous := aSmaCCInterval! !!SmaCCStringInterval methodsFor: 'accessing'!string: aString	isRemoved := false.	string := aString! !!SmaCCStringInterval methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: id;		nextPut: $,;		print: start;		nextPut: $-;		print: stop;		nextPut: $)! !!SmaCCStringInterval methodsFor: 'editing'!insertAfter: aSmaCCInterval	self next: aSmaCCInterval next.	aSmaCCInterval next: self! !!SmaCCStringInterval methodsFor: 'editing'!splitAt: anIndex	| new |	(self isSentinel or: [ anIndex = start ])		ifTrue: [ ^ self ].	anIndex > stop		ifTrue: [ ^ next ].	new := self copy.	self stop: anIndex - 1.	new start: anIndex.	new insertAfter: self.	^ new! !!SmaCCStringInterval methodsFor: 'private'!removed	next := nil.	previous := nil! !!SmaCCStringInterval methodsFor: 'private'!addAllAnnotations: aCollection	! !!SmaCCStringInterval methodsFor: 'private'!convertToRemoved	| interval |	(self isRemoved or: [ self isSentinel ])		ifTrue: [ ^ self ].	isRemoved := true.	(previous canBeMergedWith: self)		ifTrue:			[ interval := previous.			interval stop: self stop.			interval next: next.			self removed.			^ interval ].	(self canBeMergedWith: next)		ifTrue:			[ interval := next.			next start: self start.			previous next: next.			self removed.			^ interval ].	^ self! !!SmaCCStringInterval methodsFor: 'private'!beSentinel	id := -1.	next := self.	previous := self! !!SmaCCStringInterval methodsFor: 'private'!nextPutOn: aWriteStream	self isRemoved		ifTrue: [ ^ self ].	aWriteStream next: self size putAll: string startingAt: start! !!SmaCCStringInterval methodsFor: 'iterating'!do: aBlock	| current |	current := self.	[ current isSentinel ]		whileFalse: [ aBlock value: current.			current := current next ]! !!SmaCCStringInterval methodsFor: 'testing'!canBeMergedWith: nextSmaCCStringInterval	^ self id = nextSmaCCStringInterval id		and:			[ self isRemoved = nextSmaCCStringInterval isRemoved				and: [ self stop + 1 = nextSmaCCStringInterval start ] ]! !!SmaCCStringInterval methodsFor: 'testing'!isEmpty	^ start > stop! !!SmaCCStringInterval methodsFor: 'testing'!isRemoved	^ isRemoved! !!SmaCCStringInterval methodsFor: 'testing'!isSentinel	^ id = -1! !!SmaCCStringInterval methodsFor: 'testing'!containsIndex: anIndex	| indexPosition indexId |	self isSentinel		ifTrue: [ ^ true ].	anIndex isInteger		ifTrue: [ indexPosition := anIndex.			indexId := 1 ]		ifFalse: [ indexPosition := anIndex index.			indexId := anIndex intervalId ].	^ id = indexId		and: [ (indexPosition between: start and: stop) or: [ indexPosition = 0 ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCStringInterval class	instanceVariableNames: ''!!SmaCCStringInterval class methodsFor: 'instance creation'!from: aSmaCCIndex to: aSmaCCIndex2 string: aString	^ self new		start: aSmaCCIndex;		stop: aSmaCCIndex2;		string: aString;		yourself! !