SmaCCParseNode subclass: #SmaCCDefinitionNode	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDefinitionNode methodsFor: 'testing'!isProductionRule	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isIgnoreDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isGroup	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isAssociativeDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isIdDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isFlagDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isAttributeDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isScopeDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isNameDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isHierarchyDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isTokenRule	^ false! !!SmaCCDefinitionNode methodsFor: 'testing'!isStartDirective	^ false! !!SmaCCDefinitionNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitDefinition: self! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!defaultTextAttributes	^ {(BlFontFamilyAttribute named: 'Source Code Pro')		beNotOverwritableByStyler.	BlFontGenericFamilyAttribute monospace beNotOverwritableByStyler.	(BlFontSizeAttribute size: 12) beNotOverwritableByStyler}! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!scannerClass	^ self topParent attributeNamed: #scannerClass ifAbsent: [ SmaCCScanner ]! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!buildInterfaceIn: presentation	self buildSourceInterfaceIn: presentation label: nil! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!findItemsToRenameFrom: anInteger	| token |	self		allNodesDo: [ :each |  ]		andTokensDo: [ :each | 			(anInteger between: each startPosition and: each stopPosition)				ifTrue: [ token := each ] ]		includeErrors: true.	token isNil		ifTrue: [ ^ #() ].	('''"<' includes: token value first)		ifTrue: [ ^ (self allTokensMatching: token)				collect: [ :each | each startPosition + 1 to: each stopPosition - 1 ] ].	(token value first isLetter or: [ token value first = $_ ])		ifTrue: [ ^ (self allTokensMatching: token)				collect: [ :each | each sourceInterval ] ].	^ #()! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!buildVariableNameInterfaceFor: aString in: presentation	| bloc refs count commonName |	refs := (self allReferencesTo: aString) select: [ :each | each isKindOf: SmaCCSymbolNode ].	refs isEmpty		ifTrue: [ ^ self ].	count := 0.	commonName := ''.	(Bag withAll: (refs collect: [ :e | e variableName ]))		doWithOccurrences: [ :each :occ | 			(each = '' or: [ occ > count ])				ifTrue: [ count := occ.					commonName := each ] ].	bloc := presentation bloc.	bloc title: 'Variable Names'.	bloc		element: [ | element defaultNameElement defaultNameEditor |			element := BlElement new.			element				constraintsDo: [ :c | 					c horizontal matchParent.					c vertical matchParent ].			element layout: BlFlowLayout vertical.			defaultNameEditor := BrTextEditor new.			defaultNameEditor text: commonName asRopedText.			refs size > 1				ifTrue: [ defaultNameElement := BlElement new						constraintsDo: [ :c | 							c horizontal matchParent.							c vertical fitContent ];						layout: BlFlowLayout horizontal;						yourself.					defaultNameElement						addChild:							((BlTextElement text: 'Default name:' asRopedText)								margin: (BlInsets all: 7);								yourself).					defaultNameElement						addChild:							(BrEditorElement new								editor: defaultNameEditor;								size: 200 @ 23;								border: (BlBorder paint: Color lightGray);								margin: (BlInsets all: 4);								yourself).					element addChild: defaultNameElement.					element						addChild:							(BlLineElement new								fromAnchor: (BlElementBottomLeftAnchor element: defaultNameElement);								toAnchor: (BlElementBottomRightAnchor element: defaultNameElement);								height: 2;								border: (BlBorder paint: (Color black alpha: 0.75) width: 1)) ].			refs				do: [ :each | 					(each buildVariableNameInterfaceElement: defaultNameEditor)						ifNotNil: [ :refElement | 							element								addChild: refElement;								addChild:									(BlLineElement new										fromAnchor: (BlElementBottomLeftAnchor element: refElement);										toAnchor: (BlElementBottomRightAnchor element: refElement);										height: 2;										border: (BlBorder paint: (Color black alpha: 0.75) width: 1)) ] ].			element ]! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!matches: aString	^ (self source asLowercase indexOfSubCollection: aString asLowercase) > 0! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!updateSource: aSmaCCString! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!tags	^ #()! !!SmaCCDefinitionNode methodsFor: '*GT4SmaCC-Development-UI'!buildSourceInterfaceIn: presentation label: aString	| bloc |	bloc := presentation bloc.	aString notNil		ifTrue: [ bloc title: aString ].	bloc		element: [ | styler text editor element |			text := self source asRopedText.			text				attributes: SmaCCParserGeneratorPresentation defaultTextAttributes.			styler := GtSmaCCGrammarStyler for: SmaCCScanner.			editor := BrTextEditor new.			editor text: (styler style: text).			element := BrEditorElement new.			element editor: editor.			element				constraintsDo: [ :c | 					c horizontal matchParent.					c vertical matchParent ].			element ]! !!SmaCCDefinitionNode methodsFor: 'accessing'!rule	^ self		lookupNode: [ :node | (node isKindOf: SmaCCProductionRuleNode) or: [ node isKindOf: SmaCCTokenRuleNode ] ]! !!SmaCCDefinitionNode methodsFor: 'accessing'!lookupRule: aString	self topParent rules		do: [ :each | 			((each isKindOf: SmaCCProductionRuleNode) or: [ each isKindOf: SmaCCTokenRuleNode ])				ifTrue: [ each name value = aString						ifTrue: [ ^ each ] ] ].	^ nil! !!SmaCCDefinitionNode methodsFor: 'accessing'!ruleReferences	^ #()! !!SmaCCDefinitionNode methodsFor: 'accessing'!ruleReferencesTo: aString	| rules |	rules := Set new.	(self allReferencesTo: aString)		do: [ :ref | ref rule ifNotNil: [ :rule | rules add: rule ] ].	^ rules		asSortedCollection: [ :a :b | a startPosition < b startPosition ]! !!SmaCCDefinitionNode methodsFor: 'accessing'!allReferencesTo: aString	| refs |	refs := OrderedCollection new.	self topParent		allNodesDo: [ :each | 			(((each isKindOf: SmaCCSymbolNode) or: [ each isKindOf: SmaCCTokenRegexNode ])				and: [ each name value = aString ])				ifTrue: [ refs add: each ] ].	^ refs! !!SmaCCDefinitionNode methodsFor: 'accessing'!uses	| rules |	rules := Set new.	self		allNodesDo: [ :each | 			((each isKindOf: SmaCCSymbolNode) or: [ each isKindOf: SmaCCTokenRegexNode ])				ifTrue: [ (self lookupRule: each name value) ifNotNil: [ :rule | rules add: rule ] ] ].	^ rules asSortedCollection: [ :a :b | a startPosition < b startPosition ]! !SmaCCDefinitionNode subclass: #SmaCCDefinitionErrorNode	instanceVariableNames: 'smaccError semicolon'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDefinitionErrorNode methodsFor: 'generated'!tokenVariables	^ #(#semicolon)! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!nodeVariables	^ #(#smaccError)! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!semicolon: aSmaCCToken	semicolon := aSmaCCToken! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!semicolon	^ semicolon! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!smaccError	^ smaccError! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitDefinitionError: self! !!SmaCCDefinitionErrorNode methodsFor: 'generated'!smaccError: aSmaCCErrorNode	self smaccError notNil		ifTrue: [ self smaccError parent: nil ].	smaccError := aSmaCCErrorNode.	self smaccError notNil		ifTrue: [ self smaccError parent: self ]! !SmaCCParseNodeVisitor subclass: #SmaCCDefinitionNodeVisitor	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitCodeProductionExpression: aCodeProductionExpression	^ self visitProductionExpression: aCodeProductionExpression! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitScopeDirective: aScopeDirective	^ self visitDirective: aScopeDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitProductionSymbol: aProductionSymbol	^ self visitSymbol: aProductionSymbol! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitRepeatRegex: aRepeatRegex	^ self visitRegex: aRepeatRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitKeywordSymbol: aKeywordSymbol	^ self visitSymbol: aKeywordSymbol! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitGroupTerm: aGroupTerm	^ self visitDefinition: aGroupTerm! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitIdDirective: anIdDirective	^ self visitDirective: anIdDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitTokenRule: aTokenRule	^ self visitDefinition: aTokenRule! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitDefinition: aDefinition	^ self visitSmaCCParseNode: aDefinition! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitDefinitionError: aDefinitionError	^ self visitDefinition: aDefinitionError! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitGrammarDefinition: aGrammarDefinition	^ self visitDefinition: aGrammarDefinition! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitTokenSymbol: aTokenSymbol	^ self visitSymbol: aTokenSymbol! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitProductionRule: aProductionRule	^ self visitDefinition: aProductionRule! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitPostfixTerm: aPostfixTerm	^ self visitDefinition: aPostfixTerm! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitSuperclassDirective: aSuperclassDirective	^ self visitDirective: aSuperclassDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitStartDirective: aStartDirective	^ self visitDirective: aStartDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitAlternationRegex: anAlternationRegex	^ self visitRegex: anAlternationRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitCharacterRegex: aCharacterRegex	^ self visitRegex: aCharacterRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitNodeNameDirective: aNodeNameDirective	^ self visitDirective: aNodeNameDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitFlagDirective: aFlagDirective	^ self visitDirective: aFlagDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitDirective: aDirective	^ self visitDefinition: aDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitAssociativeDirective: anAssociativeDirective	^ self visitDirective: anAssociativeDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitTokenRegex: aTokenRegex	^ self visitRegex: aTokenRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitAttributeDirective: anAttributeDirective	^ self visitDirective: anAttributeDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitClassProductionExpression: aClassProductionExpression	^ self visitProductionExpression: aClassProductionExpression! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitConcatenationRegex: aConcatenationRegex	^ self visitRegex: aConcatenationRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitErrorSymbol: anErrorSymbol	^ self visitSymbol: anErrorSymbol! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitProductionExpression: aProductionExpression	^ self visitDefinition: aProductionExpression! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitIgnoreVariableDirective: anIgnoreVariableDirective	^ self visitDirective: anIgnoreVariableDirective! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitCharacterBlockRegex: aCharacterBlockRegex	^ self visitRegex: aCharacterBlockRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitRegex: aRegex	^ self visitDefinition: aRegex! !!SmaCCDefinitionNodeVisitor methodsFor: 'generated'!visitSymbol: aSymbol	^ self visitDefinition: aSymbol! !SmaCCGLRParser subclass: #SmaCCDefinitionParser	instanceVariableNames: 'acceptSyntaxErrors'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForStartLine1: nodes	| result |	result := SmaCCStartDirectiveNode new.	result startToken: (nodes at: 1).	result addTokens: (nodes at: 2) to: result symbols.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForIgnoredVariables1: nodes	| result |	result := SmaCCIgnoreVariableDirectiveNode new.	result ignoreVariablesToken: (nodes at: 2).	result addTokens: (nodes at: 3) to: result names.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForFile1: nodes	| result |	result := SmaCCGrammarDefinitionNode new.	result addNodes: (nodes at: 1) to: result rules.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRules1: nodes	| result |	result := OrderedCollection new: 2.	self add: (nodes at: 1) to: result.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRules2: nodes	| result |	result := nodes at: 1.	self add: (nodes at: 2) to: result.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForTerms1: nodes	| result |	result := OrderedCollection new: 2.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexTerm2: nodes	| result |	result := SmaCCCharacterRegexNode new.	result char: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForProductionRule1: nodes	| result |	result := SmaCCProductionRuleNode new.	result name: (nodes at: 1).	result colon: (nodes at: 3).	result addTokens: ((nodes at: 4) at: 1) to: result barTokens.	result addNodes: ((nodes at: 4) at: 2) to: result expressions.	result semicolon: (nodes at: 6).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRules1: nodes	| result |	result := nodes at: 1.	self add: (nodes at: 2) to: (result at: 1).	self add: (nodes at: 3) to: (result at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForSuperclassLine1: nodes	| result |	result := SmaCCSuperclassDirectiveNode new.	result hierarchyToken: (nodes at: 1).	result superclass: (nodes at: 2).	result leftParen: (nodes at: 3).	result addTokens: (nodes at: 4) to: result names.	result rightParen: (nodes at: 5).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionFor______barToken__ConcatenationRegex__item__1: nodes	| result |	result := Array new: 2.	result at: 1 put: (nodes at: 1).	result at: 2 put: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRule5: nodes	| result |	result := SmaCCClassProductionExpressionNode new.	result addNodes: (nodes at: 1) to: result terms.	result left: (nodes at: 2).	result right: (nodes at: 3).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForLeftLine1: nodes	| result |	result := SmaCCAssociativeDirectiveNode new.	result typeToken: (nodes at: 1).	result addNodes: (nodes at: 2) to: result symbols.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForStartDirective1: nodes	self scope: #directives.	^ nil! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForTerm1: nodes	| result |	result := SmaCCKeywordSymbolNode new.	result name: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForScopesLine1: nodes	| result |	result := SmaCCScopeDirectiveNode new.	result typeToken: (nodes at: 1).	result addTokens: (nodes at: 2) to: result names.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForSpecialTerm5: nodes	| result |	result := SmaCCGroupTermNode new.	result leftParen: (nodes at: 1).	result addTokens: ((nodes at: 2) at: 1) to: result barTokens.	result addNodes: ((nodes at: 2) at: 2) to: result expressions.	result rightParen: (nodes at: 3).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForDirectiveLine1: nodes	| result |	result := nodes at: 3.	result directiveStartToken: (nodes at: 2).	result semicolon: (nodes at: 5).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForError2: nodes	| result |	result := SmaCCDefinitionErrorNode new.	result smaccError: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForTerm2: nodes	| result |	result := SmaCCTokenSymbolNode new.	result name: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexRule2: nodes	| result |	result := nodes at: 2.	result addFirstToken: (nodes at: 1) to: result states.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRule1: nodes	| result |	result := SmaCCProductionExpressionNode new.	result addNodes: (nodes at: 1) to: result terms.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexTerm6: nodes	| result |	result := SmaCCCharacterBlockRegexNode new.	result block: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForGLR1: nodes	| result |	result := SmaCCFlagDirectiveNode new.	result typeToken: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexTerm7: nodes	| result |	result := SmaCCTokenRegexNode new.	result name: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForError1: nodes	| result |	result := SmaCCDefinitionErrorNode new.	result smaccError: (nodes at: 1).	result semicolon: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRootClassLine1: nodes	| result |	result := SmaCCNodeNameDirectiveNode new.	result typeToken: (nodes at: 1).	result name: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexTerm5: nodes	| result |	result := nodes at: 2.	result addFirstToken: (nodes at: 1) to: result leftParens.	result addToken: (nodes at: 3) to: result rightParens.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForTerm3: nodes	| result |	result := SmaCCProductionSymbolNode new.	result name: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexTerm8: nodes	| result |	result := SmaCCRepeatRegexNode new.	result regex: (nodes at: 1).	result count: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForSpecialTerm4: nodes	| result |	result := SmaCCPostfixTermNode new.	result term: (nodes at: 1).	result operator: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionFor______barToken__ConcatenationRegex__item___1: nodes	| result |	result := Array new: 2.	result at: 1 put: (OrderedCollection new: 2).	result at: 2 put: (OrderedCollection new: 2).	self add: ((nodes at: 1) at: 1) to: (result at: 1).	self add: ((nodes at: 1) at: 2) to: (result at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForStartRegex1: nodes	self scope: #scanner.	^ nil! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForNamedTerm2: nodes	| result |	result := nodes at: 1.	result variableNameToken: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRules2: nodes	| result |	result := Array new: 2.	result at: 1 put: (OrderedCollection new: 2).	result at: 2 put: (OrderedCollection new: 2).	self add: (nodes at: 1) to: (result at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionFor______barToken__ConcatenationRegex__item___2: nodes	| result |	result := nodes at: 1.	self add: ((nodes at: 2) at: 1) to: (result at: 1).	self add: ((nodes at: 2) at: 2) to: (result at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForTerm4: nodes	| result |	result := SmaCCErrorSymbolNode new.	result name: (nodes at: 1).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegex2: nodes	| result |	result := SmaCCAlternationRegexNode new.	result addNode: (nodes at: 1) to: result items.	result addTokens: ((nodes at: 2) at: 1) to: result barTokens.	result addNodes: ((nodes at: 2) at: 2) to: result items.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForIdMethodLine1: nodes	| result |	result := SmaCCIdDirectiveNode new.	result idToken: (nodes at: 1).	result addTokens: (nodes at: 2) to: result names.	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRule2: nodes	| result |	result := SmaCCCodeProductionExpressionNode new.	result addNodes: (nodes at: 1) to: result terms.	result code: (nodes at: 2).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForEndDirective1: nodes	self scope: #default.	^ nil! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForAttributesLine1: nodes	| result |	result := SmaCCAttributeDirectiveNode new.	result attributesToken: (nodes at: 1).	result classname: (nodes at: 2).	result leftParen: (nodes at: 3).	result addTokens: (nodes at: 4) to: result names.	result rightParen: (nodes at: 5).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForParserRule4: nodes	| result |	result := SmaCCClassProductionExpressionNode new.	result addNodes: (nodes at: 1) to: result terms.	result left: (nodes at: 2).	result classname: (nodes at: 3).	result right: (nodes at: 4).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForRegexRule1: nodes	| result |	result := SmaCCTokenRuleNode new.	result name: (nodes at: 2).	result colon: (nodes at: 3).	result regex: (nodes at: 4).	result semicolon: (nodes at: 6).	^ result! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForStartProduction1: nodes	self scope: #parser.	^ nil! !!SmaCCDefinitionParser methodsFor: 'generated-reduction actions'!reduceActionForConcatenationRegex2: nodes	| result |	result := SmaCCConcatenationRegexNode new.	result addNode: (nodes at: 1) to: result items.	result addNodes: (nodes at: 2) to: result items.	^ result! !!SmaCCDefinitionParser methodsFor: 'private'!dismissErrorToken	self scope: #default.	^ super dismissErrorToken! !!SmaCCDefinitionParser methodsFor: 'testing'!useAllTokenIds	^ false! !!SmaCCDefinitionParser methodsFor: 'testing'!tryAllTokens	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDefinitionParser class	instanceVariableNames: ''!!SmaCCDefinitionParser class methodsFor: 'generated'!definitionComment"%scopes default scanner directives parser;directives <scopes>	: scopes	| states 	;directives <excludes> 	: excludes 	;directives <root> 	: root 	;directives <hierarchy> 	: hierarchy 	;directives <attributes>	: attributes	;directives <prefix> 	: prefix 	;directives <suffix> 	: suffix 	;directives <left> 	: left 	;directives <right> 	: right 	;directives <nonassoc> 	: nonassoc 	;directives <id> 	: id 	;directives <start> 	: start 	;directives <glr>	: glr	;directives <ignorecase>	: ignorecase	;directives <ignorevariables>	: ignore_variables	;directives <annotate_tokens>	: annotate_tokens	;directives <lr1>	: lr1	;directives <unicode>	: unicode	;directives <byte>	: byte	;<name> 	: (<isLetter> | _) (<isLetter> | _ | <isDigit>)*	;<directive> 	: \%	;<whitespace>	: \s+ 	;<tokenname>	: \< <name> \>	;default directives parser <symbolname>	: <name>	;directives parser <keyword>	: (\"" [^\""]* \"") + 	;<comment>	: (\# [^\r\n]*) 	| (\/\* [^\*]* \*+ ([^\/\*] [^\*]* \*+)* \/)	;parser <code>	: \{ 	;parser <immediateCode>	: \[	;parser <variablename>	: \' <name> \' 	;<production>	: \: (\: \=)? 	;<directive>	: % 	;<semicolon>	: \; 	;scanner <backslashcharacter>	: \\ [^cx] 	| \\ c [A-Z] 	| \\ x [0-9A-Fa-f]{1,4}	;scanner <characterblock>	: \[ ([^\]\\] | <backslashcharacter> )+ \] 	;scanner <repeat>	: \{ [0-9]* \, [0-9]* \}	;scanner <character>	: [^\ \t\v\\\r\n\{\(\[\.]	; scanner <anycharacter>	: \.	;parser <error>	: error	;parser <classLeft> 	: \{\{ 	;parser <classRight> 	: \}\} 	;default parser <patternToken>	: ` [^`]* `	;%glr;%id <code> <immediateCode> <keyword> <symbolname> <tokenname> <variablename> <semicolon>	<directive> <production> <classLeft> <classRight>;%left	""|"";%left ""("" <character> <backslashcharacter> <characterblock> <anycharacter> <tokenname> <symbolname> <directive>;%left ""*"" ""+"" ""?"" <repeat> ;%start ProductionRule RegexRule DirectiveLine File;%hierarchy Directive (		ScopeDirective		NodeNameDirective 		SuperclassDirective		AttributeDirective		AssociativeDirective		IdDirective		StartDirective		FlagDirective		IgnoreVariableDirective	);%hierarchy Symbol (		KeywordSymbol		TokenSymbol		ProductionSymbol		ErrorSymbol	);%hierarchy ProductionExpression (		CodeProductionExpression		ClassProductionExpression	);%hierarchy Regex (		CharacterRegex		CharacterBlockRegex		AlternationRegex		ConcatenationRegex		TokenRegex		RepeatRegex	);%prefix SmaCC;%suffix Node;%root Definition;File	: Rules {{GrammarDefinition}}	;Rules	: Rule 'rule'	| Rules Rule 'rule'	;Rule 	: ProductionRule 	| DirectiveLine	| RegexRule 	| Error	;Error	: error 'smaccError' <semicolon> 'semicolon' {{DefinitionError}}	| error 'smaccError' {{DefinitionError}}	;# DirectivesDirectiveLine 	: StartDirective <directive> 'directiveStartToken' Directive EndDirective <semicolon> 'semicolon' {{Directive}}	;Directive 	: ExcludeScopesLine 	| ScopesLine	| RootClassLine	| SuperclassLine	| AttributesLine	| PrefixLine	| SuffixLine	| LeftLine 	| RightLine 	| NonAssociativeLine	| IdMethodLine	| StartLine 	| GLR	| IgnoreCase	| IgnoredVariables	| AnnotateTokens	| LR1	| Unicode	| Byte	;StartDirective 	: {self scope: #directives. nil}	;EndDirective 	: {self scope: #default. nil}	;ScopesLine 	: <scopes> 'typeToken' Scopes {{ScopeDirective}}	;Scopes 	: 	| Scopes Symbol 'name'	;ExcludeScopesLine 	: <excludes> 'typeToken' Scopes {{ScopeDirective}}	;RootClassLine 	: <root> 'typeToken' <symbolname> 'name' {{NodeNameDirective}}	;SuperclassLine	: <hierarchy> 'hierarchyToken' <symbolname> 'superclass' ""("" 'leftParen' ClassList "")"" 'rightParen' {{SuperclassDirective}}	;AttributesLine	: <attributes> 'attributesToken' <symbolname> 'classname' ""("" 'leftParen' IvarList "")"" 'rightParen' {{AttributeDirective}}	;IvarList		:	| IvarList <symbolname> 'name'	;ClassList 	:	| ClassList <symbolname> 'name'	;PrefixLine	: <prefix> 'typeToken' <symbolname> 'name' {{NodeNameDirective}}	;SuffixLine	: <suffix> 'typeToken' <symbolname> 'name' {{NodeNameDirective}}	;LeftLine	: <left> 'typeToken' TokenList {{AssociativeDirective}}	;RightLine	: <right> 'typeToken' TokenList {{AssociativeDirective}}	;NonAssociativeLine	: <nonassoc> 'typeToken' TokenList {{AssociativeDirective}}	;TokenList	: Term 'symbol'	| TokenList Term 'symbol'	;IdMethodLine	: <id> 'idToken' IdTokens {{IdDirective}}	;IdTokens	: <tokenname> 'name'	| IdTokens <tokenname> 'name'	;StartLine	: <start> 'startToken' StartingTokens {{StartDirective}}	;StartingTokens	: <symbolname> 'symbol'	| StartingTokens <symbolname> 'symbol' 	;GLR	: <glr> 'typeToken' {{FlagDirective}}	;IgnoredVariables	: EndDirective <ignorevariables> 'ignoreVariablesToken' IgnoredVariableList {{IgnoreVariableDirective}}	;IgnoredVariableList	: <symbolname> 'name'	| IgnoredVariableList <symbolname> 'name'	;IgnoreCase	: <ignorecase> 'typeToken' {{FlagDirective}}	;AnnotateTokens	: <annotate_tokens> 'typeToken' {{FlagDirective}}	;LR1	: <lr1> 'typeToken' {{FlagDirective}}	;Unicode	: <unicode> 'typeToken' {{FlagDirective}}	;Byte	: <byte> 'typeToken' {{FlagDirective}}	;# ScannerRegexRule 	: StartRegex <tokenname> 'name' <production> 'colon' Regex 'regex' EndRegex <semicolon> 'semicolon' {{TokenRule}}	| Symbol 'state' RegexRule {{TokenRule}}	;StartRegex	: {self scope: #scanner. nil}	;EndRegex	: {self scope: #default. nil}	;Symbol 	: <symbolname> 	;Regex	: ConcatenationRegex	| ConcatenationRegex 'item'  (""|"" 'barToken' ConcatenationRegex 'item')+ {{AlternationRegex}}	;ConcatenationRegex	: RegexTerm	| RegexTerm 'item' RegexTerm 'item' + {{ConcatenationRegex}}	;RegexTerm	: <character> 'char' {{CharacterRegex}}	| <directive> 'char' {{CharacterRegex}}	| <anycharacter> 'char' {{CharacterRegex}}	| <backslashcharacter> 'char' {{CharacterRegex}}	| ""("" 'leftParen' Regex "")"" 'rightParen' {{Regex}}	| <characterblock> 'block' {{CharacterBlockRegex}}	| <tokenname> 'name' {{TokenRegex}}	| RegexTerm 'regex' ""*"" 'count' {{RepeatRegex}}		| RegexTerm 'regex' ""+"" 'count' {{RepeatRegex}}	| RegexTerm 'regex' ""?"" 'count' {{RepeatRegex}}	| RegexTerm 'regex' <repeat> 'count' {{RepeatRegex}}	;# Parser ProductionRule	: <symbolname> 'name' StartProduction <production> 'colon' ParserRules EndProduction <semicolon> 'semicolon' {{ProductionRule}}	;StartProduction	: {self scope: #parser. nil}	;EndProduction	: {self scope: #default. nil}	;ParserRules	: ParserRules ""|"" 'barToken' ParserRule 'expression'	| ParserRule 'expression'	;ParserRule 	: Terms {{ProductionExpression}}	| Terms <code> 'code' {{CodeProductionExpression}}	| Terms <immediateCode> 'code' {{CodeProductionExpression}}	| Terms <classLeft> 'left' <symbolname> 'classname' <classRight> 'right' {{ClassProductionExpression}}	| Terms <classLeft> 'left' <classRight> 'right' {{ClassProductionExpression}}	;Terms 	:	| Terms SpecialTerm 'term'	;SpecialTerm	: NamedTerm	| SpecialTerm 'term' ""?"" 'operator' {{PostfixTerm}}	| SpecialTerm 'term' ""+"" 'operator' {{PostfixTerm}}	| SpecialTerm 'term' ""*"" 'operator' {{PostfixTerm}}	| ""("" 'leftParen' ParserRules "")"" 'rightParen' {{GroupTerm}}	;NamedTerm	: Term	| Term <variablename> 'variableNameToken' {{Symbol}}	;Term	: <keyword> 'name' {{KeywordSymbol}}	| <tokenname> 'name' {{TokenSymbol}}	| <symbolname> 'name' {{ProductionSymbol}}	| <error> 'name' {{ErrorSymbol}}	;"! !!SmaCCDefinitionParser class methodsFor: 'generated'!startingStateForProductionRule	^ 2! !!SmaCCDefinitionParser class methodsFor: 'generated'!startingStateForFile	^ 1! !!SmaCCDefinitionParser class methodsFor: 'generated'!symbolTypes	^ #(#SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCGrammarDefinitionNode #SmaCCGrammarDefinitionNode #OrderedCollection #SmaCCDefinitionNode #SmaCCDefinitionErrorNode #SmaCCDirectiveNode #SmaCCDirectiveNode nil nil #SmaCCScopeDirectiveNode #OrderedCollection #SmaCCScopeDirectiveNode #SmaCCNodeNameDirectiveNode #SmaCCSuperclassDirectiveNode #SmaCCAttributeDirectiveNode #OrderedCollection #OrderedCollection #SmaCCNodeNameDirectiveNode #SmaCCNodeNameDirectiveNode #SmaCCAssociativeDirectiveNode #SmaCCAssociativeDirectiveNode #SmaCCAssociativeDirectiveNode #OrderedCollection #SmaCCIdDirectiveNode #OrderedCollection #SmaCCStartDirectiveNode #OrderedCollection #SmaCCFlagDirectiveNode #SmaCCIgnoreVariableDirectiveNode #OrderedCollection #SmaCCFlagDirectiveNode #SmaCCFlagDirectiveNode #SmaCCFlagDirectiveNode #SmaCCFlagDirectiveNode #SmaCCFlagDirectiveNode #SmaCCTokenRuleNode nil nil #SmaCCToken #SmaCCRegexNode #OrderedCollection #OrderedCollection #SmaCCRegexNode #OrderedCollection #SmaCCRegexNode #SmaCCProductionRuleNode nil nil #OrderedCollection #SmaCCProductionExpressionNode #OrderedCollection #SmaCCDefinitionNode #SmaCCSymbolNode #SmaCCSymbolNode #SmaCCToken #SmaCCErrorNode)! !!SmaCCDefinitionParser class methodsFor: 'generated'!startingStateForRegexRule	^ 3! !!SmaCCDefinitionParser class methodsFor: 'generated'!reduceTable^#(	#(82 0 #reduceActionForStartRegex1: 5588993 false ) 	#(53 0 #reduceActionForStartDirective1: 3355649 false ) 	#(84 1 #liftFirstValue: 5679105 false ) 	#(92 0 #reduceActionForStartProduction1: 6641665 false ) 	#(47 1 #reduceActionForFile1: 2630657 false ) 	#(48 1 #reduceActionForRules1: 2670593 false ) 	#(49 1 #liftFirstValue: 2716676 false ) 	#(49 1 #liftFirstValue: 2716674 false ) 	#(49 1 #liftFirstValue: 2716675 false ) 	#(49 1 #liftFirstValue: 2716673 false ) 	#(50 1 #reduceActionForError2: 2786306 false ) 	#(48 2 #reduceActionForRules2: 2670594 false ) 	#(54 0 #reduceActionForEndDirective1: 3409921 false ) 	#(81 2 #reduceActionForRegexRule2: 5413890 false ) 	#(50 2 #reduceActionForError1: 2786305 false ) 	#(96 0 #reduceActionForTerms1: 7192577 false ) 	#(56 0 #reduceActionForTerms1: 3525633 false ) 	#(73 1 #reduceActionForGLR1: 4853761 false ) 	#(76 1 #reduceActionForGLR1: 5120001 false ) 	#(77 1 #reduceActionForGLR1: 5181441 false ) 	#(78 1 #reduceActionForGLR1: 5252097 false ) 	#(79 1 #reduceActionForGLR1: 5299201 false ) 	#(80 1 #reduceActionForGLR1: 5354497 false ) 	#(52 1 #liftFirstValue: 3053570 false ) 	#(52 1 #liftFirstValue: 3053569 false ) 	#(52 1 #liftFirstValue: 3053571 false ) 	#(52 1 #liftFirstValue: 3053572 false ) 	#(52 1 #liftFirstValue: 3053573 false ) 	#(52 1 #liftFirstValue: 3053574 false ) 	#(52 1 #liftFirstValue: 3053575 false ) 	#(52 1 #liftFirstValue: 3053576 false ) 	#(52 1 #liftFirstValue: 3053577 false ) 	#(52 1 #liftFirstValue: 3053578 false ) 	#(52 1 #liftFirstValue: 3053579 false ) 	#(52 1 #liftFirstValue: 3053580 false ) 	#(52 1 #liftFirstValue: 3053581 false ) 	#(52 1 #liftFirstValue: 3053583 false ) 	#(52 1 #liftFirstValue: 3053582 false ) 	#(52 1 #liftFirstValue: 3053584 false ) 	#(52 1 #liftFirstValue: 3053585 false ) 	#(52 1 #liftFirstValue: 3053586 false ) 	#(52 1 #liftFirstValue: 3053587 false ) 	#(93 0 #reduceActionForEndDirective1: 6691841 false ) 	#(94 1 #reduceActionForParserRules2: 6740994 false ) 	#(95 1 #reduceActionForParserRule1: 6839297 false ) 	#(55 2 #reduceActionForScopesLine1: 3459073 false ) 	#(57 2 #reduceActionForScopesLine1: 3565569 false ) 	#(58 2 #reduceActionForRootClassLine1: 3641345 false ) 	#(63 2 #reduceActionForRootClassLine1: 4117505 false ) 	#(64 2 #reduceActionForRootClassLine1: 4199425 false ) 	#(99 1 #reduceActionForTerm2: 7566338 false ) 	#(99 1 #reduceActionForTerm3: 7566339 false ) 	#(99 1 #reduceActionForTerm1: 7566337 false ) 	#(99 1 #reduceActionForTerm4: 7566340 false ) 	#(65 2 #reduceActionForLeftLine1: 4281345 false ) 	#(68 1 #reduceActionForRules1: 4509697 false ) 	#(66 2 #reduceActionForLeftLine1: 4352001 false ) 	#(67 2 #reduceActionForLeftLine1: 4424705 false ) 	#(70 1 #reduceActionForRules1: 4628481 false ) 	#(69 2 #reduceActionForIdMethodLine1: 4568065 false ) 	#(72 1 #reduceActionForRules1: 4767745 false ) 	#(71 2 #reduceActionForStartLine1: 4695041 false ) 	#(90 1 #reduceActionForRegexTerm7: 5936135 false ) 	#(90 1 #reduceActionForRegexTerm2: 5936130 false ) 	#(90 1 #reduceActionForRegexTerm2: 5936132 false ) 	#(90 1 #reduceActionForRegexTerm6: 5936134 false ) 	#(90 1 #reduceActionForRegexTerm2: 5936129 false ) 	#(90 1 #reduceActionForRegexTerm2: 5936131 false ) 	#(83 0 #reduceActionForEndDirective1: 5635073 false ) 	#(85 1 #liftFirstValue: 5707777 false ) 	#(88 1 #liftFirstValue: 5836801 false ) 	#(95 2 #reduceActionForParserRule2: 6839298 false ) 	#(95 2 #reduceActionForParserRule2: 6839299 false ) 	#(96 2 #reduceActionForRules2: 7192578 false ) 	#(97 1 #liftFirstValue: 7234561 false ) 	#(98 1 #liftFirstValue: 7489537 false ) 	#(56 2 #reduceActionForRules2: 3525634 false ) 	#(62 0 #reduceActionForTerms1: 4066305 false ) 	#(61 0 #reduceActionForTerms1: 4017153 false ) 	#(68 2 #reduceActionForRules2: 4509698 false ) 	#(70 2 #reduceActionForRules2: 4628482 false ) 	#(72 2 #reduceActionForRules2: 4767746 false ) 	#(51 5 #reduceActionForDirectiveLine1: 2919425 false ) 	#(75 1 #reduceActionForRules1: 5028865 false ) 	#(74 3 #reduceActionForIgnoredVariables1: 4900865 false ) 	#(87 1 #reduceActionFor______barToken__ConcatenationRegex__item___1: 5767169 false ) 	#(85 2 #reduceActionForRegex2: 5707778 false ) 	#(90 2 #reduceActionForRegexTerm8: 5936136 false ) 	#(90 2 #reduceActionForRegexTerm8: 5936137 false ) 	#(90 2 #reduceActionForRegexTerm8: 5936138 false ) 	#(90 2 #reduceActionForRegexTerm8: 5936139 false ) 	#(88 2 #reduceActionForConcatenationRegex2: 5836802 false ) 	#(89 1 #reduceActionForRules1: 5890049 false ) 	#(94 3 #reduceActionForParserRules1: 6740993 false ) 	#(91 6 #reduceActionForProductionRule1: 6491137 false ) 	#(95 3 #reduceActionForParserRule5: 6839301 false ) 	#(97 2 #reduceActionForSpecialTerm4: 7234564 false ) 	#(97 2 #reduceActionForSpecialTerm4: 7234563 false ) 	#(97 2 #reduceActionForSpecialTerm4: 7234562 false ) 	#(98 2 #reduceActionForNamedTerm2: 7489538 false ) 	#(75 2 #reduceActionForRules2: 5028866 false ) 	#(90 3 #reduceActionForRegexTerm5: 5936133 false ) 	#(81 6 #reduceActionForRegexRule1: 5413889 false ) 	#(86 2 #reduceActionFor______barToken__ConcatenationRegex__item__1: 5767169 false ) 	#(87 2 #reduceActionFor______barToken__ConcatenationRegex__item___2: 5767170 false ) 	#(89 2 #reduceActionForRules2: 5890050 false ) 	#(97 3 #reduceActionForSpecialTerm5: 7234565 false ) 	#(95 4 #reduceActionForParserRule4: 6839300 false ) 	#(59 5 #reduceActionForSuperclassLine1: 3725313 false ) 	#(62 2 #reduceActionForRules2: 4066306 false ) 	#(60 5 #reduceActionForAttributesLine1: 3871745 false ) 	#(61 2 #reduceActionForRules2: 4017154 false )	).! !!SmaCCDefinitionParser class methodsFor: 'generated'!symbolNames	^ #('"("' '")"' '"*"' '"+"' '"?"' '"|"' '<scopes>' '<excludes>' '<root>' '<hierarchy>' '<attributes>' '<prefix>' '<suffix>' '<left>' '<right>' '<nonassoc>' '<id>' '<start>' '<glr>' '<ignorecase>' '<ignorevariables>' '<annotate_tokens>' '<lr1>' '<unicode>' '<byte>' '<whitespace>' '<tokenname>' '<symbolname>' '<keyword>' '<comment>' '<code>' '<immediateCode>' '<variablename>' '<production>' '<directive>' '<semicolon>' '<backslashcharacter>' '<characterblock>' '<repeat>' '<character>' '<anycharacter>' '<error>' '<classLeft>' '<classRight>' '<patternToken>' 'B e g i n' 'File' 'Rules' 'Rule' 'Error' 'DirectiveLine' 'Directive' 'StartDirective' 'EndDirective' 'ScopesLine' 'Scopes' 'ExcludeScopesLine' 'RootClassLine' 'SuperclassLine' 'AttributesLine' 'IvarList' 'ClassList' 'PrefixLine' 'SuffixLine' 'LeftLine' 'RightLine' 'NonAssociativeLine' 'TokenList' 'IdMethodLine' 'IdTokens' 'StartLine' 'StartingTokens' 'GLR' 'IgnoredVariables' 'IgnoredVariableList' 'IgnoreCase' 'AnnotateTokens' 'LR1' 'Unicode' 'Byte' 'RegexRule' 'StartRegex' 'EndRegex' 'Symbol' 'Regex' '("|" ''barToken'' ConcatenationRegex ''item'')' '("|" ''barToken'' ConcatenationRegex ''item'')+' 'ConcatenationRegex' 'RegexTerm ''item'' +' 'RegexTerm' 'ProductionRule' 'StartProduction' 'EndProduction' 'ParserRules' 'ParserRule' 'Terms' 'SpecialTerm' 'NamedTerm' 'Term' 'E O F' 'error')! !!SmaCCDefinitionParser class methodsFor: 'generated'!startingStateForDirectiveLine	^ 4! !!SmaCCDefinitionParser class methodsFor: 'generated'!transitionTable^#(#[1 0 6 0 27 0 21 0 28 0 10 0 35 0 25 0 47 0 29 0 48 0 33 0 49 0 33 0 50 0 33 0 51 0 45 0 53 0 33 0 81 0 53 0 82 0 57 0 84 0 33 0 91 0 65 0 101] #[1 0 69 0 28 0 73 0 91] #[1 0 6 0 27 0 57 0 28 0 81 0 81 0 53 0 82 0 57 0 84] #[1 0 10 0 35 0 85 0 51 0 45 0 53] #[1 0 14 0 27 0 14 0 28 0 18 0 34 0 89 0 92] #[0 0 0 0 100] #[1 0 6 0 27 0 21 0 28 0 10 0 35 0 93 0 49 0 93 0 50 0 93 0 51 0 45 0 53 0 93 0 81 0 53 0 82 0 57 0 84 0 93 0 91 0 22 0 100 0 65 0 101] #[0 0 26 0 27 0 28 0 35 0 100 0 101] #[0 0 30 0 27 0 28 0 35 0 100 0 101] #[0 0 34 0 27 0 28 0 35 0 100 0 101] #[0 0 97 0 35] #[0 0 38 0 27 0 28 0 35 0 100 0 101] #[0 0 101 0 27] #[1 0 6 0 27 0 57 0 28 0 105 0 81 0 53 0 82 0 57 0 84] #[0 0 42 0 27 0 28 0 35 0 100 0 101] #[1 0 46 0 27 0 46 0 28 0 46 0 35 0 109 0 36 0 46 0 100 0 46 0 101] #[1 0 18 0 34 0 89 0 92] #[0 0 0 0 100] #[0 0 14 0 27 0 28 0 36] #[0 0 0 0 100] #[0 0 0 0 100] #[0 0 113 0 34] #[0 0 50 0 27 0 28 0 35 0 100 0 101] #[1 0 117 0 7 0 121 0 8 0 125 0 9 0 129 0 10 0 133 0 11 0 137 0 12 0 141 0 13 0 145 0 14 0 149 0 15 0 153 0 16 0 157 0 17 0 161 0 18 0 165 0 19 0 169 0 20 0 54 0 21 0 173 0 22 0 177 0 23 0 181 0 24 0 185 0 25 0 189 0 52 0 193 0 54 0 189 0 55 0 189 0 57 0 189 0 58 0 189 0 59 0 189 0 60 0 189 0 63 0 189 0 64 0 189 0 65 0 189 0 66 0 189 0 67 0 189 0 69 0 189 0 71 0 189 0 73 0 189 0 74 0 189 0 76 0 189 0 77 0 189 0 78 0 189 0 79 0 189 0 80] #[0 1 17 0 34] #[0 0 58 0 27 0 28 0 35 0 100 0 101] #[0 0 62 0 27 0 28 0 35 0 100 0 101] #[1 0 66 0 1 0 66 0 6 0 66 0 27 0 66 0 28 0 66 0 29 0 66 0 31 0 66 0 32 0 66 0 36 0 66 0 42 0 66 0 43 1 21 0 94 1 25 0 95 1 29 0 96] #[1 0 70 0 28 0 70 0 36 1 33 0 56] #[1 0 70 0 28 0 70 0 36 1 37 0 56] #[0 1 41 0 28] #[0 1 45 0 28] #[0 1 49 0 28] #[0 1 53 0 28] #[0 1 57 0 28] #[1 1 61 0 27 1 65 0 28 1 69 0 29 1 73 0 42 1 77 0 68 1 81 0 99] #[1 1 61 0 27 1 65 0 28 1 69 0 29 1 73 0 42 1 85 0 68 1 81 0 99] #[1 1 61 0 27 1 65 0 28 1 69 0 29 1 73 0 42 1 89 0 68 1 81 0 99] #[1 1 93 0 27 1 97 0 70] #[1 1 101 0 28 1 105 0 72] #[0 0 74 0 36] #[0 0 78 0 36] #[0 0 82 0 36] #[0 0 86 0 36] #[0 0 90 0 36] #[0 0 94 0 36] #[1 0 54 0 36 1 109 0 54] #[0 1 113 0 21] #[0 0 98 0 36] #[0 0 102 0 36] #[0 0 106 0 36] #[0 0 110 0 36] #[0 0 114 0 36] #[0 0 118 0 36] #[0 0 122 0 36] #[0 0 126 0 36] #[0 0 130 0 36] #[0 0 134 0 36] #[0 0 138 0 36] #[0 0 142 0 36] #[0 0 146 0 36] #[0 0 150 0 36] #[0 0 154 0 36] #[0 0 158 0 36] #[0 0 162 0 36] #[0 0 166 0 36] #[0 0 170 0 36] #[1 1 117 0 1 1 121 0 27 1 125 0 35 1 129 0 37 1 133 0 38 1 137 0 40 1 141 0 41 1 145 0 85 1 149 0 88 1 153 0 90] #[1 1 157 0 6 0 174 0 36 1 161 0 93] #[0 0 178 0 2 0 6 0 36] #[1 1 165 0 1 0 182 0 2 0 182 0 6 1 61 0 27 1 65 0 28 1 69 0 29 1 169 0 31 1 173 0 32 0 182 0 36 1 73 0 42 1 177 0 43 1 181 0 97 1 181 0 98 1 189 0 99] #[1 1 193 0 28 0 186 0 36 1 193 0 84] #[1 1 193 0 28 0 190 0 36 1 193 0 84] #[0 0 194 0 36] #[0 1 197 0 1] #[0 1 201 0 1] #[0 0 198 0 36] #[0 0 202 0 36] #[0 0 206 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 33 0 36 0 42 0 43] #[0 0 210 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 33 0 36 0 42 0 43] #[0 0 214 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 33 0 36 0 42 0 43] #[0 0 218 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 33 0 36 0 42 0 43] #[1 1 61 0 27 1 65 0 28 1 69 0 29 0 222 0 36 1 73 0 42 1 205 0 99] #[0 0 226 0 27 0 28 0 29 0 36 0 42] #[1 1 61 0 27 1 65 0 28 1 69 0 29 0 230 0 36 1 73 0 42 1 205 0 99] #[1 1 61 0 27 1 65 0 28 1 69 0 29 0 234 0 36 1 73 0 42 1 205 0 99] #[0 0 238 0 27 0 36] #[1 1 209 0 27 0 242 0 36] #[0 0 246 0 28 0 36] #[1 1 213 0 28 0 250 0 36] #[0 1 217 0 36] #[1 1 221 0 28 1 225 0 75] #[1 1 117 0 1 1 121 0 27 1 125 0 35 1 129 0 37 1 133 0 38 1 137 0 40 1 141 0 41 1 229 0 85 1 149 0 88 1 153 0 90] #[0 0 254 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 2 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 6 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 10 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 14 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 18 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[1 1 22 0 36 1 233 0 83] #[1 1 26 0 2 1 237 0 6 1 26 0 36 1 241 0 86 1 245 0 87] #[1 1 117 0 1 1 30 0 2 1 249 0 3 1 253 0 4 2 1 0 5 1 30 0 6 1 121 0 27 1 125 0 35 1 30 0 36 1 129 0 37 1 133 0 38 2 5 0 39 1 137 0 40 1 141 0 41 2 9 0 89 2 13 0 90] #[1 0 66 0 1 0 66 0 2 0 66 0 6 0 66 0 27 0 66 0 28 0 66 0 29 0 66 0 31 0 66 0 32 0 66 0 36 0 66 0 42 0 66 0 43 2 17 0 95 1 29 0 96] #[0 2 21 0 36] #[1 0 66 0 1 0 66 0 2 0 66 0 6 0 66 0 27 0 66 0 28 0 66 0 29 0 66 0 31 0 66 0 32 0 66 0 42 0 66 0 43 2 25 0 94 1 25 0 95 1 29 0 96] #[0 1 34 0 2 0 6 0 36] #[0 1 38 0 2 0 6 0 36] #[1 2 29 0 28 2 33 0 44] #[1 1 42 0 1 1 42 0 2 2 37 0 3 2 41 0 4 2 45 0 5 1 42 0 6 1 42 0 27 1 42 0 28 1 42 0 29 1 42 0 31 1 42 0 32 1 42 0 36 1 42 0 42 1 42 0 43] #[0 1 46 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[1 1 50 0 1 1 50 0 2 1 50 0 3 1 50 0 4 1 50 0 5 1 50 0 6 1 50 0 27 1 50 0 28 1 50 0 29 1 50 0 31 1 50 0 32 2 49 0 33 1 50 0 36 1 50 0 42 1 50 0 43] #[0 1 54 0 28 0 36] #[1 1 58 0 2 1 58 0 28 2 53 0 62] #[1 1 62 0 2 1 62 0 28 2 57 0 61] #[0 1 66 0 27 0 28 0 29 0 36 0 42] #[0 1 70 0 27 0 36] #[0 1 74 0 28 0 36] #[0 1 78 0 27 0 28 0 35 0 100 0 101] #[0 1 82 0 28 0 36] #[1 2 61 0 28 1 86 0 36] #[0 2 65 0 2] #[0 2 69 0 36] #[1 1 117 0 1 1 121 0 27 1 125 0 35 1 129 0 37 1 133 0 38 1 137 0 40 1 141 0 41 2 73 0 88 1 153 0 90] #[0 1 90 0 2 0 6 0 36] #[1 1 94 0 2 1 237 0 6 1 94 0 36 2 77 0 86] #[0 1 98 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 102 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 106 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 110 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[1 1 117 0 1 1 114 0 2 1 114 0 6 1 121 0 27 1 125 0 35 1 114 0 36 1 129 0 37 1 133 0 38 1 137 0 40 1 141 0 41 2 81 0 90] #[1 1 118 0 1 1 118 0 2 1 249 0 3 1 253 0 4 2 1 0 5 1 118 0 6 1 118 0 27 1 118 0 35 1 118 0 36 1 118 0 37 1 118 0 38 2 5 0 39 1 118 0 40 1 118 0 41] #[0 1 122 0 2 0 6 0 36] #[0 1 126 0 27 0 28 0 35 0 100 0 101] #[1 2 85 0 2 1 157 0 6] #[0 2 89 0 44] #[0 1 130 0 2 0 6 0 36] #[0 1 134 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[0 1 138 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[0 1 142 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[0 1 146 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[1 2 93 0 2 2 97 0 28] #[1 2 101 0 2 2 105 0 28] #[0 1 150 0 28 0 36] #[0 1 154 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 35 0 36 0 37 0 38 0 39 0 40 0 41] #[0 1 158 0 27 0 28 0 35 0 100 0 101] #[0 1 162 0 2 0 6 0 36] #[0 1 166 0 2 0 6 0 36] #[1 1 170 0 1 1 170 0 2 1 249 0 3 1 253 0 4 2 1 0 5 1 170 0 6 1 170 0 27 1 170 0 35 1 170 0 36 1 170 0 37 1 170 0 38 2 5 0 39 1 170 0 40 1 170 0 41] #[0 1 174 0 1 0 2 0 3 0 4 0 5 0 6 0 27 0 28 0 29 0 31 0 32 0 36 0 42 0 43] #[0 1 178 0 2 0 6 0 36] #[0 1 182 0 36] #[0 1 186 0 2 0 28] #[0 1 190 0 36] #[0 1 194 0 2 0 28]	).! !!SmaCCDefinitionParser class methodsFor: 'generated-accessing'!scannerClass	^SmaCCDefinitionScanner! !!SmaCCDefinitionParser class methodsFor: 'generated-accessing'!cacheId	^'2019-04-17T19:47:03.912455-05:00'! !SmaCCScanner subclass: #SmaCCDefinitionScanner	instanceVariableNames: 'parseSourceSelector'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDefinitionScanner methodsFor: 'testing'!canParseSmalltalk: aString	RBParser parseExpression: aString onError: [ :error :pos | ^ false ].	^ true! !!SmaCCDefinitionScanner methodsFor: 'testing'!canParse: aString	^ self perform: parseSourceSelector with: aString! !!SmaCCDefinitionScanner methodsFor: 'initialize-release'!parseSourceSelector: aSymbol	parseSourceSelector := aSymbol! !!SmaCCDefinitionScanner methodsFor: 'initialize-release'!initialize	super initialize.	parseSourceSelector := #canParseSmalltalk:! !!SmaCCDefinitionScanner methodsFor: 'token-actions'!code	| code |	code := ''.	[ code := code , (stream upTo: $}).	self canParse: code ]		whileFalse: [ stream atEnd				ifTrue: [ ^ self scannerError ].			code := code , '}' ].	matchActions := Array with: self codeId.	^ self createTokenFor: '{' , code , '}'! !!SmaCCDefinitionScanner methodsFor: 'token-actions'!immediateCode	| code |	code := ''.	[ code := code , (stream upTo: $]).	self canParse: code ]		whileFalse: [ stream atEnd				ifTrue: [ ^ self scannerError ].			code := code , ']' ].	matchActions := Array with: self immediateCodeId.	^ self createTokenFor: '[' , code , ']'! !!SmaCCDefinitionScanner methodsFor: 'generated'!symbolnameId	^ 28! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan5	self step.	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue: [ ^ self scan6 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!productionId	^ 34! !!SmaCCDefinitionScanner methodsFor: 'generated'!emptySymbolTokenId	^ 100! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X4	self recordMatch: #(31).	self step.	currentCharacter == ${		ifTrue: [ ^ self recordAndReportMatch: #(43) ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X4	self recordMatch: #(26 40).	self step.	(currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ])		ifTrue: [ [ self recordMatch: #(26).			self step.			currentCharacter isSeparator				or: [ currentCharacter == Character pageUp ] ] whileTrue ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan6	[ self step.	currentCharacter == $>		ifTrue: [ ^ self recordAndReportMatch: #(27) ].	currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]		whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X6	self step.	currentCharacter == $}		ifTrue: [ ^ self recordAndReportMatch: #(44) ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan8	[ self step.	currentCharacter == $"		ifTrue: [ self recordMatch: #(29).			self step.			currentCharacter == $"				ifTrue: [ ^ self scan8 ].			^ self reportLastMatch ].	true ] whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!codeId	^ 31! !!SmaCCDefinitionScanner methodsFor: 'generated'!variablenameId	^ 33! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X5	[ self recordMatch: #(28).	self step.	currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]		whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan3	self recordMatch: #(34).	self step.	currentCharacter == $:		ifTrue: [ ^ self scan4 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X8	self recordMatch: #(34 40).	self step.	currentCharacter == $:		ifTrue: [ ^ self scan4 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX2X2	[ self recordMatch: #(26).	self step.	currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan7	[ self step.	currentCharacter == $`		ifTrue: [ ^ self recordAndReportMatch: #(45) ].	true ] whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X2	self recordMatch: #(30 40).	self step.	(currentCharacter <= Character tab		or: [ (currentCharacter between: Character pageUp and: Character newPage)				or: [ currentCharacter >= (Character value: 14) ] ])		ifTrue: [ [ self recordMatch: #(30).			self step.			currentCharacter <= Character tab				or: [ (currentCharacter between: Character pageUp and: Character newPage)						or: [ currentCharacter >= (Character value: 14) ] ] ] whileTrue ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!tokenActions	^ #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #whitespace nil nil nil #comment #code #immediateCode nil nil nil nil nil nil nil nil nil nil nil nil #patternToken)! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX1	self step.	currentCharacter == $#		ifTrue:			[ ^ self scanForTokenX1X1 ].	currentCharacter == $%		ifTrue: [ ^ self recordAndReportMatch: #(35) ].	currentCharacter == $(		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	currentCharacter == $)		ifTrue: [ ^ self recordAndReportMatch: #(2) ].	^ self scanForTokenX1X4! !!SmaCCDefinitionScanner methodsFor: 'generated'!classLeftId	^ 43! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X5	[ self step.	currentCharacter == $,		ifTrue: [ [ self step.			currentCharacter == $}				ifTrue: [ ^ self recordAndReportMatch: #(39) ].			currentCharacter isDigit ] whileTrue.			^ self reportLastMatch ].	currentCharacter isDigit ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX1X1	[ self recordMatch: #(30).	self step.	currentCharacter <= Character tab		or: [ (currentCharacter between: Character pageUp and: Character newPage)				or: [ currentCharacter >= (Character value: 14) ] ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!immediateCodeId	^ 32! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX1X2	[ self recordMatch: #(26).	self step.	currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan1	self step.	currentCharacter == $*		ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan11	[ self step.	currentCharacter == $\		ifTrue: [ ^ self scan12 ].	currentCharacter == $]		ifTrue: [ ^ self recordAndReportMatch: #(38) ].	true ] whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX1X3	[ self recordMatch: #(28).	self step.	currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]		whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX2X1	[ self recordMatch: #(30).	self step.	currentCharacter <= Character tab		or: [ (currentCharacter between: Character pageUp and: Character newPage)				or: [ currentCharacter >= (Character value: 14) ] ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X1	self step.	currentCharacter == $c		ifTrue: [ self step.			(currentCharacter between: $A and: $Z)				ifTrue: [ ^ self recordAndReportMatch: #(37) ].			^ self reportLastMatch ].	currentCharacter == $x		ifTrue: [ self step.			(currentCharacter isDigit				or: [ (currentCharacter between: $A and: $F)						or: [ currentCharacter between: $a and: $f ] ])				ifTrue: [ self recordMatch: #(37).					self step.					(currentCharacter isDigit						or: [ (currentCharacter between: $A and: $F)								or: [ currentCharacter between: $a and: $f ] ])						ifTrue: [ self recordMatch: #(37).							self step.							(currentCharacter isDigit								or: [ (currentCharacter between: $A and: $F)										or: [ currentCharacter between: $a and: $f ] ])								ifTrue: [ self recordMatch: #(37).									self step.									(currentCharacter isDigit										or: [ (currentCharacter between: $A and: $F)												or: [ currentCharacter between: $a and: $f ] ])										ifTrue: [ ^ self recordAndReportMatch: #(37) ] ] ] ].			^ self reportLastMatch ].	^ self recordAndReportMatch: #(37)! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX1X4	currentCharacter == $*		ifTrue: [ ^ self recordAndReportMatch: #(3) ].	currentCharacter == $+		ifTrue: [ ^ self recordAndReportMatch: #(4) ].	currentCharacter == $/		ifTrue: [ ^ self scan1 ].	currentCharacter == $:		ifTrue: [ ^ self scan3 ].	currentCharacter == $;		ifTrue: [ ^ self recordAndReportMatch: #(36) ].	currentCharacter == $<		ifTrue: [ ^ self scan5 ].	currentCharacter == $?		ifTrue: [ ^ self recordAndReportMatch: #(5) ].	currentCharacter == $`		ifTrue: [ ^ self scan7 ].	currentCharacter == $|		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	(currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ])		ifTrue:			[ ^ self scanForTokenX1X2 ].	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue:			[ self scanForTokenX1X3 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X1	[ self recordMatch: #(30).	self step.	currentCharacter <= Character tab		or: [ (currentCharacter between: Character pageUp and: Character newPage)				or: [ currentCharacter >= (Character value: 14) ] ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX2X3	[ self recordMatch: #(28).	self step.	currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]		whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!classRightId	^ 44! !!SmaCCDefinitionScanner methodsFor: 'generated'!semicolonId	^ 36! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X7	currentCharacter == $:		ifTrue: [ ^ self scan3 ].	currentCharacter == $;		ifTrue: [ ^ self recordAndReportMatch: #(36) ].	currentCharacter == $<		ifTrue: [ ^ self scan5 ].	currentCharacter == $?		ifTrue: [ ^ self recordAndReportMatch: #(5) ].	currentCharacter == $[		ifTrue: [ ^ self recordAndReportMatch: #(32) ].	currentCharacter == $`		ifTrue: [ ^ self scan7 ].	currentCharacter == ${		ifTrue:			[ ^ self scan9X4 ].	currentCharacter == $|		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	currentCharacter == $}		ifTrue:			[ ^ self scan9X6 ].	(currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ])		ifTrue:			[ ^ self scan9X3 ].	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue:			[ self scan9X5 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!keywordId	^ 29! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan4	self step.	currentCharacter == $=		ifTrue: [ ^ self recordAndReportMatch: #(34) ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!errorTokenId	^ 101! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X7	[ self recordMatch: #(26).	self step.	currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!directiveId	^ 35! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX2	self step.	currentCharacter == $"		ifTrue: [ ^ self scan8 ].	currentCharacter == $#		ifTrue:			[ ^ self scanForTokenX2X1 ].	currentCharacter == $%		ifTrue: [ ^ self recordAndReportMatch: #(35) ].	currentCharacter == $(		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	^ self scanForTokenX2X4! !!SmaCCDefinitionScanner methodsFor: 'generated'!tokennameId	^ 27! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X3	self step.	currentCharacter == $\		ifTrue: [ ^ self scan12 ].	(currentCharacter <= $[ or: [ currentCharacter >= $^ ])		ifTrue: [ ^ self scan11 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X6	self recordMatch: #(40).	self step.	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue: [ ^ self scan6 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10	self step.	currentCharacter == Character newPage		ifTrue: [ ^ self scan10X4 ].	currentCharacter == $#		ifTrue: [ ^ self scan10X2 ].	currentCharacter == $%		ifTrue: [ ^ self recordAndReportMatch: #(35 40) ].	currentCharacter == $(		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	currentCharacter == $)		ifTrue: [ ^ self recordAndReportMatch: #(2 40) ].	currentCharacter == $*		ifTrue: [ ^ self recordAndReportMatch: #(3 40) ].	currentCharacter == $+		ifTrue: [ ^ self recordAndReportMatch: #(4 40) ].	^ self scan10X10! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X3	[ self recordMatch: #(26).	self step.	currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ] ] whileTrue.	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9	self step.	currentCharacter == $"		ifTrue: [ ^ self scan8 ].	currentCharacter == $#		ifTrue:			[ ^ self scan9X1 ].	currentCharacter == $%		ifTrue: [ ^ self recordAndReportMatch: #(35) ].	currentCharacter == $'		ifTrue:			[ ^ self scan9X2 ].	currentCharacter == $(		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	currentCharacter == $)		ifTrue: [ ^ self recordAndReportMatch: #(2) ].	currentCharacter == $*		ifTrue: [ ^ self recordAndReportMatch: #(3) ].	currentCharacter == $+		ifTrue: [ ^ self recordAndReportMatch: #(4) ].	currentCharacter == $/		ifTrue: [ ^ self scan1 ].	^ self scan9X7! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForToken	scope == #parser		ifTrue: [ ^ self scan9 ].	scope == #directives		ifTrue:			[ ^ self scanForTokenX2 ].	scope == #default		ifTrue:			[ ^ self scanForTokenX1 ].	scope == #scanner		ifTrue: [ ^ self scan10 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scanForTokenX2X4	currentCharacter == $)		ifTrue: [ ^ self recordAndReportMatch: #(2) ].	currentCharacter == $*		ifTrue: [ ^ self recordAndReportMatch: #(3) ].	currentCharacter == $+		ifTrue: [ ^ self recordAndReportMatch: #(4) ].	currentCharacter == $/		ifTrue: [ ^ self scan1 ].	currentCharacter == $:		ifTrue: [ ^ self scan3 ].	currentCharacter == $;		ifTrue: [ ^ self recordAndReportMatch: #(36) ].	currentCharacter == $<		ifTrue: [ ^ self scan5 ].	currentCharacter == $?		ifTrue: [ ^ self recordAndReportMatch: #(5) ].	currentCharacter == $|		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	(currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ])		ifTrue:			[ ^ self scanForTokenX2X2 ].	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue:			[ self scanForTokenX2X3 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X10	currentCharacter == $.		ifTrue: [ ^ self recordAndReportMatch: #(41) ].	currentCharacter == $/		ifTrue: [ ^ self scan10X9 ].	currentCharacter == $:		ifTrue: [ ^ self scan10X8 ].	currentCharacter == $;		ifTrue: [ ^ self recordAndReportMatch: #(36 40) ].	currentCharacter == $<		ifTrue: [ ^ self scan10X6 ].	currentCharacter == $?		ifTrue: [ ^ self recordAndReportMatch: #(5 40) ].	currentCharacter == $[		ifTrue: [ ^ self scan10X3 ].	currentCharacter == $\		ifTrue: [ ^ self scan10X1 ].	currentCharacter == ${		ifTrue: [ ^ self scan10X5 ].	currentCharacter == $|		ifTrue: [ ^ self recordAndReportMatch: #(6 40) ].	(currentCharacter isSeparator		or: [ currentCharacter == Character pageUp ])		ifTrue: [ ^ self scan10X7 ].	^ self recordAndReportMatch: #(40)! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan9X2	self step.	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue: [ [ self step.			currentCharacter == $'				ifTrue: [ ^ self recordAndReportMatch: #(33) ].			currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]				whileTrue ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan10X9	self recordMatch: #(40).	self step.	currentCharacter == $*		ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan2	[ self step.	currentCharacter == $*		ifTrue: [ [ self step.			currentCharacter == $* ] whileTrue.			currentCharacter == $/				ifTrue: [ ^ self recordAndReportMatch: #(30) ].			^ self scan2 ].	true ] whileTrue! !!SmaCCDefinitionScanner methodsFor: 'generated'!scan12	self step.	currentCharacter == $c		ifTrue: [ self step.			(currentCharacter between: $A and: $Z)				ifTrue: [ ^ self scan11 ].			^ self reportLastMatch ].	currentCharacter == $x		ifTrue: [ self step.			(currentCharacter isDigit				or: [ (currentCharacter between: $A and: $F)						or: [ currentCharacter between: $a and: $f ] ])				ifTrue: [ ^ self scan11 ].			^ self reportLastMatch ].	^ self scan11! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDefinitionScanner class	instanceVariableNames: ''!!SmaCCDefinitionScanner class methodsFor: 'generated-initialization'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(28 'annotate_tokens' #(22 #(#directives))) #(28 'attributes' #(11 #(#directives))) #(28 'byte' #(25 #(#directives))) #(28 'error' #(42 #(#parser))) #(28 'excludes' #(8 #(#directives))) #(28 'glr' #(19 #(#directives))) #(28 'hierarchy' #(10 #(#directives))) #(28 'id' #(17 #(#directives))) #(28 'ignore_variables' #(21 #(#directives))) #(28 'ignorecase' #(20 #(#directives))) #(28 'left' #(14 #(#directives))) #(28 'lr1' #(23 #(#directives))) #(28 'nonassoc' #(16 #(#directives))) #(28 'prefix' #(12 #(#directives))) #(28 'right' #(15 #(#directives))) #(28 'root' #(9 #(#directives))) #(28 'scopes' #(7 #(#directives))) #(28 'start' #(18 #(#directives))) #(28 'states' #(7 #(#directives))) #(28 'suffix' #(13 #(#directives))) #(28 'unicode' #(24 #(#directives))))		do: [ :each | 			(keywordMap at: each first ifAbsentPut: [ Dictionary new ])				at: (each at: 2)				put: each last ].	^ keywordMap! !SmaCCDefinitionNode subclass: #SmaCCDirectiveNode	instanceVariableNames: 'directiveStartToken semicolon'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ self subclassResponsibility! !!SmaCCDirectiveNode methodsFor: 'testing'!isDirective	^ true! !!SmaCCDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#directiveStartToken #semicolon)! !!SmaCCDirectiveNode methodsFor: 'generated'!semicolon: aSmaCCToken	semicolon := aSmaCCToken! !!SmaCCDirectiveNode methodsFor: 'generated'!semicolon	^ semicolon! !!SmaCCDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitDirective: self! !!SmaCCDirectiveNode methodsFor: 'generated'!directiveStartToken	^ directiveStartToken! !!SmaCCDirectiveNode methodsFor: 'generated'!directiveStartToken: aSmaCCToken	directiveStartToken := aSmaCCToken! !SmaCCDirectiveNode subclass: #SmaCCAssociativeDirectiveNode	instanceVariableNames: 'typeToken symbols'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCAssociativeDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	symbols := OrderedCollection new: 2.! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#typeToken #directiveStartToken #semicolon)! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!symbols	^ symbols! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!symbols: anOrderedCollection	self setParents: self symbols to: nil.	symbols := anOrderedCollection.	self setParents: self symbols to: self! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitAssociativeDirective: self! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!compositeNodeVariables	^ #(#symbols)! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!typeToken	^ typeToken! !!SmaCCAssociativeDirectiveNode methodsFor: 'generated'!typeToken: aSmaCCToken	typeToken := aSmaCCToken! !!SmaCCAssociativeDirectiveNode methodsFor: 'testing'!isAssociativeDirective	^ true! !!SmaCCAssociativeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , typeToken value! !!SmaCCAssociativeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ typeToken! !SmaCCDirectiveNode subclass: #SmaCCAttributeDirectiveNode	instanceVariableNames: 'attributesToken classname leftParen names rightParen'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCAttributeDirectiveNode methodsFor: 'testing'!isAttributeDirective	^ true! !!SmaCCAttributeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , attributesToken value! !!SmaCCAttributeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ attributesToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!attributesToken: aSmaCCToken	attributesToken := aSmaCCToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#names)! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#attributesToken #classname #leftParen #rightParen #directiveStartToken #semicolon)! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!names	^ names! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!classname	^ classname! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!names: anOrderedCollection	names := anOrderedCollection! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!classname: aSmaCCToken	classname := aSmaCCToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitAttributeDirective: self! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!rightParen	^ rightParen! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!rightParen: aSmaCCToken	rightParen := aSmaCCToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!leftParen	^ leftParen! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!attributesToken	^ attributesToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated'!leftParen: aSmaCCToken	leftParen := aSmaCCToken! !!SmaCCAttributeDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	names := OrderedCollection new: 2.! !SmaCCDirectiveNode subclass: #SmaCCFlagDirectiveNode	instanceVariableNames: 'typeToken'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCFlagDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , typeToken value! !!SmaCCFlagDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ typeToken! !!SmaCCFlagDirectiveNode methodsFor: 'testing'!isFlagDirective	^ true! !!SmaCCFlagDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#typeToken #directiveStartToken #semicolon)! !!SmaCCFlagDirectiveNode methodsFor: 'generated'!typeToken	^ typeToken! !!SmaCCFlagDirectiveNode methodsFor: 'generated'!typeToken: aSmaCCToken	typeToken := aSmaCCToken! !!SmaCCFlagDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitFlagDirective: self! !SmaCCDefinitionNode subclass: #SmaCCGrammarDefinitionNode	instanceVariableNames: 'rules'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCGrammarDefinitionNode methodsFor: 'acccessing'!tokenRules	^ rules select: [ :each | each isKindOf: SmaCCTokenRuleNode ]! !!SmaCCGrammarDefinitionNode methodsFor: 'acccessing'!definitionNamed: aString	^ (self tokenNamed: aString) ifNil: [ self productionNamed: aString ]! !!SmaCCGrammarDefinitionNode methodsFor: 'acccessing'!productionRules	^ rules select: [ :each | each isKindOf: SmaCCProductionRuleNode ]! !!SmaCCGrammarDefinitionNode methodsFor: 'acccessing'!tokenNamed: aString	^ self tokenRules detect: [ :each | each name value = aString ] ifNone: [ nil ]! !!SmaCCGrammarDefinitionNode methodsFor: 'acccessing'!productionNamed: aString	^ self productionRules detect: [ :each | each name value = aString ] ifNone: [ nil ]! !!SmaCCGrammarDefinitionNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	rules := OrderedCollection new: 2.! !!SmaCCGrammarDefinitionNode methodsFor: 'generated'!rules: anOrderedCollection	self setParents: self rules to: nil.	rules := anOrderedCollection.	self setParents: self rules to: self! !!SmaCCGrammarDefinitionNode methodsFor: 'generated'!rules	^ rules! !!SmaCCGrammarDefinitionNode methodsFor: 'generated'!compositeNodeVariables	^ #(#rules)! !!SmaCCGrammarDefinitionNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitGrammarDefinition: self! !SmaCCDefinitionNode subclass: #SmaCCGroupTermNode	instanceVariableNames: 'leftParen barTokens expressions rightParen'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCGroupTermNode methodsFor: 'iterating'!alternativesDo: aBlock	expressions do: [ :each | aBlock value: each terms ]! !!SmaCCGroupTermNode methodsFor: 'accessing'!allPossibilities	^ self hasReductionExpression		ifTrue: [ 1 ]		ifFalse: [ (expressions inject: 0 into: [ :sum :each | sum + each allPossibilities ]) max: 1 ]! !!SmaCCGroupTermNode methodsFor: 'accessing'!possibilities	^ self hasReductionExpression		ifTrue: [ 1 ]		ifFalse: [ expressions size ]! !!SmaCCGroupTermNode methodsFor: 'accessing'!variableNameToken	^ nil! !!SmaCCGroupTermNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	barTokens := OrderedCollection new: 2.	expressions := OrderedCollection new: 2.! !!SmaCCGroupTermNode methodsFor: 'generated'!compositeTokenVariables	^ #(#barTokens)! !!SmaCCGroupTermNode methodsFor: 'generated'!expressions: anOrderedCollection	self setParents: self expressions to: nil.	expressions := anOrderedCollection.	self setParents: self expressions to: self! !!SmaCCGroupTermNode methodsFor: 'generated'!tokenVariables	^ #(#leftParen #rightParen)! !!SmaCCGroupTermNode methodsFor: 'generated'!barTokens	^ barTokens! !!SmaCCGroupTermNode methodsFor: 'generated'!rightParen	^ rightParen! !!SmaCCGroupTermNode methodsFor: 'generated'!compositeNodeVariables	^ #(#expressions)! !!SmaCCGroupTermNode methodsFor: 'generated'!rightParen: aSmaCCToken	rightParen := aSmaCCToken! !!SmaCCGroupTermNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitGroupTerm: self! !!SmaCCGroupTermNode methodsFor: 'generated'!expressions	^ expressions! !!SmaCCGroupTermNode methodsFor: 'generated'!leftParen	^ leftParen! !!SmaCCGroupTermNode methodsFor: 'generated'!barTokens: anOrderedCollection	barTokens := anOrderedCollection! !!SmaCCGroupTermNode methodsFor: 'generated'!leftParen: aSmaCCToken	leftParen := aSmaCCToken! !!SmaCCGroupTermNode methodsFor: 'testing'!hasReductionExpression	^ expressions anySatisfy: [ :each | each hasReductionExpression ]! !!SmaCCGroupTermNode methodsFor: 'testing'!isGroup	^ true! !SmaCCDirectiveNode subclass: #SmaCCIdDirectiveNode	instanceVariableNames: 'idToken names'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCIdDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	names := OrderedCollection new: 2.! !!SmaCCIdDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%id'! !!SmaCCIdDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ idToken! !!SmaCCIdDirectiveNode methodsFor: 'testing'!isIdDirective	^ true! !!SmaCCIdDirectiveNode methodsFor: 'generated'!idToken	^ idToken! !!SmaCCIdDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#names)! !!SmaCCIdDirectiveNode methodsFor: 'generated'!names	^ names! !!SmaCCIdDirectiveNode methodsFor: 'generated'!idToken: aSmaCCToken	idToken := aSmaCCToken! !!SmaCCIdDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitIdDirective: self! !!SmaCCIdDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#idToken #directiveStartToken #semicolon)! !!SmaCCIdDirectiveNode methodsFor: 'generated'!names: anOrderedCollection	names := anOrderedCollection! !SmaCCDirectiveNode subclass: #SmaCCIgnoreVariableDirectiveNode	instanceVariableNames: 'ignoreVariablesToken names'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCIgnoreVariableDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , ignoreVariablesToken value! !!SmaCCIgnoreVariableDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ ignoreVariablesToken! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	names := OrderedCollection new: 2.! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'testing'!isIgnoreDirective	^ true! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!ignoreVariablesToken: aSmaCCToken	ignoreVariablesToken := aSmaCCToken! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#names)! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!names	^ names! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#ignoreVariablesToken #directiveStartToken #semicolon)! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!ignoreVariablesToken	^ ignoreVariablesToken! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitIgnoreVariableDirective: self! !!SmaCCIgnoreVariableDirectiveNode methodsFor: 'generated'!names: anOrderedCollection	names := anOrderedCollection! !SmaCCDirectiveNode subclass: #SmaCCNodeNameDirectiveNode	instanceVariableNames: 'typeToken name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#typeToken #name #directiveStartToken #semicolon)! !!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitNodeNameDirective: self! !!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!name	^ name! !!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!typeToken	^ typeToken! !!SmaCCNodeNameDirectiveNode methodsFor: 'generated'!typeToken: aSmaCCToken	typeToken := aSmaCCToken! !!SmaCCNodeNameDirectiveNode methodsFor: 'testing'!isNameDirective	^ true! !!SmaCCNodeNameDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , typeToken value! !!SmaCCNodeNameDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ typeToken! !SmaCCDefinitionNode subclass: #SmaCCPostfixTermNode	instanceVariableNames: 'term operator'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCPostfixTermNode methodsFor: 'testing'!isOptional	^ operator value = '?'! !!SmaCCPostfixTermNode methodsFor: 'generated'!tokenVariables	^ #(#operator)! !!SmaCCPostfixTermNode methodsFor: 'generated'!term	^ term! !!SmaCCPostfixTermNode methodsFor: 'generated'!nodeVariables	^ #(#term)! !!SmaCCPostfixTermNode methodsFor: 'generated'!operator	^ operator! !!SmaCCPostfixTermNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitPostfixTerm: self! !!SmaCCPostfixTermNode methodsFor: 'generated'!term: aSmaCCDefinitionNode	self term notNil		ifTrue: [ self term parent: nil ].	term := aSmaCCDefinitionNode.	self term notNil		ifTrue: [ self term parent: self ]! !!SmaCCPostfixTermNode methodsFor: 'generated'!operator: aSmaCCToken	operator := aSmaCCToken! !!SmaCCPostfixTermNode methodsFor: 'accessing'!allPossibilities	self isOptional		ifTrue: [ ^ term allPossibilities + 1 ].	^ 1! !!SmaCCPostfixTermNode methodsFor: 'accessing'!possibilities	^ self isOptional		ifTrue: [ 2 ]		ifFalse: [ 1 ]! !!SmaCCPostfixTermNode methodsFor: 'accessing'!variableNameToken	^ nil! !!SmaCCPostfixTermNode methodsFor: 'iterating'!alternativesDo: aBlock	self isOptional		ifTrue: [ aBlock value: #().			aBlock value: (Array with: term) ]		ifFalse: [ aBlock value: (Array with: self) ]! !SmaCCDefinitionNode subclass: #SmaCCProductionExpressionNode	instanceVariableNames: 'terms'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCProductionExpressionNode methodsFor: 'accessing'!allPossibilities	^ terms inject: 1 into: [ :sum :each | sum * each allPossibilities ]! !!SmaCCProductionExpressionNode methodsFor: 'testing'!hasReductionExpression	^ self class ~= SmaCCProductionExpressionNode! !!SmaCCProductionExpressionNode methodsFor: 'testing'!isEmptyExpression	^ self terms isEmpty! !!SmaCCProductionExpressionNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	terms := OrderedCollection new: 2.! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!updateSource: aSmaCCString	| position index |	self hasNodeDefined		ifFalse: [ ^ self ].	self terms isEmpty		ifTrue: [ index := self parent expressions identityIndexOf: self.			position := index = 1				ifTrue: [ aSmaCCString nextIndex: self parent colon stopPosition ]				ifFalse: [ aSmaCCString nextIndex: (self parent barTokens at: index - 1) stopPosition ] ]		ifFalse: [ position := aSmaCCString nextIndex: self stopPosition ].	aSmaCCString insert: ' {{' , self astNodeName , '}}' at: position! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!buildASTNodeInterfaceElement	| toggle element label textEditor editorElement textChangedBlock |	textEditor := BrTextEditor new.	element := BlElement new.	element		constraintsDo: [ :c | 			c horizontal matchParent.			c vertical fitContent ].	element layout: BlFlowLayout horizontal.	label := BlTextElement text: self styledProductionLabel asRopedText.	label margin: (BlInsets all: 7).	toggle := BrToggle new		look: BrMaterialToggleLabelledLook;		label: 'AST';		margin: (BlInsets all: 1).	toggle activated: self hasNodeDefined.	toggle viewModel		when: BrToggleActivatedEvent do: [ self definesNode: true ];		when: BrToggleDeactivatedEvent			do: [ self definesNode: false.			self removeAttributeNamed: #astNodeName.			textEditor text: '' asRopedText ].	textEditor text: self astNodeName asRopedText.	textChangedBlock := [ :event | 	| astNode |	astNode := textEditor text asString.	(astNode notEmpty and: [ toggle isActivated not ])		ifTrue: [ toggle activate.			self definesNode: true ].	self astNodeName: astNode ].	textEditor		when: BrTextEditorInsertedEvent do: textChangedBlock;		when: BrTextEditorDeletedEvent do: textChangedBlock.	editorElement := BrEditorElement new.	editorElement editor: textEditor.	editorElement size: 200 @ 23.	editorElement		border: (BlBorder paint: Color lightGray);		margin: (BlInsets all: 4).	element addChild: toggle.	element addChild: editorElement.	element addChild: label.	^ element! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!astNodeName: aString	^ self attributeNamed: #astNodeName put: aString! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!definesNode: aBoolean	^ self attributeNamed: #hasNodeDefined put: aBoolean! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!astNodeName	^ self attributeNamed: #astNodeName ifAbsent: [ self originalAstNodeName ]! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!styledProductionLabel	^ self styledText! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!originalAstNodeName	^ ''! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!hasNodeDefined	^ self attributeNamed: #hasNodeDefined ifAbsent: [ self class == SmaCCClassProductionExpressionNode ]! !!SmaCCProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!styledText	| text rule |	rule := self parentOfType: SmaCCProductionRuleNode.	text := rule source asRopedText.	text		attributes: SmaCCParserGeneratorPresentation defaultTextAttributes.	GtSmaCCGrammarStyler new style: text.	^ text		copyFrom: self startPosition - rule startPosition + 1		to: self stopPosition - rule startPosition + 1! !!SmaCCProductionExpressionNode methodsFor: 'generated'!terms	^ terms! !!SmaCCProductionExpressionNode methodsFor: 'generated'!terms: anOrderedCollection	self setParents: self terms to: nil.	terms := anOrderedCollection.	self setParents: self terms to: self! !!SmaCCProductionExpressionNode methodsFor: 'generated'!compositeNodeVariables	^ #(#terms)! !!SmaCCProductionExpressionNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitProductionExpression: self! !SmaCCProductionExpressionNode subclass: #SmaCCClassProductionExpressionNode	instanceVariableNames: 'left classname right'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCClassProductionExpressionNode methodsFor: 'generated'!right: aSmaCCToken	right := aSmaCCToken! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!classname: aSmaCCToken	classname := aSmaCCToken! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!tokenVariables	^ #(#left #classname #right)! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!left	^ left! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitClassProductionExpression: self! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!classname	^ classname! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!left: aSmaCCToken	left := aSmaCCToken! !!SmaCCClassProductionExpressionNode methodsFor: 'generated'!right	^ right! !!SmaCCClassProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!updateSource: aSmaCCString	self hasNodeDefined		ifTrue: [ self astNodeName = self originalAstNodeName				ifFalse: [ classname isNil						ifFalse: [ aSmaCCString deleteFrom: classname startPosition to: classname stopPosition ].					aSmaCCString insert: self astNodeName at: right startPosition ] ]		ifFalse: [ aSmaCCString deleteFrom: left startPosition to: right stopPosition ]! !!SmaCCClassProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!styledProductionLabel	| text |	text := super styledProductionLabel.	^ text copyFrom: 1 to: left startPosition - self startPosition! !!SmaCCClassProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!nodeName	^ classname isNil		ifTrue: [ (self nodeOfType: SmaCCProductionRuleNode) nodeName ]		ifFalse: [ classname value ]! !!SmaCCClassProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!originalAstNodeName	^ classname isNil		ifTrue: [ '' ]		ifFalse: [ classname value ]! !SmaCCProductionExpressionNode subclass: #SmaCCCodeProductionExpressionNode	instanceVariableNames: 'code'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCCodeProductionExpressionNode methodsFor: 'generated'!code	^ code! !!SmaCCCodeProductionExpressionNode methodsFor: 'generated'!tokenVariables	^ #(#code)! !!SmaCCCodeProductionExpressionNode methodsFor: 'generated'!code: aSmaCCToken	code := aSmaCCToken! !!SmaCCCodeProductionExpressionNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitCodeProductionExpression: self! !!SmaCCCodeProductionExpressionNode methodsFor: '*GT4SmaCC-Development-UI'!styledProductionLabel	| text |	text := super styledProductionLabel.	^ text copyFrom: 1 to: code startPosition - self startPosition! !SmaCCDefinitionNode subclass: #SmaCCProductionRuleNode	instanceVariableNames: 'name colon barTokens expressions semicolon'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCProductionRuleNode methodsFor: 'testing'!isProductionRule	^ true! !!SmaCCProductionRuleNode methodsFor: 'generated'!compositeTokenVariables	^ #(#barTokens)! !!SmaCCProductionRuleNode methodsFor: 'generated'!expressions: anOrderedCollection	self setParents: self expressions to: nil.	expressions := anOrderedCollection.	self setParents: self expressions to: self! !!SmaCCProductionRuleNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCProductionRuleNode methodsFor: 'generated'!semicolon: aSmaCCToken	semicolon := aSmaCCToken! !!SmaCCProductionRuleNode methodsFor: 'generated'!barTokens	^ barTokens! !!SmaCCProductionRuleNode methodsFor: 'generated'!tokenVariables	^ #(#name #colon #semicolon)! !!SmaCCProductionRuleNode methodsFor: 'generated'!name	^ name! !!SmaCCProductionRuleNode methodsFor: 'generated'!compositeNodeVariables	^ #(#expressions)! !!SmaCCProductionRuleNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitProductionRule: self! !!SmaCCProductionRuleNode methodsFor: 'generated'!semicolon	^ semicolon! !!SmaCCProductionRuleNode methodsFor: 'generated'!expressions	^ expressions! !!SmaCCProductionRuleNode methodsFor: 'generated'!colon: aSmaCCToken	colon := aSmaCCToken! !!SmaCCProductionRuleNode methodsFor: 'generated'!barTokens: anOrderedCollection	barTokens := anOrderedCollection! !!SmaCCProductionRuleNode methodsFor: 'generated'!colon	^ colon! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!buildInterfaceIn: presentation	self buildASTNodeInterfaceIn: presentation.	self buildVariableNameInterfaceFor: name value in: presentation.	presentation list		title: 'References';		display: [ self ruleReferences ];		format: [ :each | each displayString ];		tags: [ :each | each tags ].	presentation list		title: 'Uses';		display: [ self uses ];		format: [ :each | each displayString ];		tags: [ :each | each tags ].	self buildSourceInterfaceIn: presentation label: 'Definition'! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ name value! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!nodeName	^ String		streamContents: [ :stream | 			| nextIsUppercase |			nextIsUppercase := true.			name source				do: [ :each | 					each = $_						ifTrue: [ nextIsUppercase := true ]						ifFalse: [ stream								nextPut:									(nextIsUppercase										ifTrue: [ each asUppercase ]										ifFalse: [ each ]).							nextIsUppercase := false ] ] ]! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!ruleReferences	^ self ruleReferencesTo: self name value! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!tags	| hasClass noClass code tags |	hasClass := noClass := code := false.	self expressions		do: [ :each | 			(each isKindOf: SmaCCClassProductionExpressionNode)				ifTrue: [ hasClass := true ]				ifFalse: [ (each isKindOf: SmaCCCodeProductionExpressionNode)						ifTrue: [ code := true ]						ifFalse: [ noClass := true ] ] ].	tags := OrderedCollection new.	hasClass		ifTrue: [ tags add: 'AST' ].	code		ifTrue: [ tags add: 'Expression' ].	noClass		ifTrue: [ tags add: 'Default' ].	^ tags asArray! !!SmaCCProductionRuleNode methodsFor: '*GT4SmaCC-Development-UI'!buildASTNodeInterfaceIn: presentation	| bloc |	bloc := presentation bloc.	bloc title: 'AST'.	bloc		element: [ | element |			element := BlElement new.			element				constraintsDo: [ :c | 					c horizontal matchParent.					c vertical matchParent ].			element layout: BlFlowLayout vertical.			self expressions				do: [ :each | 					| nodeElement |					nodeElement := each buildASTNodeInterfaceElement.					element addChild: nodeElement.					element						addChild:							(BlLineElement new								fromAnchor: (BlElementBottomLeftAnchor element: nodeElement);								toAnchor: (BlElementBottomRightAnchor element: nodeElement);								height: 2;								border: (BlBorder paint: (Color black alpha: 0.75) width: 1)) ].			element ]! !!SmaCCProductionRuleNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	barTokens := OrderedCollection new: 2.	expressions := OrderedCollection new: 2.! !SmaCCDefinitionNode subclass: #SmaCCRegexNode	instanceVariableNames: 'leftParens rightParens'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!newlineString	^ SmaCCCharacterSet with: (Character value: 10)! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isDigit: each	^ each between: $0 and: $9! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!whitespaceValues	^ #[9 10 11 12 13 32]! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!tabString	^ SmaCCCharacterSet withAll: '	'! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!carriageReturnString	^ SmaCCCharacterSet with: (Character value: 13)! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isWhitespace: each	^ self whitespaceValues includes: each asInteger! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!hexStringFrom: aStream	^ SmaCCCharacterSet with: (Character value: (self hexValueFrom: aStream))! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ self subclassResponsibility! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!verticalTabString	^ SmaCCCharacterSet with: (Character value: 11)! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!allCharacters	^ SmaCCGrammar allCharacters! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!formFeedString	^ SmaCCCharacterSet with: (Character value: 12)! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isLetterOrDigit: each	^ (each between: $a and: $z) or: [ (each between: $A and: $Z) or: [ (self isDigit: each) or: [ each == $_ ] ] ]! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!hexValueFrom: aStream	| char value count |	count := value := 0.	[ aStream atEnd not		and: [ count < 4				and: [ char := aStream peek.					(char between: $0 and: $9) or: [ (char between: $A and: $F) or: [ char between: $a and: $f ] ] ] ] ]		whileTrue: [ count := count + 1.			value := value * 16 + aStream next digitValue ].	^ value! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!nodeFor: aStream	| block char |	block := nil.	char := aStream next.	char == $f		ifTrue: [ ^ SmaCCCharacterRENode characters: self formFeedString ].	char == $n		ifTrue: [ ^ SmaCCCharacterRENode characters: self newlineString ].	char == $r		ifTrue: [ ^ SmaCCCharacterRENode characters: self carriageReturnString ].	char == $t		ifTrue: [ ^ SmaCCCharacterRENode characters: self tabString ].	char == $v		ifTrue: [ ^ SmaCCCharacterRENode characters: self verticalTabString ].	char == $c		ifTrue: [ ^ SmaCCCharacterRENode characters: (SmaCCCharacterSet with: (Character value: aStream next asInteger - $A asInteger)) ].	char == $x		ifTrue: [ ^ SmaCCCharacterRENode characters: (self hexStringFrom: aStream) ].	char == $d		ifTrue: [ block := [ :each | self isDigit: each ] ].	char == $D		ifTrue: [ block := [ :each | (self isDigit: each) not ] ].	char == $s		ifTrue: [ block := [ :each | self isWhitespace: each ] ].	char == $S		ifTrue: [ block := [ :each | (self isWhitespace: each) not ] ].	char == $w		ifTrue: [ block := [ :each | self isLetterOrDigit: each ] ].	char == $W		ifTrue: [ block := [ :each | (self isLetterOrDigit: each) not ] ].	block isNil		ifTrue: [ ^ SmaCCCharacterRENode characters: (SmaCCCharacterSet with: char) ].	^ SmaCCCharacterRENode characters: (self allCharacters select: block)! !!SmaCCRegexNode methodsFor: '*SmaCC_Development'!regularExpression	^ self attributeNamed: #regularExpression ifAbsentPut: [ self asRegularExpression ]! !!SmaCCRegexNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	leftParens := OrderedCollection new: 2.	rightParens := OrderedCollection new: 2.! !!SmaCCRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	leftParens do: aBlock.	rightParens do: aBlock! !!SmaCCRegexNode methodsFor: 'generated'!compositeTokenVariables	^ #(#leftParens #rightParens)! !!SmaCCRegexNode methodsFor: 'generated'!leftParens: anOrderedCollection	leftParens := anOrderedCollection! !!SmaCCRegexNode methodsFor: 'generated'!leftParens	^ leftParens! !!SmaCCRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitRegex: self! !!SmaCCRegexNode methodsFor: 'generated'!rightParens: anOrderedCollection	rightParens := anOrderedCollection! !!SmaCCRegexNode methodsFor: 'generated'!rightParens	^ rightParens! !SmaCCRegexNode subclass: #SmaCCAlternationRegexNode	instanceVariableNames: 'items barTokens'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCAlternationRegexNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	items := OrderedCollection new: 2.	barTokens := OrderedCollection new: 2.! !!SmaCCAlternationRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ SmaCCOrRENode nodes: (self items collect: [ :each | each regularExpression ])! !!SmaCCAlternationRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	super testTokensDo: aBlock.	barTokens do: aBlock! !!SmaCCAlternationRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testIntervalsDo: aBlock	barTokens do: [ :each | aBlock value: each startPosition value: each stopPosition ]! !!SmaCCAlternationRegexNode methodsFor: 'generated'!compositeTokenVariables	^ #(#barTokens #leftParens #rightParens)! !!SmaCCAlternationRegexNode methodsFor: 'generated'!items: anOrderedCollection	self setParents: self items to: nil.	items := anOrderedCollection.	self setParents: self items to: self! !!SmaCCAlternationRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitAlternationRegex: self! !!SmaCCAlternationRegexNode methodsFor: 'generated'!barTokens	^ barTokens! !!SmaCCAlternationRegexNode methodsFor: 'generated'!barTokens: anOrderedCollection	barTokens := anOrderedCollection! !!SmaCCAlternationRegexNode methodsFor: 'generated'!compositeNodeVariables	^ #(#items)! !!SmaCCAlternationRegexNode methodsFor: 'generated'!items	^ items! !SmaCCRegexNode subclass: #SmaCCCharacterBlockRegexNode	instanceVariableNames: 'block'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCCharacterBlockRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	super testTokensDo: aBlock.	aBlock value: block! !!SmaCCCharacterBlockRegexNode methodsFor: 'generated'!block: aSmaCCToken	block := aSmaCCToken! !!SmaCCCharacterBlockRegexNode methodsFor: 'generated'!tokenVariables	^ #(#block)! !!SmaCCCharacterBlockRegexNode methodsFor: 'generated'!block	^ block! !!SmaCCCharacterBlockRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitCharacterBlockRegex: self! !!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| characters aStream invert node |	aStream := ReadStream on: (block value copyFrom: 2 to: block value size - 1).	characters := OrderedCollection new.	invert := aStream peekFor: $^.	[ aStream atEnd ] whileFalse: [ characters addAll: (self charactersFor: aStream) ].	node := SmaCCCharacterRENode characters: (SmaCCCharacterSet withAll: characters).	invert		ifTrue: [ node := SmaCCNotRENode on: node ].	^ node! !!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!reportCharacterBlockError	SmaCCParserError new		messageText: 'Invalid character block';		tag: block;		signal! !!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!charactersFor: aStream	| characters char endCharacters |	aStream atEnd		ifTrue: [ self reportCharacterBlockError ].	char := aStream next.	characters := char == $\		ifTrue: [ (self nodeFor: aStream) characters ]		ifFalse: [ OrderedCollection with: char ].	(characters size = 1 and: [ aStream peekFor: $- ])		ifFalse: [ ^ characters ].	endCharacters := self charactersFor: aStream.	endCharacters size > 1		ifTrue: [ self reportCharacterBlockError ].	^ (characters first asInteger to: endCharacters first asInteger) collect: [ :each | Character value: each ]! !SmaCCRegexNode subclass: #SmaCCCharacterRegexNode	instanceVariableNames: 'char'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCCharacterRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| ch |	ch := self char value.	ch = '.'		ifTrue: [ ^ SmaCCCharacterRENode characters: self allCharacters ].	ch first = $\		ifTrue: [ ^ self nodeFor: (ReadStream on: (ch copyFrom: 2 to: ch size)) ].	^ SmaCCCharacterRENode characters: (SmaCCCharacterSet withAll: ch)! !!SmaCCCharacterRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	super testTokensDo: aBlock.	aBlock value: char! !!SmaCCCharacterRegexNode methodsFor: 'generated'!tokenVariables	^ #(#char)! !!SmaCCCharacterRegexNode methodsFor: 'generated'!char	^ char! !!SmaCCCharacterRegexNode methodsFor: 'generated'!char: aSmaCCToken	char := aSmaCCToken! !!SmaCCCharacterRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitCharacterRegex: self! !SmaCCRegexNode subclass: #SmaCCConcatenationRegexNode	instanceVariableNames: 'items'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCConcatenationRegexNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	items := OrderedCollection new: 2.! !!SmaCCConcatenationRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ SmaCCSequenceRENode nodes: (self items collect: [ :each | each regularExpression ])! !!SmaCCConcatenationRegexNode methodsFor: 'generated'!items	^ items! !!SmaCCConcatenationRegexNode methodsFor: 'generated'!items: anOrderedCollection	self setParents: self items to: nil.	items := anOrderedCollection.	self setParents: self items to: self! !!SmaCCConcatenationRegexNode methodsFor: 'generated'!compositeNodeVariables	^ #(#items)! !!SmaCCConcatenationRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitConcatenationRegex: self! !SmaCCRegexNode subclass: #SmaCCRepeatRegexNode	instanceVariableNames: 'regex count'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCRepeatRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	super testTokensDo: aBlock.	aBlock value: count! !!SmaCCRepeatRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| re |	re := self regex regularExpression.	count value = '*'		ifTrue: [ ^ re repeat ].	count value = '+'		ifTrue: [ ^ re repeatForAtLeast: 1 ].	count value = '?'		ifTrue: [ ^ re repeatFor: 0 to: 1 ].	count value first = ${		ifTrue: [ | readStream start stop |			readStream := ReadStream on: (count value copyFrom: 2 to: count value size - 1).			start := readStream upTo: $,.			stop := readStream upToEnd.			^ re				repeatFor:					(start isEmpty						ifTrue: [ 0 ]						ifFalse: [ start asNumber ])				to:					(stop isEmpty						ifTrue: [ 1 bitShift: 31 ]						ifFalse: [ stop asNumber ]) ].	self reportCountError! !!SmaCCRepeatRegexNode methodsFor: '*SmaCC_Development'!reportCountError	SmaCCParserError new		messageText: 'Unknown repeat count';		tag: count;		signal! !!SmaCCRepeatRegexNode methodsFor: 'generated'!tokenVariables	^ #(#count)! !!SmaCCRepeatRegexNode methodsFor: 'generated'!count: aSmaCCToken	count := aSmaCCToken! !!SmaCCRepeatRegexNode methodsFor: 'generated'!nodeVariables	^ #(#regex)! !!SmaCCRepeatRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitRepeatRegex: self! !!SmaCCRepeatRegexNode methodsFor: 'generated'!count	^ count! !!SmaCCRepeatRegexNode methodsFor: 'generated'!regex	^ regex! !!SmaCCRepeatRegexNode methodsFor: 'generated'!regex: aSmaCCRegexNode	self regex notNil		ifTrue: [ self regex parent: nil ].	regex := aSmaCCRegexNode.	self regex notNil		ifTrue: [ self regex parent: self ]! !SmaCCDirectiveNode subclass: #SmaCCScopeDirectiveNode	instanceVariableNames: 'typeToken names'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCScopeDirectiveNode methodsFor: 'testing'!isScopeDirective	^ true! !!SmaCCScopeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , typeToken value! !!SmaCCScopeDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ typeToken! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#typeToken #directiveStartToken #semicolon)! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#names)! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!names	^ names! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitScopeDirective: self! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!names: anOrderedCollection	names := anOrderedCollection! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!typeToken	^ typeToken! !!SmaCCScopeDirectiveNode methodsFor: 'generated'!typeToken: aSmaCCToken	typeToken := aSmaCCToken! !!SmaCCScopeDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	names := OrderedCollection new: 2.! !SmaCCDirectiveNode subclass: #SmaCCStartDirectiveNode	instanceVariableNames: 'startToken symbols'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCStartDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	symbols := OrderedCollection new: 2.! !!SmaCCStartDirectiveNode methodsFor: 'generated'!startToken	^ startToken! !!SmaCCStartDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#symbols)! !!SmaCCStartDirectiveNode methodsFor: 'generated'!startToken: aSmaCCToken	startToken := aSmaCCToken! !!SmaCCStartDirectiveNode methodsFor: 'generated'!symbols	^ symbols! !!SmaCCStartDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitStartDirective: self! !!SmaCCStartDirectiveNode methodsFor: 'generated'!symbols: anOrderedCollection	symbols := anOrderedCollection! !!SmaCCStartDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#startToken #directiveStartToken #semicolon)! !!SmaCCStartDirectiveNode methodsFor: 'testing'!isStartDirective	^ true! !!SmaCCStartDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , startToken value! !!SmaCCStartDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ startToken! !SmaCCDirectiveNode subclass: #SmaCCSuperclassDirectiveNode	instanceVariableNames: 'hierarchyToken superclass leftParen names rightParen'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCSuperclassDirectiveNode methodsFor: 'testing'!isHierarchyDirective	^ true! !!SmaCCSuperclassDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ '%' , hierarchyToken value , ' ' , superclass value! !!SmaCCSuperclassDirectiveNode methodsFor: '*GT4SmaCC-Development-UI'!directiveNameToken	^ hierarchyToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!compositeTokenVariables	^ #(#names)! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!superclass: aSmaCCToken	superclass := aSmaCCToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!tokenVariables	^ #(#hierarchyToken #superclass #leftParen #rightParen #directiveStartToken #semicolon)! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!hierarchyToken	^ hierarchyToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!names	^ names! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!rightParen: aSmaCCToken	rightParen := aSmaCCToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!hierarchyToken: aSmaCCToken	hierarchyToken := aSmaCCToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitSuperclassDirective: self! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!names: anOrderedCollection	names := anOrderedCollection! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!rightParen	^ rightParen! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!leftParen	^ leftParen! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!leftParen: aSmaCCToken	leftParen := aSmaCCToken! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated'!superclass	^ superclass! !!SmaCCSuperclassDirectiveNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	names := OrderedCollection new: 2.! !SmaCCDefinitionNode subclass: #SmaCCSymbolNode	instanceVariableNames: 'variableNameToken'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCSymbolNode methodsFor: 'generated'!tokenVariables	^ #(#variableNameToken)! !!SmaCCSymbolNode methodsFor: 'generated'!variableNameToken: aSmaCCToken	variableNameToken := aSmaCCToken! !!SmaCCSymbolNode methodsFor: 'generated'!variableNameToken	^ variableNameToken! !!SmaCCSymbolNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitSymbol: self! !!SmaCCSymbolNode methodsFor: 'iterating'!alternativesDo: aBlock! !!SmaCCSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!variableName: aString	^ self attributeNamed: #variableName put: aString! !!SmaCCSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!buildVariableNameInterfaceElement: aBrTextEditor	| expression element isCommon textEditor labelText editorElement commonNameBlock nameEditorBlock |	expression := self		lookupNode: [ :node | (node isKindOf: SmaCCProductionExpressionNode) and: [ node parent isKindOf: SmaCCProductionRuleNode ] ].	expression isNil		ifTrue: [ ^ nil ].	isCommon := self variableName = aBrTextEditor text asString.	textEditor := BrTextEditor new.	commonNameBlock := [ :event | 	| newName |	newName := aBrTextEditor text asString.	isCommon		ifTrue: [ textEditor text: newName asRopedText.			self variableName: newName ].	isCommon := textEditor text asString = aBrTextEditor text asString ].	aBrTextEditor		when: BrTextEditorInsertedEvent do: commonNameBlock;		when: BrTextEditorDeletedEvent do: commonNameBlock.	nameEditorBlock := [ :event | 	self variableName: textEditor text asString.	isCommon := textEditor text asString = aBrTextEditor text asString ].	textEditor		when: BrTextEditorInsertedEvent do: nameEditorBlock;		when: BrTextEditorDeletedEvent do: nameEditorBlock.	element := BlElement new.	element		constraintsDo: [ :c | 			c horizontal matchParent.			c vertical fitContent ].	element layout: BlFlowLayout horizontal.	textEditor text: self variableName asRopedText.	editorElement := BrEditorElement new.	editorElement editor: textEditor.	editorElement size: 200 @ 23.	editorElement		border: (BlBorder paint: Color lightGray);		margin: (BlInsets all: 4).	labelText := expression styledText.	(labelText from: self startPosition - parent startPosition + 1 to: self stopPosition - parent startPosition + 1)		underlinePaint: Color black		width: 3.	element		addChild: editorElement;		addChild:			((BlTextElement text: labelText)				margin: (BlInsets all: 7);				yourself).	^ element! !!SmaCCSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!updateSource: aSmaCCString	| name |	name := self attributeNamed: #variableName ifAbsent: [ ^ self ].	name isEmpty		ifTrue: [ variableNameToken notNil				ifTrue: [ aSmaCCString deleteFrom: variableNameToken startPosition to: variableNameToken stopPosition ] ]		ifFalse: [ variableNameToken notNil				ifTrue: [ aSmaCCString deleteFrom: variableNameToken startPosition to: variableNameToken stopPosition.					aSmaCCString insert: '''' , name , '''' at: variableNameToken startPosition ]				ifFalse: [ aSmaCCString insert: ' ''' , name , '''' at: (aSmaCCString nextIndex: self name stopPosition) ] ]! !!SmaCCSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!definition	^ nil! !!SmaCCSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!variableName	^ self		attributeNamed: #variableName		ifAbsent: [ variableNameToken isNil				ifTrue: [ '' ]				ifFalse: [ variableNameToken value copyFrom: 2 to: variableNameToken value size - 1 ] ]! !!SmaCCSymbolNode methodsFor: 'accessing'!allPossibilities	^ 1! !!SmaCCSymbolNode methodsFor: 'accessing'!possibilities	^ 1! !SmaCCSymbolNode subclass: #SmaCCErrorSymbolNode	instanceVariableNames: 'name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCErrorSymbolNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCErrorSymbolNode methodsFor: 'generated'!name	^ name! !!SmaCCErrorSymbolNode methodsFor: 'generated'!tokenVariables	^ #(#name #variableNameToken)! !!SmaCCErrorSymbolNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitErrorSymbol: self! !SmaCCSymbolNode subclass: #SmaCCKeywordSymbolNode	instanceVariableNames: 'name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCKeywordSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ self name value! !!SmaCCKeywordSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!buildInterfaceIn: presentation	self buildVariableNameInterfaceFor: self name value in: presentation.	presentation list		title: 'References';		display: [ self ruleReferencesTo: self name value ];		format: [ :e | e displayString ];		tags: [ :e | e tags ]! !!SmaCCKeywordSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!matches: aString	^ (self name value asLowercase indexOfSubCollection: aString asLowercase) > 0! !!SmaCCKeywordSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!tags	^ #('Token')! !!SmaCCKeywordSymbolNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCKeywordSymbolNode methodsFor: 'generated'!name	^ name! !!SmaCCKeywordSymbolNode methodsFor: 'generated'!tokenVariables	^ #(#name #variableNameToken)! !!SmaCCKeywordSymbolNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitKeywordSymbol: self! !SmaCCSymbolNode subclass: #SmaCCProductionSymbolNode	instanceVariableNames: 'name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCProductionSymbolNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCProductionSymbolNode methodsFor: 'generated'!name	^ name! !!SmaCCProductionSymbolNode methodsFor: 'generated'!tokenVariables	^ #(#name #variableNameToken)! !!SmaCCProductionSymbolNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitProductionSymbol: self! !!SmaCCProductionSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!definition	^ self topParent rules		detect: [ :each | (each isKindOf: SmaCCProductionRuleNode) and: [ each name = name ] ]		ifNone: [ nil ]! !SmaCCRegexNode subclass: #SmaCCTokenRegexNode	instanceVariableNames: 'name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCTokenRegexNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCTokenRegexNode methodsFor: 'generated'!name	^ name! !!SmaCCTokenRegexNode methodsFor: 'generated'!tokenVariables	^ #(#name)! !!SmaCCTokenRegexNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitTokenRegex: self! !!SmaCCTokenRegexNode methodsFor: '*GT4SmaCC-Development-UI'!definition	^ self topParent rules detect: [ :each | (each isKindOf: SmaCCTokenRuleNode) and: [ each name = name ] ] ifNone: [ nil ]! !!SmaCCTokenRegexNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	super testTokensDo: aBlock.	aBlock value: name! !!SmaCCTokenRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ (self topParent tokenNamed: name value)		ifNotNil: [ :rule | rule regularExpression copy ]		ifNil: [ (SmaCCGrammar implicitToken: name value) ifNil: [ self reportMissingTokenDefinition ] ]! !!SmaCCTokenRegexNode methodsFor: '*SmaCC_Development'!reportMissingTokenDefinition	SmaCCParserError new		messageText: 'Missing token definition';		tag: name;		signal! !SmaCCDefinitionNode subclass: #SmaCCTokenRuleNode	instanceVariableNames: 'name colon regex semicolon states'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCTokenRuleNode methodsFor: '*SmaCC_Development'!reportCircularDefinitionError	SmaCCParserError new		messageText: 'Circular token definition';		tag: name;		signal! !!SmaCCTokenRuleNode methodsFor: '*SmaCC_Development'!regularExpression	| re |	(self attributeNamed: #regularExpression ifAbsent: [ nil ])		ifNotNil: [ :each | ^ each ].	(self attributeNamed: #buildingRegularExpression ifAbsent: [ false ])		ifTrue: [ self reportCircularDefinitionError ].	self attributeNamed: #buildingRegularExpression put: true.	re := SmaCCSequenceRENode nodes: {regex regularExpression}.	self attributeNamed: #regularExpression put: re.	self removeAttributeNamed: #buildingRegularExpression.	re position: self name startPosition.	self states do: [ :each | re addState: each value asSymbol ].	^ re! !!SmaCCTokenRuleNode methodsFor: 'generated-initialize-release'!initialize	super initialize.	states := OrderedCollection new: 2.! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!testTokensDo: aBlock	aBlock value: name! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!buildInterfaceIn: presentation	self buildVariableNameInterfaceFor: name value in: presentation.	presentation list		title: 'References';		display: [ self ruleReferences ];		format: [ :each | each displayString ];		tags: [ :each | each tags ].	presentation list		title: 'Uses';		display: [ self uses ];		format: [ :each | each displayString ];		tags: [ :each | each tags ].	self buildSourceInterfaceIn: presentation label: 'Definition'.	self buildMethodInterfaceIn: presentation! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!displayString	^ name value! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!isMethod	^ (self scannerClass whichClassIncludesSelector: self selector)		ifNil: [ false ]		ifNotNil: [ :cls | cls includesBehavior: SmaCCScanner ]! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!buildMethodInterfaceIn: presentation	self isMethod		ifFalse: [ ^ self ].	presentation bloc		title: 'Method';		element: [ | text styler editor editorElement |			text := ((self scannerClass whichClassIncludesSelector: self selector) sourceCodeAt: self selector) asRopedText.			text				attributes:					{BlFontGenericFamilyAttribute monospace beNotOverwritableByStyler.					(BlFontSizeAttribute size: 14) beNotOverwritableByStyler}.			styler := BrRBTextStyler new.			styler classOrMetaClass: self scannerClass.			editor := BrTextEditor new.			editor styler: styler.			editor text: text.			editorElement := BrEditorElement new.			editorElement				constraintsDo: [ :c | 					c horizontal matchParent.					c vertical matchParent ].			editorElement editor: editor.			editorElement ]! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!ruleReferences	^ self ruleReferencesTo: self name value! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!selector	^ (self name value copyFrom: 2 to: self name value size - 1) asSymbol! !!SmaCCTokenRuleNode methodsFor: '*GT4SmaCC-Development-UI'!tags	^ self isMethod		ifTrue: [ #('Token' 'Method') ]		ifFalse: [ #('Token') ]! !!SmaCCTokenRuleNode methodsFor: 'generated'!compositeTokenVariables	^ #(#states)! !!SmaCCTokenRuleNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCTokenRuleNode methodsFor: 'generated'!semicolon: aSmaCCToken	semicolon := aSmaCCToken! !!SmaCCTokenRuleNode methodsFor: 'generated'!tokenVariables	^ #(#name #colon #semicolon)! !!SmaCCTokenRuleNode methodsFor: 'generated'!regex: aSmaCCRegexNode	self regex notNil		ifTrue: [ self regex parent: nil ].	regex := aSmaCCRegexNode.	self regex notNil		ifTrue: [ self regex parent: self ]! !!SmaCCTokenRuleNode methodsFor: 'generated'!regex	^ regex! !!SmaCCTokenRuleNode methodsFor: 'generated'!name	^ name! !!SmaCCTokenRuleNode methodsFor: 'generated'!states: anOrderedCollection	states := anOrderedCollection! !!SmaCCTokenRuleNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitTokenRule: self! !!SmaCCTokenRuleNode methodsFor: 'generated'!nodeVariables	^ #(#regex)! !!SmaCCTokenRuleNode methodsFor: 'generated'!semicolon	^ semicolon! !!SmaCCTokenRuleNode methodsFor: 'generated'!states	^ states! !!SmaCCTokenRuleNode methodsFor: 'generated'!colon: aSmaCCToken	colon := aSmaCCToken! !!SmaCCTokenRuleNode methodsFor: 'generated'!colon	^ colon! !!SmaCCTokenRuleNode methodsFor: 'testing'!isTokenRule	^ true! !SmaCCSymbolNode subclass: #SmaCCTokenSymbolNode	instanceVariableNames: 'name'	classVariableNames: ''	package: 'SmaCC_Grammar_Parser'!!SmaCCTokenSymbolNode methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCTokenSymbolNode methodsFor: 'generated'!name	^ name! !!SmaCCTokenSymbolNode methodsFor: 'generated'!tokenVariables	^ #(#name #variableNameToken)! !!SmaCCTokenSymbolNode methodsFor: 'generated'!acceptVisitor: aDefinitionVisitor	^ aDefinitionVisitor visitTokenSymbol: self! !!SmaCCTokenSymbolNode methodsFor: '*GT4SmaCC-Development-UI'!definition	^ self topParent rules		detect: [ :each | (each isKindOf: SmaCCTokenRuleNode) and: [ each name = name ] ]		ifNone: [ nil ]! !