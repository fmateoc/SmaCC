Model subclass: #SmaCCAbstractRewrite	instanceVariableNames: 'parent properties'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCAbstractRewrite methodsFor: 'rewriting'!clearLocalVariablesIn: aClass	! !!SmaCCAbstractRewrite methodsFor: 'rewriting'!updateClass: aClass	! !!SmaCCAbstractRewrite methodsFor: 'rewriting'!performOn: aSmaCCNode continuation: aBlock	self subclassResponsibility! !!SmaCCAbstractRewrite methodsFor: 'printing'!displayString	| stream |	stream := WriteStream on: String new.	self displayOn: stream.	^ stream contents! !!SmaCCAbstractRewrite methodsFor: 'printing'!displayOn: aStream	self subclassResponsibility! !!SmaCCAbstractRewrite methodsFor: '*GT4SmaCC-Rewrite-Engine-UI'!element	^ self subclassResponsibility! !!SmaCCAbstractRewrite methodsFor: 'changing'!modified	parent notNil		ifTrue: [ parent modified ]! !!SmaCCAbstractRewrite methodsFor: 'changing'!changed: aSymbol	super changed: aSymbol.	self announcer announce: aSymbol.	self modified! !!SmaCCAbstractRewrite methodsFor: 'testing'!isUpToDate	^ true! !!SmaCCAbstractRewrite methodsFor: 'testing'!isUnder: aSmaCCAbstractRewrite	| current |	current := self.	[ current notNil and: [ current ~= aSmaCCAbstractRewrite ] ]		whileTrue: [ current := current parent ].	^ current notNil! !!SmaCCAbstractRewrite methodsFor: 'testing'!matches: aString	| stream |	stream := WriteStream on: String new.	self localSaveOn: stream.	^ '*' , aString , '*' match: stream contents! !!SmaCCAbstractRewrite methodsFor: 'testing'!isComposite	^ false! !!SmaCCAbstractRewrite methodsFor: 'testing'!isRoot	^ parent isNil! !!SmaCCAbstractRewrite methodsFor: 'accessing'!parent: aSmaCCAbstractRewrite	parent := aSmaCCAbstractRewrite! !!SmaCCAbstractRewrite methodsFor: 'accessing'!properties: aDictionary	properties := aDictionary! !!SmaCCAbstractRewrite methodsFor: 'accessing'!rewrites	^ #()! !!SmaCCAbstractRewrite methodsFor: 'accessing'!topParent	^ parent ifNil: [ self ] ifNotNil: [ :value | value topParent ]! !!SmaCCAbstractRewrite methodsFor: 'accessing'!parserClass	^ parent notNil		ifTrue: [ parent parserClass ]		ifFalse: [ nil ]! !!SmaCCAbstractRewrite methodsFor: 'accessing'!parent	^ parent! !!SmaCCAbstractRewrite methodsFor: 'accessing'!finishedLoading	! !!SmaCCAbstractRewrite methodsFor: 'accessing'!listForClass: aClass into: aSmaCCRewriteLink	^ aSmaCCRewriteLink! !!SmaCCAbstractRewrite methodsFor: 'accessing'!properties	^ properties ifNil: [ properties := Dictionary new ]! !!SmaCCAbstractRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!contextClass	^ SmaCCRewriteMatchContext! !!SmaCCAbstractRewrite methodsFor: 'initialize-release'!engine: aSmaCCRewriteEngine	! !!SmaCCAbstractRewrite methodsFor: 'copying'!postCopy	announcer := nil.	dependents := nil.	super postCopy.	parent := nil! !!SmaCCAbstractRewrite methodsFor: 'saving'!localSaveOn: aStream	self subclassResponsibility! !!SmaCCAbstractRewrite methodsFor: 'saving'!saveOn: aStream	self localSaveOn: aStream! !!SmaCCAbstractRewrite methodsFor: 'accessing-properites'!propertyAt: aString ifAbsentPut: aBlock	^ self properties at: aString ifAbsentPut: aBlock! !!SmaCCAbstractRewrite methodsFor: 'accessing-properites'!propertyAt: aString	^ self properties at: aString ifAbsent: [ nil ]! !!SmaCCAbstractRewrite methodsFor: 'accessing-properites'!removeProperty: aString	^ self properties removeKey: aString ifAbsent: [ nil ]! !!SmaCCAbstractRewrite methodsFor: 'accessing-properites'!propertyAt: aString put: anObject	^ self properties at: aString put: anObject! !!SmaCCAbstractRewrite methodsFor: 'accessing-properites'!propertyAt: aString ifAbsent: aBlock	^ self properties at: aString ifAbsent: aBlock! !SmaCCString subclass: #SmaCCAnnotatedString	instanceVariableNames: 'node rule'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCAnnotatedString methodsFor: 'accessing'!rule: aSmaCCRewrite	rule := aSmaCCRewrite! !!SmaCCAnnotatedString methodsFor: 'accessing'!node: aSmaCCParseNode	node := aSmaCCParseNode! !!SmaCCAnnotatedString methodsFor: 'accessing'!node	^ node! !!SmaCCAnnotatedString methodsFor: 'accessing'!rule	^ rule! !!SmaCCAnnotatedString methodsFor: 'public'!intervalClass	^ SmaCCAnnotatedStringInterval! !!SmaCCAnnotatedString methodsFor: 'public'!removeInterval: startInterval	| result |	result := super removeInterval: startInterval.	self addAnnotationTo: result.	^ result! !!SmaCCAnnotatedString methodsFor: 'public'!addAnnotationTo: aSmaCCAnnotatedStringInterval	(node isNil or: [ rule isNil ])		ifTrue: [ ^ self ].	aSmaCCAnnotatedStringInterval		addAnnotation: (SmaCCRewriteAnnotation onNode: node rewrite: rule)! !!SmaCCAnnotatedString methodsFor: 'public'!newIntervalFor: aString	| interval |	interval := super newIntervalFor: aString.	self addAnnotationTo: interval.	^ interval! !SmaCCStringInterval subclass: #SmaCCAnnotatedStringInterval	instanceVariableNames: 'annotations'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCAnnotatedStringInterval methodsFor: 'copying'!postCopy	super postCopy.	annotations := annotations copy! !!SmaCCAnnotatedStringInterval methodsFor: 'public'!annotations: aSequenceableCollection	annotations := aSequenceableCollection! !!SmaCCAnnotatedStringInterval methodsFor: 'public'!addAnnotation: aSmaCCRewriteAnnotation	| collection |	collection := self annotations.	(collection notEmpty		and: [ collection last = aSmaCCRewriteAnnotation ])		ifTrue: [ ^ self ].	collection add: aSmaCCRewriteAnnotation! !!SmaCCAnnotatedStringInterval methodsFor: 'public'!annotations	^ annotations ifNil: [ annotations := OrderedCollection new: 2 ]! !!SmaCCAnnotatedStringInterval methodsFor: 'public'!addAllAnnotations: aCollection	self annotations addAll: aCollection! !!SmaCCAnnotatedStringInterval methodsFor: 'testing'!canBeMergedWith: nextSmaCCStringInterval	"We want to keep the annotations, so we don't allow merging"	^ false! !SmaCCParseNode subclass: #SmaCCReplaceExpression	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCReplaceExpression methodsFor: 'generated'!acceptVisitor: aReplaceVisitor	^ aReplaceVisitor visitReplace: self! !!SmaCCReplaceExpression methodsFor: 'evaluating'!evaluateInContext: aSmaCCRewriteMatchContext	self subclassResponsibility! !SmaCCReplaceExpression subclass: #SmaCCCodeReplaceExpression	instanceVariableNames: 'code'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCCodeReplaceExpression methodsFor: 'evaluating'!method	^ self		attributeNamed: #method		ifAbsentPut: [ | tree |			tree := RBParser parseMethod: 'code ' , code value.			tree body statements isEmpty				ifTrue: [ tree := RBParser parseMethod: 'code ^''''' ].			tree body addReturn.			SmaCCRewriteMatchContext compiledMethodFor: tree formattedCode ]! !!SmaCCCodeReplaceExpression methodsFor: 'evaluating'!evaluateInContext: aSmaCCRewriteMatchContext	| value |	value := self method		valueWithReceiver: aSmaCCRewriteMatchContext		arguments: #().	^ (value isString or: [ value isKindOf: SmaCCString ])		ifTrue: [ value ]		ifFalse:			[ aSmaCCRewriteMatchContext				sourceFrom: aSmaCCRewriteMatchContext match startPosition				to: aSmaCCRewriteMatchContext match stopPosition ]! !!SmaCCCodeReplaceExpression methodsFor: 'generated'!code	^ code! !!SmaCCCodeReplaceExpression methodsFor: 'generated'!tokenVariables	^ #(#code)! !!SmaCCCodeReplaceExpression methodsFor: 'generated'!code: aSmaCCToken	code := aSmaCCToken! !!SmaCCCodeReplaceExpression methodsFor: 'generated'!acceptVisitor: aReplaceVisitor	^ aReplaceVisitor visitCodeReplace: self! !SmaCCReplaceExpression subclass: #SmaCCCompositeReplaceExpression	instanceVariableNames: 'expressions'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCCompositeReplaceExpression methodsFor: 'generated-initialize-release'!initialize	super initialize.	expressions := OrderedCollection new: 2.! !!SmaCCCompositeReplaceExpression methodsFor: 'evaluating'!evaluateInContext: aSmaCCRewriteMatchContext	| result |	result := aSmaCCRewriteMatchContext smaccStringClass new.	self expressions		reverseDo:			[ :each | result addPrefix: (each evaluateInContext: aSmaCCRewriteMatchContext) ].	^ result! !!SmaCCCompositeReplaceExpression methodsFor: 'generated'!expressions	^ expressions! !!SmaCCCompositeReplaceExpression methodsFor: 'generated'!expressions: anOrderedCollection	self setParents: self expressions to: nil.	expressions := anOrderedCollection.	self setParents: self expressions to: self! !!SmaCCCompositeReplaceExpression methodsFor: 'generated'!compositeNodeVariables	^ #(#expressions)! !!SmaCCCompositeReplaceExpression methodsFor: 'generated'!acceptVisitor: aReplaceVisitor	^ aReplaceVisitor visitCompositeReplace: self! !SmaCCReplaceExpression subclass: #SmaCCNodeReplaceExpression	instanceVariableNames: 'beforeWhitespace beforePrefix prefix name postfix afterPostfix afterWhitespace'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCNodeReplaceExpression methodsFor: 'evaluating'!evaluateInContext: aSmaCCRewriteMatchContext	| result |	result := aSmaCCRewriteMatchContext smaccStringClass new.	self addPostfixTo: result inContext: aSmaCCRewriteMatchContext.	result addPrefix: (aSmaCCRewriteMatchContext stringFor: name value).	self addPrefixTo: result inContext: aSmaCCRewriteMatchContext.	^ result! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!name: aSmaCCToken	name := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!postfix	^ postfix! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!postfix: aSmaCCToken	postfix := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!beforeWhitespace: aSmaCCToken	beforeWhitespace := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!prefix: aSmaCCToken	prefix := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!afterWhitespace	^ afterWhitespace! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!name	^ name! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!beforeWhitespace	^ beforeWhitespace! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!afterWhitespace: aSmaCCToken	afterWhitespace := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!tokenVariables	^ #(#beforeWhitespace #beforePrefix #prefix #name #postfix #afterPostfix #afterWhitespace)! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!afterPostfix: aSmaCCToken	afterPostfix := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!acceptVisitor: aReplaceVisitor	^ aReplaceVisitor visitNodeReplace: self! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!afterPostfix	^ afterPostfix! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!beforePrefix	^ beforePrefix! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!beforePrefix: aSmaCCToken	beforePrefix := aSmaCCToken! !!SmaCCNodeReplaceExpression methodsFor: 'generated'!prefix	^ prefix! !!SmaCCNodeReplaceExpression methodsFor: 'private'!addPrefixTo: aSmaCCString inContext: aSmaCCRewriteMatchContext	| node startPosition |	node := aSmaCCRewriteMatchContext nodeFor: name value.	startPosition := aSmaCCRewriteMatchContext		originalStartPosition: node.	prefix notNil		ifTrue: [ aSmaCCString addPrefix: prefix value ].	(aSmaCCRewriteMatchContext isAtStartOfParent: node)		ifTrue: [ ^ self ].	beforePrefix notNil		ifTrue:			[ (aSmaCCRewriteMatchContext				charactersAtAndBefore: (aSmaCCRewriteMatchContext previousIndex: startPosition)				matchesToken: beforePrefix)				ifTrue:					[ beforePrefix value size						timesRepeat:							[ startPosition := aSmaCCRewriteMatchContext								previousIndex: startPosition ] ].			aSmaCCString addPrefix: beforePrefix value ].	beforeWhitespace notNil		ifTrue:			[ aSmaCCString				addPrefix: (aSmaCCRewriteMatchContext whitespaceBefore: startPosition) ]! !!SmaCCNodeReplaceExpression methodsFor: 'private'!addPostfixTo: aSmaCCString inContext: aSmaCCRewriteMatchContext	| node position string |	node := aSmaCCRewriteMatchContext nodeFor: name value.	(aSmaCCRewriteMatchContext isAtEndOfParent: node)		ifFalse:			[ position := aSmaCCRewriteMatchContext originalStopPosition: node.			string := nil.			afterPostfix notNil				ifTrue:					[ (aSmaCCRewriteMatchContext						charactersAtAndAfter: (aSmaCCRewriteMatchContext nextIndex: position)						matchesToken: afterPostfix)						ifTrue:							[ afterPostfix value size								timesRepeat: [ position := aSmaCCRewriteMatchContext nextIndex: position ] ].					string := afterPostfix value ].			afterWhitespace notNil				ifTrue:					[ aSmaCCString						addPrefix: (aSmaCCRewriteMatchContext whitespaceAfter: position) ].			string notNil				ifTrue: [ aSmaCCString addPrefix: string ] ].	postfix notNil		ifTrue: [ aSmaCCString addPrefix: postfix value ]! !SmaCCParser subclass: #SmaCCReplaceExpressionParser	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForPrefixModifiers1: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 2 put: (nodes at: 2).	result at: 3 put: (nodes at: 4).	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForNodeReplace1: nodes	| result |	result := SmaCCNodeReplaceExpression new.	result beforeWhitespace: ((nodes at: 3) at: 1).	result beforePrefix: ((nodes at: 3) at: 2).	result prefix: ((nodes at: 3) at: 3).	result name: (nodes at: 4).	result postfix: ((nodes at: 5) at: 1).	result afterPostfix: ((nodes at: 5) at: 2).	result afterWhitespace: ((nodes at: 5) at: 3).	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForPostfixModifiers1: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 2 put: (nodes at: 3).	result at: 3 put: (nodes at: 4).	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForSwitchStateToExpression1: nodes	self scope: #expression.	^ nil! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForRewriteExpressions2: nodes	| result |	result := nodes at: 1.	self add: (nodes at: 2) to: result.	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForSwitchStateToCode1: nodes	self scope: #code.	^ nil! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForCodeReplace1: nodes	| result |	result := SmaCCCodeReplaceExpression new.	result code: (nodes at: 3).	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForStringReplace1: nodes	| result |	result := SmaCCStringReplaceExpression new.	result string: (nodes at: 1).	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForExpression1: nodes	| result |	result := SmaCCCompositeReplaceExpression new.	result addNodes: (nodes at: 1) to: result expressions.	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForRewriteExpressions1: nodes	| result |	result := OrderedCollection new: 2.	^ result! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForSwitchStateToDefault1: nodes	self scope: #default.	^ nil! !!SmaCCReplaceExpressionParser methodsFor: 'generated-reduction actions'!reduceActionForPrefixModifiers2: nodes	| result |	result := Array new: 3.	result at: 1 put: (nodes at: 1).	result at: 3 put: (nodes at: 2).	^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReplaceExpressionParser class	instanceVariableNames: ''!!SmaCCReplaceExpressionParser class methodsFor: 'generated-accessing'!scannerClass	^SmaCCReplaceExpressionScanner! !!SmaCCReplaceExpressionParser class methodsFor: 'generated-accessing'!cacheId	^'2019-04-15T17:15:43.228108-05:00'! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!definitionComment"%excludes expression code ;%id <codeExpression>;expression <name>	: (<isLetter> | _) (<isLetter> | _ | <isDigit>) *	;expression <newline>	: \\	;expression <special_characters>	: [\~\!!\@\#\$\%\^\&\*\(\)\-\+\=\|\{\[\]\}\<\,\>\.\?\/\;\:\'\""]+	;expression <end_of_expression_character>	: _	;<string>	: [^`]+	;default expression <backquote>	: `	;default code <double_backquote>	: ``	;%prefix SmaCC;%suffix Expression;%root Replace;Expression	: RewriteExpressions {{CompositeReplace}}	;RewriteExpressions	: 	| RewriteExpressions RewriteExpression 'expression'	;RewriteExpression	: StringReplace	| NodeReplace	| CodeReplace	;StringReplace	: <string> 'string' {{StringReplace}}	;NodeReplace	: SwitchStateToExpression <backquote> PrefixModifiers <name> 'name' PostfixModifiers SwitchStateToDefault <backquote> {{NodeReplace}}	;SwitchStateToDefault	: {self scope: #default. nil}	;SwitchStateToExpression	: {self scope: #expression. nil}	;CodeReplace	: SwitchStateToCode <double_backquote> <codeExpression> 'code' SwitchStateToDefault <double_backquote> {{CodeReplace}}	;SwitchStateToCode	: {self scope: #code. nil}	;PrefixModifiers	: OptionalWhitespace 'beforeWhitespace' Characters 'beforePrefix' <end_of_expression_character> OptionalCharacters 'prefix'	| OptionalWhitespace 'beforeWhitespace' OptionalCharacters 'prefix'	;PostfixModifiers	: OptionalCharacters 'postfix' <end_of_expression_character> Characters 'afterPostfix' OptionalWhitespace 'afterWhitespace'	| OptionalCharacters 'postfix' OptionalWhitespace 'afterWhitespace'	;OptionalWhitespace	: 	| <newline>	;OptionalCharacters	: 	| Characters	;Characters	: <special_characters> 'characters'	;"! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!symbolTypes	^ #(#SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCCompositeReplaceExpression #SmaCCCompositeReplaceExpression #OrderedCollection #SmaCCReplaceExpression #SmaCCStringReplaceExpression #SmaCCNodeReplaceExpression nil nil #SmaCCCodeReplaceExpression nil #OrderedCollection #OrderedCollection #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCToken #SmaCCErrorNode)! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!startingStateForExpression	^ 1! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!reduceTable^#(	#(10 0 #reduceActionForRewriteExpressions1: 525313 false ) 	#(15 0 #reduceActionForSwitchStateToExpression1: 943105 false ) 	#(17 0 #reduceActionForSwitchStateToCode1: 1143809 false ) 	#(9 1 #reduceActionForExpression1: 466945 false ) 	#(12 1 #reduceActionForStringReplace1: 675841 false ) 	#(10 2 #reduceActionForRewriteExpressions2: 525314 false ) 	#(11 1 #liftFirstValue: 606209 false ) 	#(11 1 #liftFirstValue: 606210 false ) 	#(11 1 #liftFirstValue: 606211 false ) 	#(20 0 #nil 1631233 false ) 	#(20 1 #liftFirstValue: 1631234 false ) 	#(21 0 #nil 1671169 false ) 	#(14 0 #reduceActionForSwitchStateToDefault1: 886785 false ) 	#(22 1 #liftFirstValue: 1712129 false ) 	#(18 2 #reduceActionForPrefixModifiers2: 1193986 false ) 	#(21 1 #liftFirstValue: 1671170 false ) 	#(16 5 #reduceActionForCodeReplace1: 1005569 false ) 	#(19 2 #reduceActionForPrefixModifiers2: 1412098 false ) 	#(18 4 #reduceActionForPrefixModifiers1: 1193985 false ) 	#(13 7 #reduceActionForNodeReplace1: 733185 false ) 	#(19 4 #reduceActionForPostfixModifiers1: 1412097 false )	).! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!symbolNames	^ #('<name>' '<newline>' '<special_characters>' '<end_of_expression_character>' '<string>' '<backquote>' '<double_backquote>' 'B e g i n' 'Expression' 'RewriteExpressions' 'RewriteExpression' 'StringReplace' 'NodeReplace' 'SwitchStateToDefault' 'SwitchStateToExpression' 'CodeReplace' 'SwitchStateToCode' 'PrefixModifiers' 'PostfixModifiers' 'OptionalWhitespace' 'OptionalCharacters' 'Characters' '<codeExpression>' 'E O F' 'error')! !!SmaCCReplaceExpressionParser class methodsFor: 'generated'!transitionTable^#(#[1 0 6 0 5 0 6 0 6 0 6 0 7 0 9 0 9 0 13 0 10 0 6 0 24] #[0 0 0 0 24] #[1 0 17 0 5 0 10 0 6 0 14 0 7 0 21 0 11 0 21 0 12 0 21 0 13 0 33 0 15 0 21 0 16 0 41 0 17 0 18 0 24] #[0 0 22 0 5 0 6 0 7 0 24] #[0 0 26 0 5 0 6 0 7 0 24] #[0 0 30 0 5 0 6 0 7 0 24] #[0 0 34 0 5 0 6 0 7 0 24] #[0 0 45 0 6] #[0 0 38 0 5 0 6 0 7 0 24] #[0 0 49 0 7] #[1 0 42 0 1 0 61 0 2 0 42 0 3 0 57 0 18 0 61 0 20] #[0 0 65 0 23] #[0 0 46 0 1 0 3 0 6] #[0 0 69 0 1] #[1 0 50 0 1 0 81 0 3 0 77 0 21 0 81 0 22] #[1 0 54 0 7 0 85 0 14] #[1 0 50 0 2 0 93 0 3 0 50 0 4 0 50 0 6 0 89 0 19 0 93 0 21 0 93 0 22] #[0 0 58 0 1 0 2 0 4 0 6] #[0 0 62 0 1] #[1 0 66 0 1 0 101 0 4] #[0 0 105 0 7] #[1 0 54 0 6 0 109 0 14] #[1 0 117 0 2 0 113 0 4 0 42 0 6 0 117 0 20] #[0 0 66 0 1 0 2 0 4 0 6] #[1 0 50 0 1 0 121 0 3 0 121 0 21 0 121 0 22] #[0 0 70 0 5 0 6 0 7 0 24] #[0 0 125 0 6] #[0 0 129 0 3 0 22] #[0 0 74 0 6] #[0 0 78 0 1] #[0 0 82 0 5 0 6 0 7 0 24] #[1 0 133 0 2 0 42 0 6 0 133 0 20] #[0 0 86 0 6]	).! !SmaCCScanner subclass: #SmaCCReplaceExpressionScanner	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCReplaceExpressionScanner methodsFor: 'private'!scanCode	outputStream reset.	[ outputStream nextPutAll: (stream upTo: $`).	stream peek == $`		ifTrue: [ self isValidCode				ifTrue: [ stream position: stream position - 1.					scope := #default.					^ self recordAndReportMatch: (Array with: self codeExpressionId) ] ].	stream atEnd		ifTrue: [ ^ self reportLastMatch ].	outputStream nextPut: $` ] repeat! !!SmaCCReplaceExpressionScanner methodsFor: 'generated'!scanForTokenX1	self step.	currentCharacter == $\		ifTrue: [ ^ self recordAndReportMatch: #(2) ].	currentCharacter == $_		ifTrue: [ self recordMatch: #(1 4).			self step.			(currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ])				ifTrue: [ [ self recordMatch: #(1).					self step.					currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]						whileTrue ].			^ self reportLastMatch ].	currentCharacter == $`		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	((currentCharacter between: $!! and: $/)		or: [ (currentCharacter between: $: and: $@)				or: [ currentCharacter == $[						or: [ (currentCharacter between: $] and: $^)								or: [ currentCharacter between: ${ and: $~ ] ] ] ])		ifTrue: [ [ self recordMatch: #(3).			self step.			(currentCharacter between: $!! and: $/)				or: [ (currentCharacter between: $: and: $@)						or: [ currentCharacter == $[								or: [ (currentCharacter between: $] and: $^)										or: [ currentCharacter between: ${ and: $~ ] ] ] ] ]				whileTrue.			^ self reportLastMatch ].	currentCharacter isLetter		ifTrue: [ [ self recordMatch: #(1).			self step.			currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]				whileTrue ].	^ self reportLastMatch! !!SmaCCReplaceExpressionScanner methodsFor: 'generated'!errorTokenId	^ 25! !!SmaCCReplaceExpressionScanner methodsFor: 'generated'!emptySymbolTokenId	^ 24! !!SmaCCReplaceExpressionScanner methodsFor: 'generated'!scanForToken	scope == #default		ifTrue: [ self step.			currentCharacter == $`				ifTrue: [ self recordMatch: #(6).					self step.					currentCharacter == $`						ifTrue: [ ^ self recordAndReportMatch: #(7) ].					^ self reportLastMatch ].			true				ifTrue: [ [ self recordMatch: #(5).					self step.					currentCharacter ~~ $` ] whileTrue ].			^ self reportLastMatch ].	scope == #expression		ifTrue:			[ ^ self scanForTokenX1 ].	scope == #code		ifTrue: [ (self scanForString: '``')				ifTrue: [ ^ self recordAndReportMatch: #(7) ] ].	^ self reportLastMatch! !!SmaCCReplaceExpressionScanner methodsFor: 'generated'!codeExpressionId	^ 23! !!SmaCCReplaceExpressionScanner methodsFor: 'testing'!isValidCode	RBParser		parseExpression: outputStream contents		onError: [ :s :p | ^ false ].	^ true! !!SmaCCReplaceExpressionScanner methodsFor: 'accessing'!next	scope = #code		ifTrue:			[ self resetScanner.			returnMatchBlock := [ :match | ^ match ].			^ self scanCode ].	^ super next! !SmaCCParseNodeVisitor subclass: #SmaCCReplaceExpressionVisitor	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCReplaceExpressionVisitor methodsFor: 'generated'!visitReplace: aReplace	^ self visitSmaCCParseNode: aReplace! !!SmaCCReplaceExpressionVisitor methodsFor: 'generated'!visitStringReplace: aStringReplace	^ self visitReplace: aStringReplace! !!SmaCCReplaceExpressionVisitor methodsFor: 'generated'!visitCodeReplace: aCodeReplace	^ self visitReplace: aCodeReplace! !!SmaCCReplaceExpressionVisitor methodsFor: 'generated'!visitCompositeReplace: aCompositeReplace	^ self visitReplace: aCompositeReplace! !!SmaCCReplaceExpressionVisitor methodsFor: 'generated'!visitNodeReplace: aNodeReplace	^ self visitReplace: aNodeReplace! !SmaCCAbstractRewrite subclass: #SmaCCRewrite	instanceVariableNames: 'comment match transformation engine'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewrite methodsFor: 'accessing'!match	^ match! !!SmaCCRewrite methodsFor: 'accessing'!transformation: aSmaCCRewriteTransformation	transformation := aSmaCCRewriteTransformation.	transformation rewrite: self.	self changed: #transformation! !!SmaCCRewrite methodsFor: 'accessing'!match: aSmaCCRewriteMatch	match := aSmaCCRewriteMatch.	match rewrite: self.	self changed: #match! !!SmaCCRewrite methodsFor: 'accessing'!comment	^ comment ifNil: [ '' ]! !!SmaCCRewrite methodsFor: 'accessing'!comment: aString	comment := aString.	self changed: #comment! !!SmaCCRewrite methodsFor: 'accessing'!transformation	^ transformation! !!SmaCCRewrite methodsFor: 'accessing'!listForClass: aClass into: aSmaCCRewriteLink	| next |	(match canMatch: aClass)		ifFalse: [ ^ aSmaCCRewriteLink ].	next := SmaCCRewriteLink new.	next rewrite: self.	aSmaCCRewriteLink next: next.	^ next! !!SmaCCRewrite methodsFor: 'testing'!matches: aString	^ (super matches: aString)		or: [ (Smalltalk at: aString asSymbol ifAbsent: [ nil ])				ifNil: [ false ]				ifNotNil: [ :class | (class isKindOf: SmaCCParseNode class) and: [ match canMatch: class ] ] ]! !!SmaCCRewrite methodsFor: 'copying'!postCopy	super postCopy.	self match: self match copy.	self transformation: self transformation copy.	engine := nil! !!SmaCCRewrite methodsFor: 'rewriting'!performOn: aSmaCCNode continuation: aBlock	| matchedContext dictionary result previousNode previousRule |	previousNode := engine source node.	previousRule := engine source rule.	engine source		node: aSmaCCNode;		rule: self.	matchedContext := engine contextClass new.	matchedContext forNode: aSmaCCNode rewriter: engine continuation: aBlock.	dictionary := match match: matchedContext.	result := dictionary notNil.	result		ifTrue: [ matchedContext context: dictionary.			result := (transformation transformUsingContext: matchedContext) ~~ SmaCCRewriteMatchContext continue ].	engine source		node: previousNode;		rule: previousRule.	^ result! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!matchTypes	^ (SmaCCRewriteMatch allSubclasses collect: [ :each | each type ])		asSet asSortedCollection! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!transformationTypes	^ ((SmaCCRewriteTransformation allSubclasses		collect: [ :each | each type ]) asSet		remove: nil ifAbsent: [  ];		yourself) asSortedCollection! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| tabulator |	(tabulator := aPresentation tabulator)		row: [ :row | 			row				column: #label size: 75;				column: #comment ]			size: 25;		row: #search;		row: #replace.	tabulator transmit		to: #label;		andShow: [ :presentation | presentation label display: 'Comment:' ].	tabulator transmit		to: #comment;		andShow: [ :presentation | 			presentation text				display: self comment;				onChangeOfPort: #text act: [ :text | self comment: text text asString ] ].	tabulator updateOn: #match from: #yourself.	tabulator updateOn: #transformation from: #yourself.	tabulator transmit		to: #search;		transformed: [ :rewrite | rewrite match ];		andShow: [ :presentation | self buildSearchIn: presentation ].	tabulator transmit		to: #replace;		transformed: [ :rewrite | rewrite transformation ];		andShow: [ :presentation | self buildReplaceIn: presentation ]! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!changedReplaceTo: aSymbol	| class rewrite |	class := SmaCCRewriteTransformation withAllSubclasses detect: [ :each | each type = aSymbol ].	self transformation class == class		ifTrue: [ ^ self ].	rewrite := class new.	self transformation: rewrite! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildReplaceIn: aPresentation	| browser types |	browser := aPresentation tabulator.	browser		row: #type size: 25;		row: #value.	types := self transformationTypes.	browser transmit		to: #type;		andShow: [ :presentation | 			presentation dropDownList				display: [ types ];				selectedIndex: (types indexOf: self transformation class type);				onChangeOfPort: #selection act: [ :list | self changedReplaceTo: list selection ] ].	browser transmit		to: #value;		andShow: [ :presentation | 			presentation dynamic				updateOn: #transformation from: [ self announcer ];				display: [ | composite |					composite := GLMCompositePresentation new.					transformation buildInterfaceIn: composite.					composite startOn: match.					composite ] ]! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!rewriteForMethod: aMethod	(match method == aMethod or: [ transformation method == aMethod ])		ifTrue: [ ^ self ].	^ nil! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildSearchIn: aPresentation	| browser types |	browser := aPresentation tabulator.	browser		row: #type size: 25;		row: #value.	types := self matchTypes.	browser transmit		to: #type;		andShow: [ :presentation | 			presentation dropDownList				display: [ types ];				selectedIndex: (types indexOf: self match class type);				onChangeOfPort: #selection act: [ :list | self changedSearchTo: list selection ] ].	browser transmit		to: #value;		andShow: [ :presentation | 			presentation dynamic				updateOn: #match from: [ self announcer ];				display: [ | composite |					composite := GLMCompositePresentation new.					match buildInterfaceIn: composite.					composite startOn: match.					composite ] ]! !!SmaCCRewrite methodsFor: '*SmaCC_Rewrite_Engine_UI'!changedSearchTo: aSymbol	| class newMatch |	class := SmaCCRewriteMatch withAllSubclasses detect: [ :each | each type = aSymbol ].	self match class == class		ifTrue: [ ^ self ].	newMatch := class new.	self match: newMatch! !!SmaCCRewrite methodsFor: 'initialize-release'!engine: aSmaCCRewriteEngine	engine := aSmaCCRewriteEngine! !!SmaCCRewrite methodsFor: '*GT4SmaCC-Rewrite-Engine-UI'!element	^ GtSmaCCRewriteElement rewrite: self! !!SmaCCRewrite methodsFor: 'printing'!displayOn: aStream	self comment notEmpty		ifTrue: [ aStream nextPutAll: self comment ]		ifFalse: [ match displayOn: aStream ]! !!SmaCCRewrite methodsFor: 'saving'!localSaveOn: aStream	self comment notEmpty		ifTrue:			[ aStream				nextPut: $";				nextPutAll: (self comment copyReplaceAll: '"' with: '""');				nextPut: $";				cr ].	match saveOn: aStream.	aStream		cr;		nextPutAll: '->';		cr.	transformation saveOn: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewrite class	instanceVariableNames: ''!!SmaCCRewrite class methodsFor: 'instance creation'!newInstance	^ self		comment: ''		match: (SmaCCRewriteTypeMatch on: SmaCCParseNode)		transformation: (SmaCCRewriteCodeTransformation on: 'self continue')! !!SmaCCRewrite class methodsFor: 'instance creation'!comment: aString match: aSmaCCRewriteMatch transformation: aSmaCCRewriteTransformation	^ self new		comment: aString;		match: aSmaCCRewriteMatch;		transformation: aSmaCCRewriteTransformation;		yourself! !Object subclass: #SmaCCRewriteAnnotation	instanceVariableNames: 'nodeClass nodeInterval rewrite'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteAnnotation methodsFor: 'comparing'!= anObject	^ self class = anObject class		and:			[ self nodeClass = anObject nodeClass				and:					[ self nodeInterval = anObject nodeInterval						and: [ self rewrite = anObject rewrite ] ] ]! !!SmaCCRewriteAnnotation methodsFor: 'comparing'!hash	^ (nodeClass hash bitXor: nodeInterval hash) bitXor: rewrite hash! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!nodeClass: aBehavior	nodeClass := aBehavior! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!nodeClass	^ nodeClass! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!rewrite: aSmaCCRewrite	rewrite := aSmaCCRewrite! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!nodeInterval: anInterval	nodeInterval := anInterval! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!nodeInterval	^ nodeInterval! !!SmaCCRewriteAnnotation methodsFor: 'accessing'!rewrite	^ rewrite! !!SmaCCRewriteAnnotation methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: nodeClass;		print: nodeInterval;		nextPutAll: ', ';		nextPutAll: rewrite displayString;		nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteAnnotation class	instanceVariableNames: ''!!SmaCCRewriteAnnotation class methodsFor: 'instance creation'!onNode: aSmaCCParseNode rewrite: aSmaCCRewrite	^ self new		nodeClass: aSmaCCParseNode class;		nodeInterval: aSmaCCParseNode sourceInterval;		rewrite: aSmaCCRewrite;		yourself! !Object subclass: #SmaCCRewriteEngine	instanceVariableNames: 'rewriteRule source newStarts newStops properties methods processedNodes outputDirectory outputFilename contextClass'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteEngine methodsFor: 'accessing'!properties: aDictionary	properties := aDictionary! !!SmaCCRewriteEngine methodsFor: 'accessing'!updateStopPositionFor: aSmaCCParseNode to: stopPosition whenEqualTo: anIndex	anIndex = (self stopPositionForNode: aSmaCCParseNode)		ifTrue: [ self				setStopPositionForNode: aSmaCCParseNode				to: stopPosition ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!stopPositionForNode: aSmaCCParseNode	((aSmaCCParseNode isKindOf: SmaCCParseNode)		and: [ aSmaCCParseNode parent isNil ])		ifTrue: [ ^ source stopIndex ].	^ newStops		at: aSmaCCParseNode		ifAbsent: [ aSmaCCParseNode stopPosition ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!contextClass	contextClass isNil		ifTrue: [ contextClass := SmaCCRewriteMatchContext newAnonymousSubclass.			self rewriteRule updateClass: contextClass ].	^ contextClass! !!SmaCCRewriteEngine methodsFor: 'accessing'!outputFilename: aString	outputFilename := aString! !!SmaCCRewriteEngine methodsFor: 'accessing'!setStartPositionForNode: aSmaCCParseNode to: anIndex	| position current |	current := aSmaCCParseNode.	position := self startPositionForNode: aSmaCCParseNode.	[ newStarts at: current put: anIndex.	current := current parent.	current notNil		and: [ position = (self startPositionForNode: current) ] ] whileTrue! !!SmaCCRewriteEngine methodsFor: 'accessing'!outputDirectory: aString	outputDirectory := aString! !!SmaCCRewriteEngine methodsFor: 'accessing'!properties	^ properties! !!SmaCCRewriteEngine methodsFor: 'accessing'!outputDirectory	^ outputDirectory! !!SmaCCRewriteEngine methodsFor: 'accessing'!source: aSmaCCString	source := aSmaCCString! !!SmaCCRewriteEngine methodsFor: 'accessing'!source	^ source! !!SmaCCRewriteEngine methodsFor: 'accessing'!rewriteRule	^ rewriteRule! !!SmaCCRewriteEngine methodsFor: 'accessing'!setStopPositionForNode: aSmaCCParseNode to: anIndex	| position current |	current := aSmaCCParseNode.	position := self stopPositionForNode: aSmaCCParseNode.	[ newStops at: current put: anIndex.	current := current parent.	current notNil		and: [ position = (self stopPositionForNode: current) ] ] whileTrue! !!SmaCCRewriteEngine methodsFor: 'accessing'!rewriteRule: aSmaCCAbstractRewrite	rewriteRule := aSmaCCAbstractRewrite.	aSmaCCAbstractRewrite engine: self! !!SmaCCRewriteEngine methodsFor: 'accessing'!startPositionForNode: aSmaCCParseNode	((aSmaCCParseNode isKindOf: SmaCCParseNode)		and: [ aSmaCCParseNode parent isNil ])		ifTrue: [ ^ source startIndex ].	^ newStarts		at: aSmaCCParseNode		ifAbsent: [ aSmaCCParseNode startPosition ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!ignoreFile	^ self propertyAt: #ignoreFile ifAbsent: [ false ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!addRewrites: aCollection	aCollection do: [ :each | self rewriteRule: each ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!outputFilename	^ outputFilename! !!SmaCCRewriteEngine methodsFor: 'accessing'!updateStartPositionFor: aSmaCCParseNode to: startPosition whenEqualTo: anIndex	anIndex = (self startPositionForNode: aSmaCCParseNode)		ifTrue: [ self				setStartPositionForNode: aSmaCCParseNode				to: startPosition ]! !!SmaCCRewriteEngine methodsFor: 'accessing'!contextClass: aBehavior	contextClass := aBehavior! !!SmaCCRewriteEngine methodsFor: 'accessing'!ignoreFile: aBoolean	^ self propertyAt: #ignoreFile put: aBoolean! !!SmaCCRewriteEngine methodsFor: 'rewriting'!rewriteTree: aSmaCCParseNode	source isNil		ifTrue: [ source := aSmaCCParseNode completeSource copy ].	^ (self rewrite: aSmaCCParseNode) asString! !!SmaCCRewriteEngine methodsFor: 'private'!markAsProcessed: aSmaCCNode	processedNodes add: aSmaCCNode! !!SmaCCRewriteEngine methodsFor: 'private'!processChildrenOf: aSmaCCNode	^ aSmaCCNode nodesDo: [ :each | self rewriteNode: each ]! !!SmaCCRewriteEngine methodsFor: 'private'!setPosition: anIndex in: aSequenceableCollection	| i lastPosition |	lastPosition := aSequenceableCollection last.	i := aSequenceableCollection size.	[ i > 0 and: [ lastPosition = (aSequenceableCollection at: i) ] ]		whileTrue: [ aSequenceableCollection at: i put: anIndex.			i := i - 1 ]! !!SmaCCRewriteEngine methodsFor: 'private'!finished	newStarts := IdentityDictionary new.	newStops := IdentityDictionary new.	properties := Dictionary new.	processedNodes := IdentitySet new.	contextClass notNil		ifTrue: [ self rewriteRule clearLocalVariablesIn: contextClass ]! !!SmaCCRewriteEngine methodsFor: 'private'!rewrite: aSmaCCParseNode	self rewriteNode: aSmaCCParseNode.	^ source		copyFrom: (self startPositionForNode: aSmaCCParseNode)		to: (self stopPositionForNode: aSmaCCParseNode)! !!SmaCCRewriteEngine methodsFor: 'private'!rewriteNode: aSmaCCNode	(aSmaCCNode isNil or: [ processedNodes includes: aSmaCCNode ])		ifTrue: [ ^ self ].	self markAsProcessed: aSmaCCNode.	rewriteRule		performOn: aSmaCCNode		continuation: [ self processChildrenOf: aSmaCCNode ]! !!SmaCCRewriteEngine methodsFor: 'initialize-release'!initialize	super initialize.	newStarts := IdentityDictionary new.	newStops := IdentityDictionary new.	properties := Dictionary new.	methods := IdentityDictionary new.	processedNodes := IdentitySet new! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!propertyAt: aString	^ properties at: aString ifAbsent: [ nil ]! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!propertyAt: aString ifAbsentPut: aBlock	^ properties at: aString ifAbsentPut: aBlock! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!removeProperty: aString	^ properties removeKey: aString ifAbsent: [ nil ]! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!propertyAt: aString put: anObject	^ properties at: aString put: anObject! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!additionalFiles	^ self propertyAt: #additionalFiles ifAbsentPut: [ Dictionary new ]! !!SmaCCRewriteEngine methodsFor: 'accessing-properites'!propertyAt: aString ifAbsent: aBlock	^ properties at: aString ifAbsent: aBlock! !!SmaCCRewriteEngine methodsFor: 'accessing-methods'!addMethodNamed: aSymbol as: aBlock	methods at: aSymbol put: aBlock! !!SmaCCRewriteEngine methodsFor: 'accessing-methods'!methodNamed: aSymbol	^ methods at: aSymbol ifAbsent: [ nil ]! !SmaCCAbstractRewrite subclass: #SmaCCRewriteFile	instanceVariableNames: 'filename rewrites parserClass isModified timestamp cachedLists'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteFile methodsFor: 'comparing'!= anObject	self class = anObject class		ifFalse: [ ^ false ].	^ self filename = anObject filename! !!SmaCCRewriteFile methodsFor: 'comparing'!hash	^ self class hash bitXor: self filename hash! !!SmaCCRewriteFile methodsFor: 'printing'!displayOn: aStream	filename isNil		ifTrue: [ ^ aStream nextPutAll: '...new file...' ].	aStream nextPutAll: filename asFileReference basename! !!SmaCCRewriteFile methodsFor: 'accessing'!engine: aSmaCCRewriteEngine	rewrites do: [ :each | each engine: aSmaCCRewriteEngine ]! !!SmaCCRewriteFile methodsFor: 'accessing'!filename	^ filename! !!SmaCCRewriteFile methodsFor: 'accessing'!rewrites: aCollection	rewrites := aCollection.	self changed: #rewrites! !!SmaCCRewriteFile methodsFor: 'accessing'!removeTransformation: aSmaCCAbstractRewrite	rewrites remove: aSmaCCAbstractRewrite ifAbsent: [  ].	aSmaCCAbstractRewrite parent: nil.	self changed: #rewrites! !!SmaCCRewriteFile methodsFor: 'accessing'!relativeFilename	| parentDirectory |	parent isNil		ifTrue: [ ^ filename ].	parentDirectory := parent directory.	^ (filename beginsWith: parentDirectory)		ifTrue: [ filename				copyFrom: parentDirectory size + 1				to: filename size ]		ifFalse: [ filename ]! !!SmaCCRewriteFile methodsFor: 'accessing'!currentFileTimestamp	^ filename isNil		ifTrue: [ nil ]		ifFalse: [ filename asFileReference exists				ifTrue: [ filename asFileReference modificationTime ]				ifFalse: [ nil ] ]! !!SmaCCRewriteFile methodsFor: 'accessing'!parserClass	^ parserClass ifNil: [ super parserClass ]! !!SmaCCRewriteFile methodsFor: 'accessing'!filename: aString	filename := aString.	timestamp := self currentFileTimestamp.	self changed: #filename! !!SmaCCRewriteFile methodsFor: 'accessing'!addTransformation: aSmaCCAbstractRewrite before: anotherSmaCCAbstractRewrite	rewrites add: aSmaCCAbstractRewrite before: anotherSmaCCAbstractRewrite.	aSmaCCAbstractRewrite parent: self.	self changed: #rewrites! !!SmaCCRewriteFile methodsFor: 'accessing'!directory	^ filename asFileReference parent pathString		, FileSystem disk delimiter asString! !!SmaCCRewriteFile methodsFor: 'accessing'!addTransformation: aSmaCCAbstractRewrite	rewrites add: aSmaCCAbstractRewrite.	aSmaCCAbstractRewrite parent: self.	self changed: #rewrites! !!SmaCCRewriteFile methodsFor: 'accessing'!parserClass: aSmaCCParserClass	parserClass := aSmaCCParserClass.	self changed: #parserClass! !!SmaCCRewriteFile methodsFor: 'accessing'!import: aString	| name rewriteFile |	name := self directory , aString.	name asFileReference exists		ifFalse: [ name := aString ].	rewriteFile := SmaCCRewriteRuleFileParser parseFile: name.	self addTransformation: rewriteFile! !!SmaCCRewriteFile methodsFor: 'accessing'!listForClass: aClass into: aSmaCCRewriteLink	^ rewrites		inject: aSmaCCRewriteLink		into: [ :sum :each | each listForClass: aClass into: sum ]! !!SmaCCRewriteFile methodsFor: 'accessing'!rewrites	^ rewrites! !!SmaCCRewriteFile methodsFor: 'accessing'!finishedLoading	isModified := false.	rewrites do: [ :each | each finishedLoading ]! !!SmaCCRewriteFile methodsFor: 'accessing'!modified	isModified := true.	cachedLists := IdentityDictionary new.	super modified.	self announcer announce: #display! !!SmaCCRewriteFile methodsFor: 'testing'!isUpToDate	^ timestamp = self currentFileTimestamp		and: [ rewrites allSatisfy: [ :each | each isUpToDate ] ]! !!SmaCCRewriteFile methodsFor: 'testing'!isComposite	^ true! !!SmaCCRewriteFile methodsFor: 'testing'!isModified	^ isModified! !!SmaCCRewriteFile methodsFor: 'initialize-release'!initialize	super initialize.	rewrites := OrderedCollection new.	isModified := false.	cachedLists := IdentityDictionary new! !!SmaCCRewriteFile methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| classes tabulator |	classes := SmaCCParser allSubclasses asSortedCollection: [ :a :b | a name < b name ].	(tabulator := aPresentation tabulator)		row: [ :row | 			row				column: #label size: 75;				column: #parser size: 250;				column: #ignore1 ]			size: 25;		row: #ignore.	tabulator transmit		to: #label;		andShow: [ :presentation | presentation label display: 'Parser:' ].	tabulator transmit		to: #parser;		andShow: [ :presentation | 			presentation dropDownList				display: [ classes ];				selectedIndex: (classes indexOf: self parserClass);				onChangeOfPort: #selection					act: [ :list | 					| parser |					parser := classes at: list selectedIndex ifAbsent: [ nil ].					self parserClass ~= parser						ifTrue: [ self parserClass: parser ] ] ]! !!SmaCCRewriteFile methodsFor: '*SmaCC_Rewrite_Engine_UI'!rewriteForMethod: aMethod	rewrites do: [ :each | (each rewriteForMethod: aMethod) ifNotNil: [ :rewrite | ^ rewrite ] ].	^ nil! !!SmaCCRewriteFile methodsFor: 'saving'!localSaveOn: aStream	aStream		nextPutAll: 'Import: ''';		nextPutAll: self relativeFilename;		nextPut: $'! !!SmaCCRewriteFile methodsFor: 'saving'!save	filename asFileReference		ensureDelete;		writeStreamDo: [ :str | 			| stream |			stream := ZnNewLineWriterStream on: str.			stream forPlatformLineEnding.			parserClass notNil				ifTrue: [ stream						nextPutAll: 'Parser: ';						nextPutAll: parserClass name;						cr;						cr ].			rewrites				do: [ :each | each saveOn: stream ]				separatedBy: [ stream						cr;						cr ].			isModified := false ].	timestamp := self currentFileTimestamp! !!SmaCCRewriteFile methodsFor: 'saving'!saveOn: aStream	super saveOn: aStream.	self save! !!SmaCCRewriteFile methodsFor: 'rewriting'!clearLocalVariablesIn: aClass	self rewrites do: [ :each | each clearLocalVariablesIn: aClass ]! !!SmaCCRewriteFile methodsFor: 'rewriting'!updateClass: aClass	self rewrites do: [ :each | each updateClass: aClass ]! !!SmaCCRewriteFile methodsFor: 'rewriting'!performLink: aSmaCCRewriteLink on: aSmaCCNode continuation: aBlock	| link continuation |	link := aSmaCCRewriteLink.	continuation := [ self		performLink: link next		on: aSmaCCNode		continuation: aBlock ].	[ link notNil ]		whileTrue:			[ (link rewrite performOn: aSmaCCNode continuation: continuation)				ifTrue: [ ^ true ].			link := link next ].	^ aBlock value! !!SmaCCRewriteFile methodsFor: 'rewriting'!performOn: aSmaCCNode continuation: aBlock	| link |	link := cachedLists		at: aSmaCCNode class		ifAbsentPut:			[ | first |			first := SmaCCRewriteLink new.			self listForClass: aSmaCCNode class into: first.			first next ].	^ self performLink: link on: aSmaCCNode continuation: aBlock! !!SmaCCRewriteFile methodsFor: '*GT4SmaCC-Rewrite-Engine-UI'!element	^ GtSmaCCRewriteFileElement rewrite: self! !!SmaCCRewriteFile methodsFor: 'copying'!postCopy	| oldRewrites |	super postCopy.	oldRewrites := self rewrites.	rewrites := OrderedCollection new: oldRewrites size.	oldRewrites do: [ :each | self addTransformation: each copy ].	cachedLists := IdentityDictionary new! !Object subclass: #SmaCCRewriteLink	instanceVariableNames: 'rewrite next'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteLink methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: rewrite displayString;		nextPut: $)! !!SmaCCRewriteLink methodsFor: 'accessing'!next: anObject	next := anObject! !!SmaCCRewriteLink methodsFor: 'accessing'!rewrite: anObject	rewrite := anObject! !!SmaCCRewriteLink methodsFor: 'accessing'!next	^ next! !!SmaCCRewriteLink methodsFor: 'accessing'!rewrite	^ rewrite! !Object subclass: #SmaCCRewriteMatch	instanceVariableNames: 'rewrite'	classVariableNames: 'HaltBlock'	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteMatch methodsFor: 'printing'!displayString	| stream |	stream := WriteStream on: String new.	self displayOn: stream.	^ stream contents! !!SmaCCRewriteMatch methodsFor: 'printing'!displayOn: aStream	self printOn: aStream! !!SmaCCRewriteMatch methodsFor: 'public'!modified	rewrite notNil		ifTrue: [ rewrite modified ]! !!SmaCCRewriteMatch methodsFor: 'public'!saveOn: aStream	self subclassResponsibility! !!SmaCCRewriteMatch methodsFor: 'testing'!canMatch: aClass	^ true! !!SmaCCRewriteMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!method	^ nil! !!SmaCCRewriteMatch methodsFor: 'accessing'!parserClass	^ rewrite parserClass! !!SmaCCRewriteMatch methodsFor: 'accessing'!rewrite: anObject	rewrite := anObject! !!SmaCCRewriteMatch methodsFor: 'accessing'!rewrite	^ rewrite! !!SmaCCRewriteMatch methodsFor: 'copying'!postCopy	super postCopy.	rewrite := nil! !!SmaCCRewriteMatch methodsFor: 'matching'!match: aSmaCCRewriteMatchContext	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteMatch class	instanceVariableNames: ''!!SmaCCRewriteMatch class methodsFor: 'accessing'!haltBlock	^ HaltBlock ifNil: [ [ :rewrite :node | false ] ]! !!SmaCCRewriteMatch class methodsFor: 'accessing'!haltBlock: aBlock	HaltBlock := aBlock! !!SmaCCRewriteMatch class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ nil! !Object subclass: #SmaCCRewriteMatchContext	instanceVariableNames: 'rewriteEngine match nodes strings continuation'	classVariableNames: 'Continue SilentProperties Uninitialized'	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteMatchContext methodsFor: 'private'!nodes	^nodes! !!SmaCCRewriteMatchContext methodsFor: 'private'!strings	^strings! !!SmaCCRewriteMatchContext methodsFor: 'accessing-methods'!addMethodNamed: aSymbol as: aBlock	rewriteEngine addMethodNamed: aSymbol as: aBlock! !!SmaCCRewriteMatchContext methodsFor: 'accessing-methods'!addProperty: aSymbol withValue: anObject	| property |	property := anObject.	self addMethodNamed: aSymbol as: [ property ].	self		addMethodNamed: (aSymbol , ':') asSymbol		as: [ :value | property := value ]! !!SmaCCRewriteMatchContext methodsFor: 'accessing-methods'!doesNotUnderstand: aMessage	| method |	method := rewriteEngine methodNamed: aMessage selector.	method isNil		ifTrue:			[ SilentProperties				ifTrue:					[ aMessage arguments size = 1						ifTrue:							[ ^ rewriteEngine								propertyAt:									(aMessage selector copyFrom: 1 to: aMessage selector size - 1)										asSymbol								put: aMessage arguments first ].					aMessage arguments isEmpty						ifTrue: [ ^ rewriteEngine								propertyAt: aMessage selector								ifAbsent: [ nil ] ] ].			^ super doesNotUnderstand: aMessage ].	method numArgs - 1 = aMessage arguments size		ifTrue: [ ^ method				valueWithArguments: (Array with: self) , aMessage arguments ].	^ method valueWithArguments: aMessage arguments! !!SmaCCRewriteMatchContext methodsFor: 'accessing-methods'!addGlobalProperty: aSymbol withValueFrom: aBlock	rewriteEngine rewriteRule propertyAt: aSymbol ifAbsentPut: aBlock.	self		addMethodNamed: aSymbol		as: [ rewriteEngine rewriteRule propertyAt: aSymbol ].	self		addMethodNamed: (aSymbol , ':') asSymbol		as: [ :value | rewriteEngine rewriteRule propertyAt: aSymbol put: value ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteWhitespaceAfter: anObject	| anIndex |	anIndex := self stopIndexFor: anObject.	self source deleteWhitespaceAfterIndex: anIndex! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aString afterAll: aCollection	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | self insert: aString after: each ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!startIndexFor: anObject	^ ((anObject isKindOf: SmaCCParseNode)		or: [ anObject isKindOf: SmaCCToken ])		ifTrue: [ rewriteEngine startPositionForNode: anObject ]		ifFalse: [ anObject ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!replaceFrom: startIndex to: stopIndex with: aString	self insert: aString before: startIndex.	self deleteFrom: startIndex to: stopIndex! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!updateStopPositionFor: node to: endPosition whenEqualTo: anIndex	rewriteEngine		updateStopPositionFor: node		to: endPosition		whenEqualTo: anIndex! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteAll: aCollection	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | self delete: each ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!delete: anObject	| start stop |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	self deleteFrom: start to: stop! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!moveFrom: startIndex to: stopIndex before: anObject	^ self source		moveFrom: (self startIndexFor: startIndex)		to: (self stopIndexFor: stopIndex)		before: (self startIndexFor: anObject)! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!replace: anObject with: aString	anObject isNil		ifTrue: [ ^ self ].	self delete: anObject.	self insert: aString before: anObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aSequenceableCollection around: aNode	self insert: aSequenceableCollection first before: aNode.	self insert: aSequenceableCollection last after: aNode! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aString between: aCollection	aCollection isNil		ifTrue: [ ^ self ].	1 to: aCollection size - 1 do: [ :i | self insert: aString after: (aCollection at: i) ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteFrom: start to: stop	| startIndex stopIndex |	startIndex := self startIndexFor: start.	stopIndex := self stopIndexFor: stop.	(startIndex isNil or: [ stopIndex isNil ])		ifTrue: [ ^ self ].	self source deleteFrom: startIndex to: stopIndex! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteWithWhitespaceAfter: anObject	self deleteWhitespaceAfter: anObject.	self delete: anObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteWhitespaceBefore: anObject	| anIndex |	anIndex := self startIndexFor: anObject.	self source deleteWhitespaceBeforeIndex: anIndex! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!moveFrom: startIndex to: stopIndex after: anObject	^ self source		moveFrom: (self startIndexFor: startIndex)		to: (self stopIndexFor: stopIndex)		after: (self startIndexFor: anObject)! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteAllWithWhitespaceAfter: aCollection	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | self deleteWithWhitespaceAfter: each ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!addNewlineWhitespace: aString to: source	| outputStream inputStream |	(aString notNil and: [ aString notEmpty ])		ifFalse: [ ^ source ].	outputStream := WriteStream on: String new.	inputStream := ReadStream on: source asString.	[ inputStream atEnd ]		whileFalse:			[ | char endOfLine |			endOfLine := false.			char := inputStream next.			char = Character lf				ifTrue: [ endOfLine := true ].			char = Character cr				ifTrue:					[ endOfLine := true.					inputStream peek = Character lf						ifTrue: [ outputStream nextPut: char.							char := inputStream next ] ].			outputStream nextPut: char.			endOfLine				ifTrue: [ outputStream nextPutAll: aString ] ].	^ outputStream contents! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!move: anObject before: anotherObject withWhitespace: aString	| start stop oldStart |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	oldStart := self startIndexFor: anotherObject.	self source moveFrom: start to: stop before: oldStart.	aString notEmpty		ifTrue:			[ self source addNewLineWhitespace: aString from: start to: stop ].	rewriteEngine		updateStartPositionFor:			((anotherObject isKindOf: SmaCCParseNode)				ifTrue: [ anotherObject ]				ifFalse: [ match ])		to: start		whenEqualTo: oldStart.	^ self startIndexFor: anObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!stopIndexFor: anObject	^ ((anObject isKindOf: SmaCCParseNode)		or: [ anObject isKindOf: SmaCCToken ])		ifTrue: [ rewriteEngine stopPositionForNode: anObject ]		ifFalse: [ anObject ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!originalStartIndexFor: anObject	^ ((anObject isKindOf: SmaCCParseNode)		or: [ anObject isKindOf: SmaCCToken ])		ifTrue: [ anObject startPosition ]		ifFalse: [ anObject ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteWithWhitespaceBefore: anObject	self deleteWhitespaceBefore: anObject.	self delete: anObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!move: anObject after: anotherObject	^ self move: anObject after: anotherObject withWhitespace: ''! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!deleteAllWithWhitespaceBefore: aCollection	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | self deleteWithWhitespaceBefore: each ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aString beforeAll: aCollection	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | self insert: aString before: each ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!move: anObject replacing: anotherObject withWhitespace: aString	| oldStop |	oldStop := self stopIndexFor: anotherObject.	self move: anObject after: anotherObject withWhitespace: aString.	self deleteFrom: (self startIndexFor: anotherObject) to: oldStop.	^ self startIndexFor: anObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aString after: anObject	| position endPosition anIndex |	anIndex := self stopIndexFor: anObject.	anIndex isNil		ifTrue: [ ^ nil ].	position := self source		insert: aString		at: (self source nextIndex: anIndex).	position isNil		ifTrue: [ ^ nil ].	endPosition := position + (aString size - 1).	self		updateStopPositionFor:			((anObject isKindOf: SmaCCParseNode)				ifTrue: [ anObject ]				ifFalse: [ match ])		to: endPosition		whenEqualTo: anIndex.	^ position! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!replaceAll: aCollection with: aString	aCollection do: [ :each | self replace: each with: aString ]! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!sourceFor: anObject	anObject isNil		ifTrue: [ ^ '' ].	^ (self		sourceFrom: (self startIndexFor: anObject)		to: (self stopIndexFor: anObject)) asString! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!move: anObject after: anotherObject withWhitespace: aString	| start stop oldStop |	start := self startIndexFor: anObject.	stop := self stopIndexFor: anObject.	oldStop := self stopIndexFor: anotherObject.	self source moveFrom: start to: stop after: oldStop.	aString notEmpty		ifTrue:			[ self source addNewLineWhitespace: aString from: start to: stop ].	rewriteEngine		updateStopPositionFor:			((anotherObject isKindOf: SmaCCParseNode)				ifTrue: [ anotherObject ]				ifFalse: [ match ])		to: stop		whenEqualTo: oldStop.	^ self startIndexFor: anotherObject! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!move: anObject before: anotherObject	^ self move: anObject before: anotherObject withWhitespace: ''! !!SmaCCRewriteMatchContext methodsFor: 'source editing'!insert: aString before: anObject	| position anIndex |	anIndex := self startIndexFor: anObject.	anIndex isNil		ifTrue: [ ^ nil ].	position := self source insert: aString at: anIndex.	rewriteEngine		updateStartPositionFor:			((anObject isKindOf: SmaCCParseNode)				ifTrue: [ anObject ]				ifFalse: [ match ])		to: position		whenEqualTo: anIndex.	^ position! !!SmaCCRewriteMatchContext methodsFor: 'parsing'!removeQuotesAround: aString	aString isEmpty		ifTrue: [ ^ aString ].	aString first = $'		ifTrue:			[ ^ (aString copyFrom: 2 to: aString size - 1)				copyReplaceAll: ''''''				with: '''' ].	aString first = $"		ifTrue:			[ ^ (aString copyFrom: 2 to: aString size - 1)				copyReplaceAll: '""'				with: '"' ].	^ aString! !!SmaCCRewriteMatchContext methodsFor: 'parsing'!parseCsvStream: aStream withHeader: aBoolean	| array result header line |	header := nil.	result := OrderedCollection new.	(CSVParser parseStream: aStream) lines		do:			[ :each | 			array := each values				collect: [ :token | self removeQuotesAround: token value ].			aBoolean				ifTrue:					[ header isNil						ifTrue: [ header := array ]						ifFalse:							[ line := Dictionary new.							1 to: (header size min: array size) do: [ :i | line at: (header at: i) put: (array at: i) ].							array size + 1 to: header size do: [ :i | line at: (header at: i) put: nil ].							result add: line ] ]				ifFalse: [ result add: array ] ].	^ result! !!SmaCCRewriteMatchContext methodsFor: 'processing'!markAsProcessed: aSmaCCParseNode	rewriteEngine markAsProcessed: aSmaCCParseNode! !!SmaCCRewriteMatchContext methodsFor: 'processing'!processChild: aSmaCCParseNode	rewriteEngine rewriteNode: aSmaCCParseNode! !!SmaCCRewriteMatchContext methodsFor: 'processing'!processChildren: aCollection	aCollection do: [ :each | self processChild: each ]! !!SmaCCRewriteMatchContext methodsFor: 'processing'!markAllAsProcessed: aCollection	aCollection do: [ :each | self markAsProcessed: each ]! !!SmaCCRewriteMatchContext methodsFor: 'processing'!continue	continuation value! !!SmaCCRewriteMatchContext methodsFor: 'processing'!debugMethod: aMethod message: aString	| newContext process |	newContext := Context		sender: thisContext sender		receiver: self		method: aMethod		arguments: #().	newContext push: self.	process := Processor activeProcess.	[ process suspend.	process suspendedContext: newContext.	process restartTop.	process debug: newContext title: 'Debugging ' , aString full: true ] forkAt: process priority + 1! !!SmaCCRewriteMatchContext methodsFor: 'processing'!processChildren	match nodesDo: [ :each | self processChild: each ]! !!SmaCCRewriteMatchContext methodsFor: 'testing'!charactersAtAndAfter: startPosition matchesToken: aSmaCCToken	| string position |	position := startPosition.	position isNil		ifTrue: [ ^ false ].	string := aSmaCCToken value.	1 to: string size do:		[ :i | 		(string at: i) = (self originalSource at: position)			ifFalse: [ ^ false ].		position := self nextIndex: position ].	^ true! !!SmaCCRewriteMatchContext methodsFor: 'testing'!hasChild: anObject position: positionSelector	| position node |	node := nil.	(anObject isKindOf: SequenceableCollection)		ifTrue:			[ node := positionSelector = #startPosition				ifTrue: [ anObject first ]				ifFalse: [ anObject last ] ].	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ node := anObject ].	anObject isNil		ifTrue: [ ^ false ].	position := node perform: positionSelector.	node		nodesDo:			[ :child | 			(child perform: positionSelector) = position				ifTrue: [ ^ true ] ].	^ false! !!SmaCCRewriteMatchContext methodsFor: 'testing'!isAtEndOfParent: anObject	(anObject isKindOf: Collection)		ifTrue: [ anObject				reverseDo: [ :each | ^ self isAtEndOfParent: each ] ].	^ (anObject isKindOf: SmaCCParseNode)		and:			[ anObject parent notNil				and: [ anObject parent stopPosition = anObject stopPosition ] ]! !!SmaCCRewriteMatchContext methodsFor: 'testing'!hasChildAtEndOf: anObject	^ self hasChild: anObject position: #stopPosition! !!SmaCCRewriteMatchContext methodsFor: 'testing'!charactersAtAndBefore: stopPosition matchesToken: aSmaCCToken	| string position |	position := stopPosition.	position isNil		ifTrue: [ ^ false ].	string := aSmaCCToken value.	string size to: 1 do:		[ :i | 		(string at: i) = (self originalSource at: position)			ifFalse: [ ^ false ].		position := self previousIndex: position ].	^ true! !!SmaCCRewriteMatchContext methodsFor: 'testing'!isAtStartOfParent: anObject	(anObject isKindOf: Collection)		ifTrue: [ anObject do: [ :each | ^ self isAtStartOfParent: each ] ].	^ (anObject isKindOf: SmaCCParseNode)		and:			[ anObject parent notNil				and: [ anObject parent startPosition = anObject startPosition ] ]! !!SmaCCRewriteMatchContext methodsFor: 'testing'!hasChildAtStartOf: anObject	^ self hasChild: anObject position: #startPosition! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!propertyAt: aString	^ rewriteEngine propertyAt: aString! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!propertyAt: aString ifAbsentPut: aBlock	^ rewriteEngine propertyAt: aString ifAbsentPut: aBlock! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!removeProperty: aString	^ rewriteEngine removeProperty: aString! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!propertyAt: aString put: anObject	^ rewriteEngine propertyAt: aString put: anObject! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!initializeGlobalProperty: aSymbol withValueFrom: aBlock	(self class classPool at: aSymbol ifAbsent: [ nil ]) == SmaCCRewriteMatchContext uninitializedValue		ifTrue: [ self class classPool at: aSymbol put: aBlock value ]! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!additionalFiles	^ rewriteEngine additionalFiles! !!SmaCCRewriteMatchContext methodsFor: 'accessing-properites'!propertyAt: aString ifAbsent: aBlock	^ rewriteEngine propertyAt: aString ifAbsent: aBlock! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!characterAt: anIndex	^ self source at: anIndex! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!rewrite: aSmaCCParseNode	^ rewriteEngine rewrite: aSmaCCParseNode! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!whitespaceBefore: anObject	^ self originalSource		whitespaceBeforeIndex: (self originalStartIndexFor: anObject)! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!originalSource	^ match completeSource! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!smaccStringClass	^ self source class! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!outputFilename: aString	^ rewriteEngine outputFilename: aString! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!originalStopPosition: anObject	(anObject isKindOf: Collection)		ifTrue: [ anObject				reverseDo: [ :each | ^ self originalStopPosition: each ] ].	((anObject isKindOf: SmaCCParseNode)		or: [ anObject isKindOf: SmaCCToken ])		ifTrue: [ ^ anObject stopPosition ].	^ nil! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!outputDirectory: aString	^ rewriteEngine outputDirectory: aString! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!rewriteEngine	^ rewriteEngine! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!originalStartPosition: anObject	(anObject isKindOf: Collection)		ifTrue: [ anObject				do: [ :each | ^ self originalStartPosition: each ] ].	((anObject isKindOf: SmaCCParseNode)		or: [ anObject isKindOf: SmaCCToken ])		ifTrue: [ ^ anObject startPosition ].	^ nil! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!outputDirectory	^ rewriteEngine outputDirectory! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!source	^ rewriteEngine source! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!startOfLineWhitespaceBefore: anObject	^ self originalSource		startOfLineWhitespaceBeforeIndex: (self originalStartIndexFor: anObject)! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!characterAtEndOf: aSmaCCNode	| index |	index := self stopIndexFor: aSmaCCNode.	^ self		characterAt:			((self source isRemoved: index)				ifTrue: [ self source previousIndex: index ]				ifFalse: [ index ])! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!match	^ match! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!previousIndex: position	^ self originalSource previousIndex: position! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!nextIndex: position	^ self originalSource nextIndex: position! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!match: anObject	match := anObject! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!rewriteEngine: anObject	rewriteEngine := anObject! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!ignoreFile	^ rewriteEngine ignoreFile! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!computeStringFor: value	(value isKindOf: Collection)		ifTrue:			[ | first last |			first := last := nil.			value				do:					[ :each | 					(each isKindOf: SmaCCParseNode)						ifTrue:							[ self processChild: each.							first isNil								ifTrue: [ first := self startIndexFor: each ].							(self stopIndexFor: each)								ifNotNil: [ :i | 									i ~= 0										ifTrue: [ last := i ] ] ]						ifFalse:							[ (each isKindOf: SmaCCToken)								ifTrue:									[ first isNil										ifTrue: [ first := value startPosition ].									last := value stopPosition ] ] ].			(first notNil and: [ last notNil ])				ifTrue: [ ^ self sourceFrom: first to: last ] ].	(value isKindOf: SmaCCParseNode)		ifTrue: [ ^ self rewrite: value ].	^ (value isKindOf: SmaCCToken)		ifTrue: [ value value ]		ifFalse: [ value ]! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!outputFilename	^ rewriteEngine outputFilename! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!safe: aBlock	^ aBlock		on: Error		do: [ :ex | ex return ]! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!sourceFrom: first to: last	^ (self source		copyFrom: (self startIndexFor: first)		to: (self stopIndexFor: last)) asString! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!stringFor: aString	^ (strings at: aString ifAbsent: [ [ '' ] ]) value! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!nodeFor: aString	^ nodes at: aString ifAbsent: [ nil ]! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!whitespaceAfter: anObject	^ self originalSource		whitespaceAfterIndex: (self stopIndexFor: anObject)! !!SmaCCRewriteMatchContext methodsFor: 'accessing'!ignoreFile: aBoolean	^ rewriteEngine ignoreFile: aBoolean! !!SmaCCRewriteMatchContext methodsFor: 'initialize-release'!context: aDictionary	aDictionary		keysAndValuesDo:			[ :key :value | 			| cachedString |			nodes at: key name put: value.			strings				at: key name				put: [ cachedString ifNil: [ cachedString := self computeStringFor: value ] ] ]! !!SmaCCRewriteMatchContext methodsFor: 'initialize-release'!forNode: aSmaCCParseNode rewriter: aSmaCCRewriteEngine continuation: aBlock	rewriteEngine := aSmaCCRewriteEngine.	match := aSmaCCParseNode.	continuation := aBlock.	nodes := Dictionary new.	strings := Dictionary new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteMatchContext class	instanceVariableNames: ''!!SmaCCRewriteMatchContext class methodsFor: 'accessing'!silentProperties	^ SilentProperties! !!SmaCCRewriteMatchContext class methodsFor: 'accessing'!uninitializedValue	^ Uninitialized! !!SmaCCRewriteMatchContext class methodsFor: 'accessing'!continue	^ Continue! !!SmaCCRewriteMatchContext class methodsFor: 'accessing'!silentProperties: anObject	SilentProperties := anObject! !!SmaCCRewriteMatchContext class methodsFor: 'instance creation'!forNode: aSmaCCParseNode rewriter: aSmaCCRewriteEngine continuation: aBlock	^ self new		forNode: aSmaCCParseNode			rewriter: aSmaCCRewriteEngine			continuation: aBlock;		yourself! !!SmaCCRewriteMatchContext class methodsFor: 'compiling'!compiledMethodFor: aString	^ [ "Pharo"	(self compiler		source: aString;		requestor: nil;		failBlock: [ ^ nil ];		compile) copyWithSource: aString ]		on: Error		do: [ :ex | 			"Squeak version"			ex				return:					(self						compile: aString						notifying: nil						trailer: self defaultMethodTrailer						ifFail: [ ^ nil ]) method ]! !!SmaCCRewriteMatchContext class methodsFor: 'class initialization'!initialize	Continue := Object new.	SilentProperties := false.	Uninitialized := Object new! !SmaCCAbstractRewrite subclass: #SmaCCRewriteMethodDefinition	instanceVariableNames: 'comment source method'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteMethodDefinition methodsFor: 'saving'!localSaveOn: aStream	self comment notEmpty		ifTrue: [ aStream				nextPut: $";				nextPutAll: (self comment copyReplaceAll: '"' with: '""');				nextPut: $";				cr ].	aStream		nextPut: $#;		nextPutAll: (self source copyReplaceAll: '!!' with: '!!!!');		nextPut: $!!! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!code: aString	self source: aString! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!comment	^ comment ifNil: [ '' ]! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!comment: aString	comment := aString.	self changed: #comment! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!source: aString	source := aString.	method := nil.	self changed: #source! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!source	^ source ifNil: [ 'yourself' ]! !!SmaCCRewriteMethodDefinition methodsFor: 'accessing'!method	method isNil		ifTrue: [ method := SmaCCRewriteMatchContext compiledMethodFor: self source ].	^ method! !!SmaCCRewriteMethodDefinition methodsFor: 'rewriting'!updateClass: aClass	aClass addSelectorSilently: self method selector withMethod: self method! !!SmaCCRewriteMethodDefinition methodsFor: 'rewriting'!performOn: aSmaCCNode continuation: aBlock	^ false! !!SmaCCRewriteMethodDefinition methodsFor: 'printing'!displayOn: aStream	self comment notEmpty		ifTrue: [ aStream nextPutAll: self comment ]		ifFalse: [ | stream |			stream := ReadStream on: self source.			aStream				nextPutAll: 'Method: ';				nextPutAll: stream nextLine ]! !!SmaCCRewriteMethodDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| tabulator |	(tabulator := aPresentation tabulator)		row: [ :row | 			row				column: #label size: 75;				column: #comment ]			size: 25;		row: #source.	tabulator transmit		to: #label;		andShow: [ :presentation | presentation label display: 'Comment:' ].	tabulator transmit		to: #comment;		andShow: [ :presentation | 			presentation text				display: self comment;				onChangeOfPort: #text act: [ :text | self comment: text text asString ] ].	tabulator updateOn: #source from: #yourself.	tabulator transmit		to: #source;		andShow: [ :presentation | 			presentation pharoMethod				title: 'Source';				smalltalkClass: [ self contextClass ];				display: self source;				onChangeOfPort: #text act: [ :text | self source: text text asString ];				morphicSelectionAct: [ :text | 						text							text: (RBParser parseMethod: text text asString) formattedCode;							update ]					icon: GLMUIThemeExtraIcons glamorousPlay					on: $t					entitled: 'Format' ]! !!SmaCCRewriteMethodDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!rewriteForMethod: aMethod	aMethod == self method		ifTrue: [ ^ self ].	^ nil! !!SmaCCRewriteMethodDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!title	^ 'Method'! !!SmaCCRewriteMethodDefinition methodsFor: '*GT4SmaCC-Rewrite-Engine-UI'!element	^ GtSmaCCMethodDefinitionElement rewrite: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteMethodDefinition class	instanceVariableNames: ''!!SmaCCRewriteMethodDefinition class methodsFor: 'instance creation'!comment: commentString source: aString	^ self new		comment: commentString;		source: aString;		yourself! !!SmaCCRewriteMethodDefinition class methodsFor: 'instance creation'!source: aString	^ self new		source: aString;		yourself! !Object subclass: #SmaCCRewriteProcessor	instanceVariableNames: 'rules parserClass inputDirectory outputDirectory files validationParserClass rewriteEngine baseDirectory lineEnding'	classVariableNames: 'Debug'	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteProcessor methodsFor: 'accessing'!validationParserClass	^ validationParserClass! !!SmaCCRewriteProcessor methodsFor: 'accessing'!ruleFile: aString	self parseRewriteRuleFile: aString! !!SmaCCRewriteProcessor methodsFor: 'accessing'!debug	^ self class debug! !!SmaCCRewriteProcessor methodsFor: 'accessing'!engine	rewriteEngine isNil		ifTrue:			[ rewriteEngine := SmaCCRewriteEngine new.			rewriteEngine rewriteRule: self rules ].	^ rewriteEngine! !!SmaCCRewriteProcessor methodsFor: 'accessing'!parseRewriteRuleFile: aString	rules := SmaCCRewriteRuleFileParser parseFile: aString! !!SmaCCRewriteProcessor methodsFor: 'accessing'!debug: aBoolean	self class debug: aBoolean! !!SmaCCRewriteProcessor methodsFor: 'accessing'!lineEnding: aSymbol	lineEnding := aSymbol! !!SmaCCRewriteProcessor methodsFor: 'accessing'!files: aCollection	files := aCollection! !!SmaCCRewriteProcessor methodsFor: 'accessing'!processAllNotifying: postBlock	self files do: [ :each | postBlock value: (self processFile: each) ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!processFile: aString	^ self processFile: aString usingResult: SmaCCRewriteResult new! !!SmaCCRewriteProcessor methodsFor: 'accessing'!validationParserClass: aSmaCCParserClass	validationParserClass := aSmaCCParserClass! !!SmaCCRewriteProcessor methodsFor: 'accessing'!inputDirectory: aString	inputDirectory := aString! !!SmaCCRewriteProcessor methodsFor: 'accessing'!parseFile: aString	| source |	source := self sourceFor: aString.	^ self parserClass parse: source! !!SmaCCRewriteProcessor methodsFor: 'accessing'!outputDirectory: aString	outputDirectory := aString! !!SmaCCRewriteProcessor methodsFor: 'accessing'!extension	^ self parserClass fileExtension! !!SmaCCRewriteProcessor methodsFor: 'accessing'!outputDirectory	^ outputDirectory! !!SmaCCRewriteProcessor methodsFor: 'accessing'!rules	^ rules! !!SmaCCRewriteProcessor methodsFor: 'accessing'!parserClass: aSmaCCParserClass	parserClass := aSmaCCParserClass! !!SmaCCRewriteProcessor methodsFor: 'accessing'!saveOutput: aString in: aFilename	| directory tries |	(aFilename isNil or: [ aFilename isEmpty ])		ifTrue: [ ^ self ].	aString isEmpty		ifTrue: [ ^ self ].	directory := aFilename asFileReference parent pathString.	tries := 1.	[ tries < 10 and: [ directory asFileReference exists not ] ]		whileTrue: [ [ directory asFileReference ensureCreateDirectory ]				on: Error				do: [ :ex | ex return ].			tries := tries + 1 ].	aFilename asFileReference		ensureDelete;		writeStreamDo: [ :str | 			| stream |			stream := str.			self lineEnding notNil				ifTrue: [ stream := ZnNewLineWriterStream on: str.					self lineEnding = #crLf						ifTrue: [ stream forCrLf ].					self lineEnding = #lf						ifTrue: [ stream forLf ].					self lineEnding = #cr						ifTrue: [ stream forCr ] ].			stream nextPutAll: aString ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!baseDirectory: aString	baseDirectory := aString! !!SmaCCRewriteProcessor methodsFor: 'accessing'!lineEnding	^ lineEnding! !!SmaCCRewriteProcessor methodsFor: 'accessing'!baseDirectory	^ baseDirectory ifNil: [ '' ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!validate: aString forResult: aSmaCCRewriteResult	| stream |	self validationParserClass isNil		ifTrue: [ ^ self ].	stream := SmaCCLineNumberStream on: (ReadStream on: aString).	[ self validationParserClass parseStream: stream ]		on: SmaCCParserError		do:			[ :ex | 			| parser token |			parser := ex tag.			token := parser errorToken.			token notNil				ifTrue:					[ aSmaCCRewriteResult						startLine: (stream lineNumberFor: (token startPosition ifNil: [ 1 ]));						startColumn: (stream columnNumberFor: (token startPosition ifNil: [ 1 ]));						interval: ((token startPosition ifNil: [ 1 ]) to: (token stopPosition ifNil: [ 1 ])) ].			aSmaCCRewriteResult				errorString: 'Validation error';				type: #warning ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!files	^ files ifNil: [ files := self inputFilenames ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!parserClass	^ parserClass! !!SmaCCRewriteProcessor methodsFor: 'accessing'!processFile: aString usingResult: aSmaCCRewriteResult	| input output tree stream subdirectory fullFilename |	(Smalltalk includesKey: #Smalltalk)		ifFalse: [ Smalltalk at: #Smalltalk put: Smalltalk ].	"Add Smalltalk back if it got stripped"	aSmaCCRewriteResult filename: aString.	[ input := self sourceFor: aString.	aSmaCCRewriteResult inputSource: input.	stream := SmaCCLineNumberStream on: (ReadStream on: input).	tree := [ self parserClass parseStream: stream ]		on: SmaCCParserError		do: [ :ex | 			| parser token |			parser := ex tag.			token := parser errorToken.			token notNil				ifTrue: [ aSmaCCRewriteResult						startLine: (stream lineNumberFor: token startPosition);						startColumn: (stream columnNumberFor: token startPosition);						interval: token sourceInterval ].			ex pass ].	tree		completeSource: input;		filename: aString.	subdirectory := self baseDirectory isEmpty		ifTrue: [ '' ]		ifFalse: [ aString asFileReference parent pathString				copyFrom: self baseDirectory size + 1				to: aString asFileReference parent pathString size ].	fullFilename := (self outputDirectory isNil		or: [ self outputDirectory isEmpty ])		ifTrue: [ '' ]		ifFalse: [ self outputDirectory , FileSystem disk delimiter asString				, subdirectory ].	self engine		source: (aSmaCCRewriteResult smaccStringClass on: input);		outputDirectory: fullFilename;		outputFilename:			aString asFileReference basenameWithoutExtension				,					(self validationParserClass isNil						ifTrue: [ '' ]						ifFalse: [ self validationParserClass fileExtension ]).	output := [ self engine rewriteTree: tree ]		on: Error		do: [ :ex | 			| frame node |			frame := thisContext.			[ frame isNil				or: [ (frame receiver isKindOf: SmaCCRewrite)						and: [ frame method selector = #performOn:continuation: ] ] ]				whileFalse: [ frame := frame sender ].			frame notNil				ifTrue: [ node := frame tempAt: 1.					aSmaCCRewriteResult						startLine: (stream lineNumberFor: node startPosition);						startColumn: (stream columnNumberFor: node startPosition);						interval: node sourceInterval;						transformation: frame receiver ].			ex pass ].	aSmaCCRewriteResult		outputSource: output;		transformedString: self engine source;		outputFilename: self engine outputFilename.	self engine additionalFiles		keysAndValuesDo: [ :file :text | aSmaCCRewriteResult addFile: text named: file ].	(self outputDirectory isNil or: [ self outputDirectory isEmpty ])		ifFalse: [ | filename |			filename := self engine outputDirectory				,					((self engine outputDirectory isEmpty						or: [ self engine outputDirectory last = FileSystem disk delimiter ])						ifTrue: [ '' ]						ifFalse: [ String with: FileSystem disk delimiter ])				, self engine outputFilename.			self engine ignoreFile				ifFalse: [ self saveOutput: output in: filename ].			self engine additionalFiles				keysAndValuesDo: [ :file :text | self saveOutput: text in: file ] ].	self engine finished.	aSmaCCRewriteResult class == SmaCCRewriteResult		ifFalse: [ self validate: output forResult: aSmaCCRewriteResult ] ]		on: Error		do: [ :ex | 			aSmaCCRewriteResult				type:					(output isNil						ifTrue: [ #error ]						ifFalse: [ #warning ]).			aSmaCCRewriteResult errorString: ex description.			(self debug and: [ Processor activeProcess respondsTo: #debug ])				ifTrue: [ Processor activeProcess debug ].			((Smalltalk options select: [ :each | '-/' includes: each first ])				collect: [ :each | each copyFrom: 2 to: each size ])				do: [ :each | 					(each sameAs: 'error')						ifTrue: [ ex pass ] ].			ex return ].	^ aSmaCCRewriteResult! !!SmaCCRewriteProcessor methodsFor: 'accessing'!inputFilenames	| names |	names := OrderedCollection new.	(self inputDirectory asFileReference		allChildrenMatching: '*' , self extension)		do: [ :each | names add: each path ].	^ names! !!SmaCCRewriteProcessor methodsFor: 'accessing'!rules: aSmaCCAbstractRewrite	rules := aSmaCCAbstractRewrite! !!SmaCCRewriteProcessor methodsFor: 'accessing'!sourceFor: aString	| fileRef |	fileRef := aString asFileReference.	^ [ fileRef contents ]		on: Error		do: [ :ex | 			| encoding |			encoding := [ fileRef				binaryReadStreamDo: [ :in | (ZnCharacterEncoder detectEncoding: in upToEnd) identifier ] ]				on: ZnCharacterEncodingError				do: [ nil ].			fileRef				readStreamDo: [ :stream | 					SmaCCParser setEncoding: encoding on: stream.					stream contents ] ]! !!SmaCCRewriteProcessor methodsFor: 'accessing'!inputDirectory	^ inputDirectory! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteProcessor class	instanceVariableNames: ''!!SmaCCRewriteProcessor class methodsFor: 'accessing'!debug	^ Debug ifNil: [ false ]! !!SmaCCRewriteProcessor class methodsFor: 'accessing'!debug: aBoolean	Debug := aBoolean! !SmaCCAbstractRewrite subclass: #SmaCCRewritePropertyDefinition	instanceVariableNames: 'comment propertyNames globalValues'	classVariableNames: 'Reader Writer'	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewritePropertyDefinition methodsFor: 'initialize-release'!initialize	super initialize.	propertyNames := Set new.	globalValues := Dictionary new! !!SmaCCRewritePropertyDefinition methodsFor: 'private'!createPropertyMethodsFor: aSymbol in: aClass	| method variable setterName |	method := self class readerPrototype copy.	variable := aClass classPool associationAt: aSymbol.	method literalAt: 1 put: variable.	method literalAt: 2 put: aSymbol.	aClass addSelectorSilently: aSymbol withMethod: method.	setterName := (aSymbol , ':') asSymbol.	method := self class writerPrototype copy.	method literalAt: 1 put: variable.	method literalAt: 2 put: setterName.	aClass addSelectorSilently: setterName withMethod: method! !!SmaCCRewritePropertyDefinition methodsFor: '*GT4SmaCC-Rewrite-Engine-UI'!element	^ GtSmaCCPropertyDefinitionElement rewrite: self! !!SmaCCRewritePropertyDefinition methodsFor: 'printing'!displayOn: aStream	self comment notEmpty		ifTrue: [ aStream nextPutAll: self comment ]		ifFalse: [ aStream				nextPutAll: 'Properties: ';				print: propertyNames size;				nextPutAll: ' local, ';				print: globalValues size;				nextPutAll: ' global' ]! !!SmaCCRewritePropertyDefinition methodsFor: 'rewriting'!clearLocalVariablesIn: aClass	propertyNames do: [ :each | aClass classPool at: each asSymbol put: nil ]! !!SmaCCRewritePropertyDefinition methodsFor: 'rewriting'!updateClass: aClass	propertyNames		do: [ :each | 			aClass classPool at: each asSymbol put: nil.			self createPropertyMethodsFor: each asSymbol in: aClass ].	globalValues		associationsDo: [ :assoc | 			aClass classPool add: assoc.			self createPropertyMethodsFor: assoc name in: aClass ]! !!SmaCCRewritePropertyDefinition methodsFor: 'rewriting'!performOn: aSmaCCNode continuation: aBlock	^ false! !!SmaCCRewritePropertyDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!addLocal	| variable |	variable := UITheme builder textEntry: 'Enter variable name:' title: 'Variable' entryText: ''.	(variable notNil and: [ RBScanner isVariable: variable ])		ifTrue: [ self addLocal: variable ]! !!SmaCCRewritePropertyDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| tabulator |	(tabulator := aPresentation tabulator)		row: [ :row | 			row				column: #label size: 75;				column: #comment ]			size: 25;		row: #locals;		row: #globals.	tabulator transmit		to: #label;		andShow: [ :presentation | presentation label display: 'Comment:' ].	tabulator transmit		to: #comment;		andShow: [ :presentation | 			presentation text				display: self comment;				onChangeOfPort: #text act: [ :text | self comment: text text asString ] ].	tabulator transmit		to: #locals;		andShow: [ :presentation | 			presentation list				title: 'Locals';				updateOn: #locals from: [ self announcer ];				act: [ self addLocal ] icon: GLMUIThemeExtraIcons glamorousAdd entitled: 'Add';				act: [ :list | self removeLocal: list selection ] icon: GLMUIThemeExtraIcons glamorousRemove entitled: 'Remove';				display: [ propertyNames asSortedCollection ] ].	tabulator transmit		to: #globals;		andShow: [ :presentation | 			presentation list				title: 'Globals';				updateOn: #globals from: [ self announcer ];				act: [ self addGlobal ] icon: GLMUIThemeExtraIcons glamorousAdd entitled: 'Add';				act: [ :list | self removeGlobal: list selection ] icon: GLMUIThemeExtraIcons glamorousRemove entitled: 'Remove';				display: [ globalValues keys asSortedCollection ] ]! !!SmaCCRewritePropertyDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!rewriteForMethod: aMethod	^ nil! !!SmaCCRewritePropertyDefinition methodsFor: '*SmaCC_Rewrite_Engine_UI'!addGlobal	| variable |	variable := UITheme builder textEntry: 'Enter variable name:' title: 'Variable' entryText: ''.	(variable notNil and: [ RBScanner isVariable: variable ])		ifTrue: [ self addGlobal: variable ]! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!removeGlobal: aString	globalValues removeKey: aString asSymbol ifAbsent: [  ].	self changed: #globals! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!addLocal: aString	propertyNames add: aString.	self changed: #locals! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!comment	^ comment ifNil: [ '' ]! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!addGlobal: aString	globalValues at: aString asSymbol put: SmaCCRewriteMatchContext uninitializedValue.	self changed: #globals! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!addAllLocals: aCollection	aCollection do: [ :each | self addLocal: each ]! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!addAllGlobals: aCollection	aCollection do: [ :each | self addGlobal: each ]! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!comment: aString	comment := aString.	self changed: #comment! !!SmaCCRewritePropertyDefinition methodsFor: 'accessing'!removeLocal: aString	propertyNames remove: aString ifAbsent: [  ].	self changed: #locals! !!SmaCCRewritePropertyDefinition methodsFor: 'saving'!localSaveOn: aStream	self comment notEmpty		ifTrue: [ aStream				nextPut: $";				nextPutAll: (self comment copyReplaceAll: '"' with: '""');				nextPut: $";				cr ].	aStream		nextPut: $(;		cr.	propertyNames asSortedCollection		do: [ :each | 			aStream				nextPut: $-;				nextPutAll: each;				cr ].	globalValues keys asSortedCollection		do: [ :each | 			aStream				nextPut: $+;				nextPutAll: each;				cr ].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewritePropertyDefinition class	instanceVariableNames: ''!!SmaCCRewritePropertyDefinition class methodsFor: 'instance creation'!comment: aString locals: localPropertyNames globals: globalPropertyNames	^ self new		comment: aString;		addAllLocals: localPropertyNames;		addAllGlobals: globalPropertyNames;		yourself! !!SmaCCRewritePropertyDefinition class methodsFor: 'accessing'!writerPrototype	^ Writer ifNil: [ Writer := SmaCCRewriteMatchContext compiledMethodFor: 'selector: anObject ^Uninitialized := anObject' ]! !!SmaCCRewritePropertyDefinition class methodsFor: 'accessing'!readerPrototype	^ Reader ifNil: [ Reader := SmaCCRewriteMatchContext compiledMethodFor: 'selector ^Uninitialized' ]! !Object subclass: #SmaCCRewriteResult	instanceVariableNames: 'filename outputFilename errorString type startLine startColumn interval transformation'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteResult methodsFor: 'accessing'!addFile: aSmaCCString named: aString	! !!SmaCCRewriteResult methodsFor: 'accessing'!inputSource: aString	! !!SmaCCRewriteResult methodsFor: 'accessing'!smaccStringClass	^ SmaCCString! !!SmaCCRewriteResult methodsFor: 'accessing'!outputFilename: anObject	outputFilename := anObject! !!SmaCCRewriteResult methodsFor: 'accessing'!type	^ type! !!SmaCCRewriteResult methodsFor: 'accessing'!startLine	^ startLine! !!SmaCCRewriteResult methodsFor: 'accessing'!outputSource: aString	! !!SmaCCRewriteResult methodsFor: 'accessing'!interval	^ interval! !!SmaCCRewriteResult methodsFor: 'accessing'!filename	^ filename! !!SmaCCRewriteResult methodsFor: 'accessing'!startColumn	^ startColumn! !!SmaCCRewriteResult methodsFor: 'accessing'!errorString	^ errorString! !!SmaCCRewriteResult methodsFor: 'accessing'!errorString: anObject	errorString := anObject! !!SmaCCRewriteResult methodsFor: 'accessing'!outputFilename	^ outputFilename! !!SmaCCRewriteResult methodsFor: 'accessing'!transformation: anObject	transformation := anObject! !!SmaCCRewriteResult methodsFor: 'accessing'!interval: anObject	interval := anObject! !!SmaCCRewriteResult methodsFor: 'accessing'!filename: anObject	filename := anObject! !!SmaCCRewriteResult methodsFor: 'accessing'!startColumn: anInteger	startColumn := anInteger! !!SmaCCRewriteResult methodsFor: 'accessing'!transformation	^ transformation! !!SmaCCRewriteResult methodsFor: 'accessing'!additionalFiles	^ Dictionary new! !!SmaCCRewriteResult methodsFor: 'accessing'!startLine: anInteger	startLine := anInteger! !!SmaCCRewriteResult methodsFor: 'accessing'!transformedString: aSmaCCAnnotatedString	! !!SmaCCRewriteResult methodsFor: 'accessing'!type: aSymbol	type := aSymbol! !!SmaCCRewriteResult methodsFor: 'public'!transformedString	^ SmaCCAnnotatedString on: ''! !!SmaCCRewriteResult methodsFor: 'public'!inputSource	^ ''! !!SmaCCRewriteResult methodsFor: 'public'!outputSource	^ ''! !!SmaCCRewriteResult methodsFor: 'testing'!isWarning	^ type = #warning! !!SmaCCRewriteResult methodsFor: 'testing'!isError	^ type = #error! !!SmaCCRewriteResult methodsFor: 'converting'!asTabDelimitedString	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: filename;		tab;		nextPutAll: (errorString ifNil: [ '' ]);		tab;		nextPutAll: (type ifNil: [ '' ]);		tab;		nextPutAll: (startLine ifNil: [ '' ] ifNotNil: [ :value | value printString ]);		tab;		nextPutAll: (startColumn ifNil: [ '' ] ifNotNil: [ :value | value printString ]);		tab;		nextPutAll:			(transformation				ifNil: [ '' ]				ifNotNil: [ :value | value displayString ]).	^ stream contents! !!SmaCCRewriteResult methodsFor: 'converting'!asSocketString	| stream null |	stream := WriteStream on: String new.	null := Character value: 0.	stream		nextPutAll: 'FILENAME=';		nextPutAll: filename;		nextPut: null.	errorString notNil		ifTrue:			[ stream				nextPutAll: 'ERRORSTRING=';				nextPutAll: errorString;				nextPut: null ].	type notNil		ifTrue:			[ stream				nextPutAll: 'TYPE=';				nextPutAll: type;				nextPut: null ].	startLine notNil		ifTrue:			[ stream				nextPutAll: 'STARTLINE=';				print: startLine;				nextPut: null ].	startColumn notNil		ifTrue:			[ stream				nextPutAll: 'STARTCOLUMN=';				print: startColumn;				nextPut: null ].	interval notNil		ifTrue:			[ stream				nextPutAll: 'INTERVAL=';				print: interval first;				nextPut: $-;				print: interval last;				nextPut: null ].	transformation notNil		ifTrue:			[ stream				nextPutAll: 'TRANSFORMATION=';				nextPutAll: transformation displayString;				nextPut: null ].	^ stream contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteResult class	instanceVariableNames: ''!!SmaCCRewriteResult class methodsFor: 'instance creation'!fromSocketString: aString	| result |	result := self new.	aString		splitFirstOn: (Character value: 0)		andThen: $=		do:			[ :key :value | 			key = 'FILENAME'				ifTrue: [ result filename: value ].			key = 'ERRORSTRING'				ifTrue: [ result errorString: value ].			key = 'TYPE'				ifTrue: [ result type: value asSymbol ].			key = 'STARTLINE'				ifTrue: [ result startLine: value asNumber ].			key = 'STARTCOLUMN'				ifTrue: [ result startColumn: value asNumber ].			key = 'INTERVAL'				ifTrue:					[ | items |					items := value substrings: $- asString.					result interval: (items first asNumber to: items last asNumber) ].			key = 'TRANSFORMATION'				ifTrue: [ result transformation: value ] ].	^ result! !SmaCCRewriteResult subclass: #SmaCCRewriteCompleteResult	instanceVariableNames: 'inputSource outputSource transformedString additionalFiles'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteCompleteResult methodsFor: 'accessing'!smaccStringClass	^ SmaCCAnnotatedString! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!addFile: aSmaCCString named: aString	self additionalFiles at: aString put: aSmaCCString! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!inputSource	^ inputSource! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!transformedString	^ transformedString ifNil: [ super transformedString ]! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!outputSource	^ outputSource! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!outputSource: aString	outputSource := aString! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!transformedString: aSmaCCAnnotatedString	transformedString := aSmaCCAnnotatedString! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!inputSource: aString	inputSource := aString! !!SmaCCRewriteCompleteResult methodsFor: 'accessing'!additionalFiles	^ additionalFiles ifNil: [ additionalFiles := Dictionary new ]! !SmaCCParser subclass: #SmaCCRewriteRuleFileParser	instanceVariableNames: 'filename'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForImport1: nodes	^ ((nodes at: 3) value copyFrom: 2 to: (nodes at: 3) value size - 1)		copyReplaceAll: ''''''		with: ''''! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForParserClass1: nodes	^ self lookupClass: (nodes at: 3)! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForMatch3: nodes	^ SmaCCRewriteTypeMatch on: (self lookupClass: (nodes at: 1))! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForVariable1: nodes	^ Array with: false with: (nodes at: 2) value! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForMatch4: nodes	^ (SmaCCRewriteTypeMatch on: (self lookupClass: (nodes at: 1)))		code: (nodes at: 2);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRules1: nodes	^ SmaCCRewriteFile new		filename: filename;		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRule3: nodes	^ SmaCCRewritePropertyDefinition		comment: (nodes at: 1)		locals:			(((nodes at: 2) reject: [ :each | each first ])				collect: [ :each | each last ])		globals:			(((nodes at: 2) select: [ :each | each first ])				collect: [ :each | each last ])! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRule2: nodes	^ SmaCCRewriteMethodDefinition		comment: (nodes at: 1)		source:			(((nodes at: 2) value copyFrom: 2 to:				(nodes at: 2) value size - 1) copyReplaceAll: '!!!!' with: '!!')! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRules4: nodes	^ (nodes at: 1)		import: (nodes at: 2);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForMatch2: nodes	^ SmaCCRewriteTreeMatch new		source: (nodes at: 2);		startingState: (nodes at: 1) value;		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForVariable2: nodes	^ Array with: true with: (nodes at: 2) value! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRules2: nodes	^ (nodes at: 1)		addTransformation: (nodes at: 2);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForTransformation1: nodes	^ SmaCCRewriteStringTransformation on: (nodes at: 1)! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForStartStringExpression1: nodes	^ self scanStringExpression! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForVariableList1: nodes	^ OrderedCollection new! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForMatch1: nodes	^ SmaCCRewriteTreeMatch new		source: (nodes at: 1);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForComment2: nodes	^ ((nodes at: 1) value copyFrom: 2 to: (nodes at: 1) value size - 1)		copyReplaceAll: '""'		with: '"'! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForTransformation2: nodes	^ SmaCCRewriteCodeTransformation on: (nodes at: 1)! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRules3: nodes	^ (nodes at: 1)		parserClass: (nodes at: 2);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForRule1: nodes	^ SmaCCRewrite		comment: (nodes at: 1)		match: (nodes at: 2)		transformation: (nodes at: 4)! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForVariableList2: nodes	^ (nodes at: 1)		add: (nodes at: 2);		yourself! !!SmaCCRewriteRuleFileParser methodsFor: 'generated-reduction actions'!reduceActionForStartSmalltalkExpression1: nodes	^ self scanSmalltalkExpression! !!SmaCCRewriteRuleFileParser methodsFor: 'private'!scanStringExpression	^ scanner scanStringExpression! !!SmaCCRewriteRuleFileParser methodsFor: 'private'!lookupClass: aSmaCCToken	| string block |	string := aSmaCCToken value.	block := [ :each | 	each name asString = string		ifTrue: [ ^ each ] ].	SmaCCParseNode withAllSubclasses do: block.	SmaCCParser allSubclassesDo: block.	^ nil! !!SmaCCRewriteRuleFileParser methodsFor: 'private'!scanSmalltalkExpression	^ scanner scanSmalltalkExpression! !!SmaCCRewriteRuleFileParser methodsFor: 'private'!filename: aString	filename := aString! !!SmaCCRewriteRuleFileParser methodsFor: 'private'!tryAllTokens	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteRuleFileParser class	instanceVariableNames: ''!!SmaCCRewriteRuleFileParser class methodsFor: 'generated'!definitionComment"<singleName>	: (<isLetter> | _) (<isLetter> | <isDigit> | _)*	;<name>	: <singleName> (\. <singleName>)*	;<string>	: (\' [^\']* \') +	;<cmt>	: (\""[^\""]*\"")+	;<method>	: \#([^!!]|!!!!)+ !!	;<whitespace>	: <isSeparator>+	;File	: Rules {'1'}	;Rules	: {SmaCCRewriteFile new filename: filename; yourself}	| Rules Rule {'1' addTransformation: '2'; yourself}	| Rules ParserClass {'1' parserClass: '2'; yourself}	| Rules Import {'1' import: '2'; yourself}	;ParserClass	: ""Parser"" "":"" <name> 'name' {self lookupClass: name}	;Import	: ""Import"" "":"" <string> 'name' {(name value copyFrom: 2 to: name value size - 1) copyReplaceAll: '''''' with: ''''}	;Rule	: Comment 'comment' Match 'match' ""->"" Transformation 'transformation' {SmaCCRewrite comment: comment match: match transformation: transformation}	| Comment 'comment' <method> 'method' {SmaCCRewriteMethodDefinition comment: comment source: ((method value copyFrom: 2 to: method value size - 1) copyReplaceAll: '!!!!' with: '!!')}	| Comment 'comment' Variables 'variables' {SmaCCRewritePropertyDefinition comment: comment locals: ((variables reject: [:each | each first]) collect: [:each | each last]) globals: ((variables select: [:each | each first]) collect: [:each | each last])}	;Comment	: {nil}	| <cmt> {('1' value copyFrom: 2 to: '1' value size - 1) copyReplaceAll: '""""' with: '""'}	;Variables	: ""("" VariableList 'vars' "")"" {vars}	;VariableList	: {OrderedCollection new}	| VariableList 'vars' Variable 'var' {vars add: var; yourself}	;Variable	: ""-"" <name> 'name' {Array with: false with: name value}	| ""+"" <name> 'name' {Array with: true with: name value}	;Match	: StringExpression {SmaCCRewriteTreeMatch new source: '1'; yourself}	| <name> 'state' StringExpression 'exp' {SmaCCRewriteTreeMatch new source: exp; startingState: state value; yourself}	| <name> {SmaCCRewriteTypeMatch on: (self lookupClass: '1')}	| <name> Block {(SmaCCRewriteTypeMatch on: (self lookupClass: '1')) code: '2'; yourself}	;StringExpression	: StartStringExpression 'string' "">>>"" ""<<<"" {string}	;Transformation	: StringExpression {SmaCCRewriteStringTransformation on: '1'}	| Block {SmaCCRewriteCodeTransformation on: '1'}	;Block	: StartSmalltalkExpression 'string' ""[""  ""]"" {string}	;StartStringExpression	: {self scanStringExpression}	;StartSmalltalkExpression	: {self scanSmalltalkExpression}	;"! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated'!startingStateForFile	^ 1! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated'!reduceTable^#(	#(20 0 #reduceActionForRules1: 263169 false ) 	#(24 0 #nil 1290241 false ) 	#(19 1 #liftFirstValue: 239617 false ) 	#(24 1 #reduceActionForComment2: 1290242 false ) 	#(20 2 #reduceActionForRules3: 263171 false ) 	#(20 2 #reduceActionForRules4: 263172 false ) 	#(20 2 #reduceActionForRules2: 263170 false ) 	#(32 0 #reduceActionForStartStringExpression1: 2328577 false ) 	#(26 0 #reduceActionForVariableList1: 1454081 false ) 	#(28 1 #reduceActionForMatch3: 1693699 false ) 	#(33 0 #reduceActionForStartSmalltalkExpression1: 2385921 false ) 	#(23 2 #reduceActionForRule2: 685058 false ) 	#(23 2 #reduceActionForRule3: 685059 false ) 	#(28 1 #reduceActionForMatch1: 1693697 false ) 	#(22 3 #reduceActionForImport1: 555009 false ) 	#(21 3 #reduceActionForParserClass1: 483329 false ) 	#(28 2 #reduceActionForMatch2: 1693698 false ) 	#(28 2 #reduceActionForMatch4: 1693700 false ) 	#(25 3 #liftSecondValue: 1401857 false ) 	#(26 2 #reduceActionForVariableList2: 1454082 false ) 	#(30 1 #reduceActionForTransformation1: 2128897 false ) 	#(23 4 #reduceActionForRule1: 685057 false ) 	#(30 1 #reduceActionForTransformation2: 2128898 false ) 	#(29 3 #liftFirstValue: 2052097 false ) 	#(27 2 #reduceActionForVariable2: 1563650 false ) 	#(27 2 #reduceActionForVariable1: 1563649 false ) 	#(31 3 #liftFirstValue: 2263041 false )	).! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated'!transitionTable^#(#[1 0 6 0 1 0 6 0 8 0 6 0 9 0 6 0 10 0 6 0 13 0 6 0 15 0 6 0 16 0 9 0 19 0 13 0 20 0 6 0 34] #[0 0 0 0 34] #[1 0 10 0 1 0 10 0 8 0 17 0 9 0 21 0 10 0 10 0 13 0 25 0 15 0 10 0 16 0 29 0 21 0 33 0 22 0 37 0 23 0 41 0 24 0 14 0 34] #[0 0 45 0 6] #[0 0 49 0 6] #[0 0 18 0 1 0 8 0 13 0 16] #[0 0 22 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 26 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 30 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[1 0 53 0 1 0 34 0 8 0 57 0 13 0 61 0 16 0 65 0 25 0 69 0 28 0 73 0 29 0 77 0 32] #[0 0 81 0 14] #[0 0 85 0 13] #[1 0 38 0 2 0 38 0 3 0 38 0 4 0 89 0 26] #[1 0 42 0 5 0 34 0 8 0 46 0 11 0 93 0 29 0 97 0 31 0 77 0 32 0 101 0 33] #[0 0 50 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 54 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 105 0 5] #[0 0 58 0 5] #[0 0 109 0 8] #[0 0 62 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 66 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[1 0 113 0 2 0 117 0 3 0 121 0 4 0 125 0 27] #[0 0 70 0 5] #[0 0 74 0 5] #[0 0 129 0 11] #[1 0 34 0 8 0 46 0 11 0 133 0 29 0 137 0 30 0 141 0 31 0 77 0 32 0 101 0 33] #[0 0 145 0 7] #[0 0 78 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 149 0 13] #[0 0 153 0 13] #[0 0 82 0 2 0 3 0 4] #[0 0 157 0 12] #[0 0 86 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 90 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 94 0 1 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 98 0 1 0 5 0 8 0 9 0 10 0 13 0 15 0 16 0 34] #[0 0 102 0 2 0 3 0 4] #[0 0 106 0 2 0 3 0 4] #[0 0 110 0 1 0 5 0 8 0 9 0 10 0 13 0 15 0 16 0 34]	).! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated'!symbolNames	^ #('"("' '")"' '"+"' '"-"' '"->"' '":"' '"<<<"' '">>>"' '"Import"' '"Parser"' '"["' '"]"' '<name>' '<string>' '<cmt>' '<method>' '<whitespace>' 'B e g i n' 'File' 'Rules' 'ParserClass' 'Import' 'Rule' 'Comment' 'Variables' 'VariableList' 'Variable' 'Match' 'StringExpression' 'Transformation' 'Block' 'StartStringExpression' 'StartSmalltalkExpression' 'E O F' 'error')! !!SmaCCRewriteRuleFileParser class methodsFor: 'file types'!fileExtension	^ '.rw'! !!SmaCCRewriteRuleFileParser class methodsFor: 'file types'!fileExtensionType	^ 'SmaCC Rewrite files'! !!SmaCCRewriteRuleFileParser class methodsFor: 'accessing'!parseFile: aString	^ aString asFileReference		readStreamDo: [ :stream | 			| parser |			parser := self on: stream.			parser filename: aString.			parser parse				filename: aString;				finishedLoading;				yourself ]! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated-accessing'!scannerClass	^SmaCCRewriteRuleFileScanner! !!SmaCCRewriteRuleFileParser class methodsFor: 'generated-accessing'!cacheId	^'2019-04-15T17:15:43.378181-05:00'! !SmaCCScanner subclass: #SmaCCRewriteRuleFileScanner	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX7	currentCharacter == $(		ifTrue: [ ^ self recordAndReportMatch: #(1) ].	currentCharacter == $)		ifTrue: [ ^ self recordAndReportMatch: #(2) ].	currentCharacter == $+		ifTrue: [ ^ self recordAndReportMatch: #(3) ].	currentCharacter == $-		ifTrue:			[ ^ self scanForTokenX1 ].	currentCharacter == $:		ifTrue: [ ^ self recordAndReportMatch: #(6) ].	currentCharacter == $<		ifTrue:			[ ^ self scanForTokenX4 ].	currentCharacter == $>		ifTrue:			[ ^ self scanForTokenX3 ].	currentCharacter == $[		ifTrue: [ ^ self recordAndReportMatch: #(11) ].	currentCharacter == $]		ifTrue: [ ^ self recordAndReportMatch: #(12) ].	currentCharacter isSeparator		ifTrue:			[ ^ self scanForTokenX2 ].	(currentCharacter isLetter or: [ currentCharacter == $_ ])		ifTrue: [ ^ self scan4 ].	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX1	self recordMatch: #(4).	self step.	currentCharacter == $>		ifTrue: [ ^ self recordAndReportMatch: #(5) ].	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!errorTokenId	^ 35! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX4	(self scanForString: '<<')		ifTrue: [ ^ self recordAndReportMatch: #(7) ].	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!tokenActions	^ #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil #whitespace)! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scan2	[ self step.	currentCharacter == $!!		ifTrue: [ self recordMatch: #(16).			self step.			currentCharacter == $!!				ifTrue: [ ^ self scan2 ].			^ self reportLastMatch ].	true ] whileTrue! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scan4	[ self recordMatch: #(13).	self step.	currentCharacter == $.		ifTrue: [ self step.			(currentCharacter isLetter or: [ currentCharacter == $_ ])				ifTrue: [ ^ self scan4 ].			^ self reportLastMatch ].	currentCharacter isAlphaNumeric or: [ currentCharacter == $_ ] ]		whileTrue.	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX2	[ self recordMatch: #(17).	self step.	currentCharacter isSeparator ] whileTrue.	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scan3	[ self step.	currentCharacter == $'		ifTrue: [ self recordMatch: #(14).			self step.			currentCharacter == $'				ifTrue: [ ^ self scan3 ].			^ self reportLastMatch ].	true ] whileTrue! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX5	self step.	currentCharacter == $!!		ifTrue: [ ^ self scan2 ].	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForToken	self step.	currentCharacter == $"		ifTrue: [ ^ self scan1 ].	currentCharacter == $#		ifTrue:			[ ^ self scanForTokenX6 ].	currentCharacter == $'		ifTrue: [ ^ self scan3 ].	^ self scanForTokenX7! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!emptySymbolTokenId	^ 34! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX6	self step.	currentCharacter == $!!		ifTrue: [ ^ self scanForTokenX5 ].	^ self scan2! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scanForTokenX3	(self scanForString: '>>')		ifTrue: [ ^ self recordAndReportMatch: #(8) ].	^ self reportLastMatch! !!SmaCCRewriteRuleFileScanner methodsFor: 'generated'!scan1	[ self step.	currentCharacter == $"		ifTrue: [ self recordMatch: #(15).			self step.			currentCharacter == $"				ifTrue: [ ^ self scan1 ].			^ self reportLastMatch ].	true ] whileTrue! !!SmaCCRewriteRuleFileScanner methodsFor: 'private'!isValidSmalltalk: aString	RBParser parseExpression: aString onError: [ :e :p | ^ false ].	^ true! !!SmaCCRewriteRuleFileScanner methodsFor: 'private'!scanStringExpression	| string |	string := stream upToAll: '<<<'.	stream position: stream position - 3.	^ string! !!SmaCCRewriteRuleFileScanner methodsFor: 'private'!fixExpression: expression	| rewriter tree |	rewriter := self class rewriter.	rewriter isNil		ifTrue: [ ^ expression ].	tree := RBParser parseExpression: expression.	[ rewriter executeTree: tree ] whileTrue: [ tree := rewriter tree ].	^ tree formattedCode! !!SmaCCRewriteRuleFileScanner methodsFor: 'private'!scanSmalltalkExpression	| expression |	expression := ''.	[ stream atEnd		ifTrue: [ self error: 'Invalid Smalltalk expression' ].	expression := expression , (stream upTo: $]).	self isValidSmalltalk: expression ] whileFalse: [ expression := expression copyWith: $] ].	stream position: stream position - 1.	^ self fixExpression: expression! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteRuleFileScanner class	instanceVariableNames: 'rewriter'!!SmaCCRewriteRuleFileScanner class methodsFor: 'generated-initialization'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(13 'Import' 9) #(13 'Parser' 10))		do: [ :each | 			(keywordMap at: each first ifAbsentPut: [ Dictionary new ])				at: (each at: 2)				put: each last ].	^ keywordMap! !!SmaCCRewriteRuleFileScanner class methodsFor: 'accessing'!rewriter	^ rewriter! !!SmaCCRewriteRuleFileScanner class methodsFor: 'accessing'!rewriter: aParseTreeRewriter	rewriter := aParseTreeRewriter! !Object subclass: #SmaCCRewriteTransformation	instanceVariableNames: 'rewrite'	classVariableNames: 'HaltBlock'	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteTransformation methodsFor: 'saving'!saveOn: aStream	self subclassResponsibility! !!SmaCCRewriteTransformation methodsFor: 'transforming'!transformUsingContext: aSmaCCRewriteMatchContext	self subclassResponsibility! !!SmaCCRewriteTransformation methodsFor: 'accessing'!rewrite: aSmaCCRewrite	rewrite := aSmaCCRewrite! !!SmaCCRewriteTransformation methodsFor: 'accessing'!rewrite	^ rewrite! !!SmaCCRewriteTransformation methodsFor: 'copying'!postCopy	super postCopy.	rewrite := nil! !!SmaCCRewriteTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!method	^ nil! !!SmaCCRewriteTransformation methodsFor: 'public'!modified	rewrite notNil		ifTrue: [ rewrite modified ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteTransformation class	instanceVariableNames: ''!!SmaCCRewriteTransformation class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ nil! !!SmaCCRewriteTransformation class methodsFor: 'accessing'!haltBlock	^ HaltBlock ifNil: [ [ :rewrite :node | false ] ]! !!SmaCCRewriteTransformation class methodsFor: 'accessing'!haltBlock: aBlock	HaltBlock := aBlock! !SmaCCRewriteTransformation subclass: #SmaCCRewriteCodeTransformation	instanceVariableNames: 'code method'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteCodeTransformation methodsFor: 'initialize-release'!code: aString	code := aString.	method := nil.	self modified! !!SmaCCRewriteCodeTransformation methodsFor: 'initialize-release'!initialize	super initialize.	code := 'self continue'! !!SmaCCRewriteCodeTransformation methodsFor: 'transforming'!transformUsingContext: aSmaCCRewriteMatchContext	self class haltBlock		ifNotNil: [ :block | 			(block value: rewrite value: aSmaCCRewriteMatchContext match)				ifTrue: [ ^ aSmaCCRewriteMatchContext debugMethod: self method message: rewrite displayString ] ].	^ self method valueWithReceiver: aSmaCCRewriteMatchContext arguments: #()! !!SmaCCRewriteCodeTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| updating |	updating := false.	aPresentation pharoScript		display: (self code ifNil: [ '' ]);		title: 'Code';		smalltalkClass: [ rewrite contextClass ];		onChangeOfPort: #text			act: [ :text | 			updating				ifFalse: [ self code: text text asString ] ];		morphicSelectionAct: [ :text | 				self code: (RBParser parseExpression: text text asString) formattedCode.				updating := true.				[ text update ]					ensure: [ updating := false ] ]			icon: GLMUIThemeExtraIcons glamorousPlay			on: $t			entitled: 'Format'! !!SmaCCRewriteCodeTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!source	^ self code! !!SmaCCRewriteCodeTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!title	^ 'Transformation'! !!SmaCCRewriteCodeTransformation methodsFor: 'saving'!saveOn: aStream	aStream		nextPut: $[;		nextPutAll: code;		nextPut: $]! !!SmaCCRewriteCodeTransformation methodsFor: 'accessing'!code	^ code! !!SmaCCRewriteCodeTransformation methodsFor: 'accessing'!method	method isNil		ifTrue: [ | tree rewriter |			tree := RBParser parseMethod: 'code ' , code.			tree body addReturn.			rewriter := RBParseTreeRewriter new.			rewriter replace: '^self continue' with: '^Continue'.			rewriter executeTree: tree.			method := SmaCCRewriteMatchContext compiledMethodFor: rewriter tree formattedCode ].	^ method! !!SmaCCRewriteCodeTransformation methodsFor: 'accessing'!string	^ code! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteCodeTransformation class	instanceVariableNames: ''!!SmaCCRewriteCodeTransformation class methodsFor: 'instance creation'!on: aString	^ self new		code: aString;		yourself! !!SmaCCRewriteCodeTransformation class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ #Code! !SmaCCRewriteTransformation subclass: #SmaCCRewriteStringTransformation	instanceVariableNames: 'string expression'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteStringTransformation methodsFor: 'initialize-release'!string	^ string ifNil: [ '' ]! !!SmaCCRewriteStringTransformation methodsFor: 'initialize-release'!initialize	super initialize.	string := ''! !!SmaCCRewriteStringTransformation methodsFor: 'initialize-release'!string: aString	string := aString.	expression := nil.	self modified! !!SmaCCRewriteStringTransformation methodsFor: 'transforming'!transformUsingContext: aSmaCCRewriteMatchContext	| newSource |	newSource := self expression		evaluateInContext: aSmaCCRewriteMatchContext.	aSmaCCRewriteMatchContext		replace: aSmaCCRewriteMatchContext match		with: newSource! !!SmaCCRewriteStringTransformation methodsFor: 'public'!saveOn: aStream	aStream		nextPutAll: '>>>';		nextPutAll: self string;		nextPutAll: '<<<'! !!SmaCCRewriteStringTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	aPresentation text		display: (self string ifNil: [ '' ]);		title: 'Replacement Pattern';		onChangeOfPort: #text act: [ :text | self string: text text asString ]! !!SmaCCRewriteStringTransformation methodsFor: '*SmaCC_Rewrite_Engine_UI'!source	^ self string! !!SmaCCRewriteStringTransformation methodsFor: 'accessing'!expression	^ expression		ifNil: [ expression := SmaCCReplaceExpressionParser parse: self string ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteStringTransformation class	instanceVariableNames: ''!!SmaCCRewriteStringTransformation class methodsFor: 'instance creation'!on: aString	^ self new		string: aString;		yourself! !!SmaCCRewriteStringTransformation class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ #String! !SmaCCRewriteMatch subclass: #SmaCCRewriteTreeMatch	instanceVariableNames: 'startingState source trees'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteTreeMatch methodsFor: 'accessing'!trees	^ trees		ifNil: [ trees := [ startingState isNil				ifTrue: [ self parserClass parseAndCacheAllPossibleStates: source ]				ifFalse: [ self parserClass parseAndCacheAll: source startingAt: self startingStateIndex ] ]				on: SmaCCParserError				do: [ :ex | ex return: #() ] ]! !!SmaCCRewriteTreeMatch methodsFor: 'accessing'!trees: aCollection	trees := aCollection! !!SmaCCRewriteTreeMatch methodsFor: 'private'!startingStateIndex	startingState isNil		ifTrue: [ ^ 1 ].	^ self parserClass		perform: ('startingStateFor' , startingState) asSymbol! !!SmaCCRewriteTreeMatch methodsFor: 'initialize-release'!initialize	super initialize.	source := ''! !!SmaCCRewriteTreeMatch methodsFor: 'testing'!canMatch: aClass	^ self trees		anySatisfy: [ :each | each class == aClass or: [ each isKindOf: SmaCCPatternNode ] ]! !!SmaCCRewriteTreeMatch methodsFor: 'matching'!match: aSmaCCRewriteMatchContext	| context |	1 to: self trees size do:		[ :i | 		context := Dictionary new.		((trees at: i)			match: aSmaCCRewriteMatchContext match			inContext: context)			ifTrue: [ ^ context ] ].	^ nil! !!SmaCCRewriteTreeMatch methodsFor: 'printing'!displayOn: aStream	aStream		nextPutAll:			((source isNil or: [ source isEmpty ])				ifTrue: [ '"Empty"' ]				ifFalse: [ source ])! !!SmaCCRewriteTreeMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| browser states |	browser := aPresentation tabulator.	browser		row: [ :row | 			row				column: #label size: 50;				column: #state;				column: #empty size: 1 ]			size: 25;		row: #value.	browser transmit		to: #label;		andShow: [ :presentation | presentation label display: 'State:' ].	states := self parserStartingStates.	browser transmit		to: #state;		andShow: [ :presentation | 			presentation dropDownList				display: [ states ];				selectedIndex: (states indexOf: self startingState);				onChangeOfPort: #selection act: [ :list | self startingState: list selection ] ].	browser transmit		to: #value;		andShow: [ :presentation | 			presentation text				display: (self source ifNil: [ '' ]);				title: 'Pattern';				onChangeOfPort: #text act: [ :text | self source: text text asString ] ]! !!SmaCCRewriteTreeMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!parserStartingStates	^ ((self parserClass class allSelectors select: [ :each | each beginsWith: 'startingStateFor' ])		collect: [ :each | each asString copyFrom: 17 to: each size ]) asSortedCollection! !!SmaCCRewriteTreeMatch methodsFor: 'public'!startingState	^ startingState! !!SmaCCRewriteTreeMatch methodsFor: 'public'!saveOn: aStream	startingState notNil		ifTrue: [ aStream				nextPutAll: startingState;				cr ].	aStream		nextPutAll: '>>>';		nextPutAll: source;		nextPutAll: '<<<'! !!SmaCCRewriteTreeMatch methodsFor: 'public'!startingState: aString	startingState := aString.	self modified! !!SmaCCRewriteTreeMatch methodsFor: 'public'!source: aString	source := aString.	trees := nil.	self modified! !!SmaCCRewriteTreeMatch methodsFor: 'public'!source	^ source! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteTreeMatch class	instanceVariableNames: ''!!SmaCCRewriteTreeMatch class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ #Pattern! !SmaCCRewriteMatch subclass: #SmaCCRewriteTypeMatch	instanceVariableNames: 'nodeClass code method enableDebug'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCRewriteTypeMatch methodsFor: 'private'!method	method isNil		ifTrue: [ | tree |			tree := RBParser parseMethod: 'code ' , code.			tree body statements isEmpty				ifTrue: [ ^ method := Object compiledMethodAt: #notNil ].			tree body addReturn.			method := SmaCCRewriteMatchContext compiledMethodFor: tree formattedCode ].	^ method! !!SmaCCRewriteTypeMatch methodsFor: 'accessing'!enableDebug	^ enableDebug! !!SmaCCRewriteTypeMatch methodsFor: 'accessing'!code	^ code! !!SmaCCRewriteTypeMatch methodsFor: 'accessing'!code: aString	code := aString.	method := nil.	self modified! !!SmaCCRewriteTypeMatch methodsFor: 'accessing'!enableDebug: aBoolean	enableDebug := aBoolean! !!SmaCCRewriteTypeMatch methodsFor: 'accessing'!nodeClass	^ nodeClass! !!SmaCCRewriteTypeMatch methodsFor: 'matching'!codeMatches: aSmaCCRewriteMatchContext	(code isNil or: [ code isEmpty ])		ifTrue: [ ^ true ].	self class haltBlock		ifNotNil: [ :block | 			(block value: rewrite value: aSmaCCRewriteMatchContext match)				ifTrue: [ ^ (aSmaCCRewriteMatchContext debugMethod: self method message: rewrite displayString) == true ] ].	^ (enableDebug and: [ SmaCCRewriteProcessor debug ])		ifTrue: [ self methodMatches: aSmaCCRewriteMatchContext ]		ifFalse: [ [ self methodMatches: aSmaCCRewriteMatchContext ]				on: Error				do: [ :ex | ex return: false ] ]! !!SmaCCRewriteTypeMatch methodsFor: 'matching'!methodMatches: aSmaCCRewriteMatchContext	^ (self method valueWithReceiver: aSmaCCRewriteMatchContext arguments: #()) = true! !!SmaCCRewriteTypeMatch methodsFor: 'matching'!match: aSmaCCRewriteMatchContext	| dictionary |	(aSmaCCRewriteMatchContext match isKindOf: nodeClass)		ifFalse: [ ^ nil ].	(self codeMatches: aSmaCCRewriteMatchContext)		ifFalse: [ ^ nil ].	dictionary := Dictionary new.	aSmaCCRewriteMatchContext match		allGettersDo:			[ :each | 			dictionary				at: (SmaCCPatternToken value: each asString)				put: (aSmaCCRewriteMatchContext match perform: each) ].	^ dictionary! !!SmaCCRewriteTypeMatch methodsFor: 'saving'!saveOn: aStream	aStream		nextPutAll:			(nodeClass isNil				ifTrue: [ 'nil' ]				ifFalse: [ nodeClass name ]).	(code isNil or: [ code isEmpty ])		ifTrue: [ ^ self ].	aStream		cr;		nextPut: $[;		nextPutAll: code;		nextPut: $]! !!SmaCCRewriteTypeMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!buildInterfaceIn: aPresentation	| browser classes |	browser := aPresentation tabulator.	browser		row: [ :row | 			row				column: #label size: 50;				column: #class;				column: #debug size: 50 ]			size: 25;		row: [ :row | 			row				column: #value span: 2;				column: #variables ].	browser transmit		to: #label;		andShow: [ :presentation | presentation label display: 'Class:' ].	classes := SmaCCParseNode withAllSubclasses asSortedCollection: [ :a :b | a name < b name ].	browser transmit		to: #class;		andShow: [ :presentation | 			presentation dropDownList				display: [ classes ];				selectedIndex: (classes indexOf: self nodeClass);				onChangeOfPort: #selection act: [ :list | self nodeClass: list selection ] ].	browser transmit		to: #debug;		andShow: [ :presentation | 			| button |			presentation morph				morph:					((button := SimpleSwitchMorph new)						target: self;						actionSelector: #enableDebug:;						arguments: #();						setSwitchState: self enableDebug;						label: 'Debug';						yourself) ].	browser transmit		to: #value;		andShow: [ :presentation | 			presentation pharoScript				display: (self code ifNil: [ '' ]);				title: 'Code';				smalltalkClass: [ rewrite contextClass ];				onChangeOfPort: #text act: [ :text | self code: text text asString ];				morphicSelectionAct: [ :text | 						text							text: (RBParser parseExpression: text text asString) formattedCode;							update ]					icon: GLMUIThemeExtraIcons glamorousPlay					on: $t					entitled: 'Format' ].	browser transmit		from: #class port: #selection;		to: #variables;		andShow: [ :presentation | 			presentation fastList				title: [ :selection | selection ifNil: [ 'Variables' ] ifNotNil: [ selection name ] ];				display: [ :selection | 					selection notNil						ifTrue: [ (Set new								addAll: selection allInstVarNames;								removeAll: SmaCCParseNode allInstVarNames;								yourself) asSortedCollection ]						ifFalse: [ #() ] ];				act: [ :list | ((browser paneNamed: #class) port: #selection) value ifNotNil: [ :sel | Smalltalk tools browser openOnClass: sel ] ]					icon: GLMUIThemeExtraIcons glamorousBrowse					entitled: 'Browse' ]! !!SmaCCRewriteTypeMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!source	^ self code! !!SmaCCRewriteTypeMatch methodsFor: '*SmaCC_Rewrite_Engine_UI'!title	^ 'Match'! !!SmaCCRewriteTypeMatch methodsFor: 'initialize-release'!initialize	super initialize.	nodeClass := SmaCCParseNode.	code := ''.	enableDebug := false! !!SmaCCRewriteTypeMatch methodsFor: 'initialize-release'!nodeClass: aClass	nodeClass := aClass.	self modified! !!SmaCCRewriteTypeMatch methodsFor: 'testing'!canMatch: aClass	^ aClass includesBehavior: nodeClass! !!SmaCCRewriteTypeMatch methodsFor: 'printing'!displayOn: aStream	aStream nextPutAll: nodeClass name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRewriteTypeMatch class	instanceVariableNames: ''!!SmaCCRewriteTypeMatch class methodsFor: '*SmaCC_Rewrite_Engine_UI'!type	^ #Type! !!SmaCCRewriteTypeMatch class methodsFor: 'instance creation'!on: aClass	^ self new		enableDebug: false;		nodeClass: aClass;		yourself! !SmaCCReplaceExpression subclass: #SmaCCStringReplaceExpression	instanceVariableNames: 'string'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCStringReplaceExpression methodsFor: 'evaluating'!evaluateInContext: aSmaCCRewriteMatchContext	^ string value! !!SmaCCStringReplaceExpression methodsFor: 'generated'!string	^ string! !!SmaCCStringReplaceExpression methodsFor: 'generated'!tokenVariables	^ #(#string)! !!SmaCCStringReplaceExpression methodsFor: 'generated'!string: aSmaCCToken	string := aSmaCCToken! !!SmaCCStringReplaceExpression methodsFor: 'generated'!acceptVisitor: aReplaceVisitor	^ aReplaceVisitor visitStringReplace: self! !Model subclass: #SmaCCTransformationToolkitModel	instanceVariableNames: 'modified files inputParserClass validationParserClass rewrites outputDirectory server runOnServer createSubdirectories commonParentDirectory lineEnding'	classVariableNames: ''	package: 'SmaCC_Rewrite_Engine'!!SmaCCTransformationToolkitModel methodsFor: 'testing'!isModified: aBoolean	modified := aBoolean! !!SmaCCTransformationToolkitModel methodsFor: 'testing'!areRewritesModified	^ self rewrites notNil and: [ self rewrites isModified ]! !!SmaCCTransformationToolkitModel methodsFor: 'testing'!isModified	^ modified or: [ self areRewritesModified ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!runOnServer: aBoolean	runOnServer := aBoolean.	modified := true.	self changed: #runOnServer with: aBoolean! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!server: aString	server := aString.	modified := true.	self changed: #server with: aString! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!runOnServer	^ runOnServer ifNil: [ false ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!lineEnding: aSymbol	lineEnding := aSymbol! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!files: aCollection	files := aCollection.	modified := true.	self changed: #files with: aCollection! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!validationParserClass: aSmaCCParserClass	validationParserClass := aSmaCCParserClass.	modified := true.	self changed: #validationParserClass with: aSmaCCParserClass! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!inputParserClass: aSmaCCParserClass	inputParserClass := aSmaCCParserClass.	modified := true.	self changed: #inputParserClass with: aSmaCCParserClass! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!inputParserClass	^ inputParserClass! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!serverPort	^ (self serverAndPort: 36rSM from: self server) last! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!server	^ (server isNil or: [ server isEmpty ])		ifTrue: [ 'localhost' ]		ifFalse: [ server ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!outputDirectory: aString	outputDirectory := aString.	modified := true.	self changed: #outputDirectory with: aString! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!createSubdirectories	^ createSubdirectories ifNil: [ false ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!outputDirectory	^ outputDirectory ifNil: [ '' ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!rewrites	^ rewrites! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!createSubdirectories: aBoolean	createSubdirectories := aBoolean.	modified := true.	self changed: #createSubdirectories with: aBoolean! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!rewrites: aSmaCCRewrite	rewrites := aSmaCCRewrite.	modified := true.	self changed: #rewrites with: aSmaCCRewrite! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!lineEnding	^ lineEnding! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!files	^ files ifNil: [ #() ]! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!serverName	^ (self serverAndPort: 36rSM from: self server) first! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!commonParentDirectory: aString	commonParentDirectory := aString! !!SmaCCTransformationToolkitModel methodsFor: 'accessing'!validationParserClass	^ validationParserClass! !!SmaCCTransformationToolkitModel methodsFor: 'actions'!loadFile: aString	aString asFileReference		readStreamDo: [ :stream | 			self class compiler				source: stream contents;				logged: false;				receiver: self;				evaluate.			self isModified: false ]! !!SmaCCTransformationToolkitModel methodsFor: 'actions-running'!runOn: tranformationFiles	self runOnServer		ifTrue: [ self serverRunOn: tranformationFiles ]		ifFalse: [ self localRunOn: tranformationFiles ]! !!SmaCCTransformationToolkitModel methodsFor: 'actions-rewrites'!openRewriteFile: filename	| fileRef |	fileRef := filename asFileReference.	^ fileRef exists		ifTrue: [ SmaCCRewriteRuleFileParser parseFile: fileRef pathString ]		ifFalse: [ SmaCCRewriteFile new				filename: fileRef pathString;				yourself ]! !!SmaCCTransformationToolkitModel methodsFor: 'actions-rewrites'!addTransformation: aSmaCCAbstractRewrite under: aSmaCCRewriteFile	self		addTransformation: aSmaCCAbstractRewrite		under: aSmaCCRewriteFile		before: nil! !!SmaCCTransformationToolkitModel methodsFor: 'actions-rewrites'!removeTransformation: aSmaCCAbstractRewrite	aSmaCCAbstractRewrite parent		removeTransformation: aSmaCCAbstractRewrite.	self changed: #removedTransformation: with: aSmaCCAbstractRewrite! !!SmaCCTransformationToolkitModel methodsFor: 'actions-rewrites'!addTransformation: aSmaCCAbstractRewrite under: aSmaCCRewriteFile before: anotherSmaCCAbstractRewrite	anotherSmaCCAbstractRewrite isNil		ifTrue: [ aSmaCCRewriteFile addTransformation: aSmaCCAbstractRewrite ]		ifFalse:			[ aSmaCCRewriteFile				addTransformation: aSmaCCAbstractRewrite				before: anotherSmaCCAbstractRewrite ].	self		changed: #addTransformation:under:		with:			(Array with: aSmaCCAbstractRewrite with: aSmaCCRewriteFile)! !!SmaCCTransformationToolkitModel methodsFor: 'public'!loadRewriteFile: aString	aString isNil		ifTrue: [ ^ self ].	self rewrites: (self openRewriteFile: aString)! !!SmaCCTransformationToolkitModel methodsFor: 'public'!saveTo: filename	filename asFileReference		ensureDelete;		writeStreamDo: [ :stream | 			stream				nextPutAll: 'self';				cr;				tab;				nextPutAll: 'inputParserClass: ';				nextPutAll: self inputParserClass storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'validationParserClass: ';				nextPutAll: self validationParserClass storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'loadRewriteFile: ';				nextPutAll: self rewrites filename storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'files: ';				nextPutAll: self files asArray storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'outputDirectory: ';				nextPutAll: self outputDirectory storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'createSubdirectories: ';				nextPutAll: self createSubdirectories storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'server: ';				nextPutAll: self server storeString;				nextPut: $;;				cr;				tab;				nextPutAll: 'runOnServer: ';				nextPutAll: self runOnServer storeString ].	modified := false.	self areRewritesModified		ifTrue: [ self saveRewrites ]! !!SmaCCTransformationToolkitModel methodsFor: 'public'!saveRewrites	self rewrites save! !!SmaCCTransformationToolkitModel methodsFor: 'public'!toggleUseServer	self runOnServer: self runOnServer not! !!SmaCCTransformationToolkitModel methodsFor: 'initialize/release'!initialize	super initialize.	modified := false.	rewrites := SmaCCRewriteFile new! !!SmaCCTransformationToolkitModel methodsFor: 'private'!serverAndPort: defaultPort from: aString	| serverName port parts |	parts := aString substrings: $: asString.	(parts size = 2		and:			[ parts last notEmpty				and: [ parts last allSatisfy: [ :each | each isDigit ] ] ])		ifTrue: [ serverName := parts first.			port := parts last asNumber ]		ifFalse: [ serverName := aString.			port := defaultPort ].	^ Array with: serverName with: port! !!SmaCCTransformationToolkitModel methodsFor: 'running'!terminateServer	| socket serverStream |	socket := Socket newTCP		connectTo: (NetNameResolver addressForName: self serverName) port: self serverPort;		yourself.	(serverStream := SocketStream on: socket) binary.	[ serverStream		nextPut: $E asInteger;		flush.	[ serverStream next ]		on: Error		do: [ :ex | "We should get here when the server quits" ex return ] ]		ensure: [ serverStream close ]! !!SmaCCTransformationToolkitModel methodsFor: 'running'!localRunOn: aCollection	SmaCCRewriteProcessor new		rules: self rewrites;		parserClass: self inputParserClass;		validationParserClass: self validationParserClass;		files: aCollection;		outputDirectory: self outputDirectory;		baseDirectory: self commonParentDirectory;		lineEnding: self lineEnding;		processAllNotifying: [ :each | self changed: #resultAdded with: each ]! !!SmaCCTransformationToolkitModel methodsFor: 'running'!commonParentDirectory	| common |	commonParentDirectory notNil		ifTrue: [ ^ commonParentDirectory ].	(self files isEmpty or: [ self createSubdirectories not ])		ifTrue: [ ^ '' ].	common := self files first asFileReference parent pathString.	self files		do: [ :each | 			[ common isEmpty or: [ each beginsWith: common ] ]				whileFalse: [ common := (common isEmpty						or: [ (common size = 3 and: [ (common at: 2) = $: ]) or: [ common size = 1 and: [ common first = $/ ] ] ])						ifTrue: [ '' ]						ifFalse: [ (common copyFrom: 1 to: common size - 1) asFileReference parent pathString ] ] ].	^ common! !!SmaCCTransformationToolkitModel methodsFor: 'running'!serverRunOn: aCollection	| baseString stream socket request serverStream |	baseString := 'INPUTPARSER=' , self inputParserClass name		, ';REWRITEFILE=' , self rewrites filename.	self outputDirectory notEmpty		ifTrue: [ baseString := baseString , ';OUTPUTDIRECTORY='				, self outputDirectory ].	baseString := baseString , ';BASEDIRECTORY='		, self commonParentDirectory.	self validationParserClass notNil		ifTrue: [ baseString := baseString , ';OUTPUTPARSER='				, self validationParserClass name ].	self lineEnding notNil		ifTrue:			[ baseString := baseString , ';LINEENDING=' , self lineEnding asString ].	stream := WriteStream on: String new.	aCollection		do: [ :each | 			stream				nextPutAll: baseString;				nextPutAll: ';FILE=';				nextPutAll: each;				nextPut: (Character value: 0) ].	request := stream contents.	socket := Socket newTCP		connectTo: (NetNameResolver addressForName: self serverName)			port: self serverPort;		yourself.	(serverStream := SocketStream on: socket) binary.	[ serverStream		noTimeout;		nextPut: $1 asInteger;		nextPut: (request size bitAnd: 255);		nextPut: (request size >> 8 bitAnd: 255);		nextPut: (request size >> 16 bitAnd: 255);		nextPut: (request size >> 24 bitAnd: 255);		nextPutAll: request asByteArray;		flush.	aCollection size		timesRepeat: [ self				changed: #resultAdded				with:					(SmaCCRewriteResult						fromSocketString:							(serverStream								next:									serverStream next + (serverStream next << 8)										+ (serverStream next << 16) + (serverStream next << 24))								asString) ] ]		ensure: [ socket close ]! !!SmaCCTransformationToolkitModel methodsFor: '*SmaCC_Rewrite_Engine_UI'!changed: aSymbol with: anObject	super changed: aSymbol with: anObject.	self announcer announce: aSymbol! !!SmaCCTransformationToolkitModel methodsFor: '*SmaCC_Rewrite_Engine_UI'!changed: aSymbol	super changed: aSymbol.	self announcer announce: aSymbol! !SmaCCRewriteMatchContext initialize!'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:54.184656 pm'!!String methodsFor: '*SmaCC_Rewrite_Engine'!splitFirstOn: firstCharacter andThen: secondCharacter do: aBlock	(self substrings: firstCharacter asString)		do:			[ :each | 			| index |			index := each indexOf: secondCharacter.			index ~= 0				ifTrue:					[ aBlock						value: (each copyFrom: 1 to: index - 1)						value: (each copyFrom: index + 1 to: each size) ] ]! !