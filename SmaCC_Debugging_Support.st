Object subclass: #SmaCCGraphNode	instanceVariableNames: 'state name success followed directLinks previousNodes reductions parser'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Roassal'!!SmaCCGraphNode methodsFor: 'accessing'!parser: aSmaCCParser	parser := aSmaCCParser! !!SmaCCGraphNode methodsFor: 'accessing'!name: aString	name := aString! !!SmaCCGraphNode methodsFor: 'accessing'!success: aBoolean	success := aBoolean! !!SmaCCGraphNode methodsFor: 'accessing'!followed: aSmaCCGraphNode	followed := aSmaCCGraphNode.	aSmaCCGraphNode notNil		ifTrue: [ aSmaCCGraphNode addPrevious: self ]! !!SmaCCGraphNode methodsFor: 'accessing'!description	| stream |	previousNodes isEmpty		ifTrue: [ ^ 'Start' ].	success		ifTrue: [ ^ 'Parsing was successful' ].	stream := WriteStream on: String new.	reductions asSortedCollection do: [ :each | stream nextPutAll: each ] separatedBy: [ stream cr ].	^ stream contents! !!SmaCCGraphNode methodsFor: 'accessing'!directLinks	^ directLinks! !!SmaCCGraphNode methodsFor: 'accessing'!followed	^ followed! !!SmaCCGraphNode methodsFor: 'accessing'!name	^ name! !!SmaCCGraphNode methodsFor: 'accessing'!success	^ success! !!SmaCCGraphNode methodsFor: 'accessing'!addDirectLinkToNodeNamed: aString state: anInteger	| node |	(followed notNil and: [ followed name = aString ])		ifTrue: [ ^ followed ].	directLinks		do: [ :each | 			each name = aString				ifTrue: [ ^ each ] ].	node := self class named: aString state: anInteger parser: parser.	node addPrevious: self.	^ directLinks add: node! !!SmaCCGraphNode methodsFor: 'accessing'!state: anInteger	state := anInteger! !!SmaCCGraphNode methodsFor: 'accessing'!allNodes	| nodes |	nodes := IdentitySet new.	self allNodesInto: nodes.	^ nodes! !!SmaCCGraphNode methodsFor: 'accessing'!state	^ state! !!SmaCCGraphNode methodsFor: 'accessing'!addReduction: aString	reductions add: aString! !!SmaCCGraphNode methodsFor: 'initialize-release'!initialize	super initialize.	name := ''.	success := false.	directLinks := OrderedCollection new.	previousNodes := OrderedCollection new.	reductions := Set new! !!SmaCCGraphNode methodsFor: 'testing'!isFollowed	^ previousNodes isEmpty or: [ previousNodes anySatisfy: [ :each | each followed == self ] ]! !!SmaCCGraphNode methodsFor: 'private'!addPrevious: aSmaCCGraphNode	previousNodes add: aSmaCCGraphNode! !!SmaCCGraphNode methodsFor: 'private'!allNodesInto: aCollection	(aCollection includes: self)		ifTrue: [ ^ self ].	aCollection add: self.	followed notNil		ifTrue: [ followed allNodesInto: aCollection ].	directLinks do: [ :each | each allNodesInto: aCollection ]! !!SmaCCGraphNode methodsFor: 'private'!stack	| stack |	stack := previousNodes notEmpty		ifTrue: [ previousNodes first stack ]		ifFalse: [ OrderedCollection new ].	stack add: state.	^ stack! !!SmaCCGraphNode methodsFor: 'inspecting'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	(composite respondsTo: #roassal2)		ifFalse: [ ^ self ].	composite roassal2		title: 'Graph';		initializeView: [ parser roassalViewForStack: self stack ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCGraphNode class	instanceVariableNames: ''!!SmaCCGraphNode class methodsFor: 'instance creation'!named: aString state: anInteger parser: aSmaCCParser	^ self new		name: aString;		state: anInteger;		parser: aSmaCCParser;		yourself! !!SmaCCGraphNode class methodsFor: 'inspecting'!gtExampleSmaCCGraphNode	<gtExample>	<label: 'SmaCCGraphNode'>	| parser |	parser := SmaCCDefinitionParser new.	^ SmaCCGraphNode		named: ''		state: parser class defaultStartingState		parser: parser! !Error subclass: #SmaCCParserSimulationError	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Simulation'!!SmaCCParserSimulationError methodsFor: 'testing'!isInputIncomplete	self token isSyntaxError		ifTrue: [ ^ false ].	^ (self simulator symbolForId: self token ids first) name = 'E O F'! !!SmaCCParserSimulationError methodsFor: 'accessing'!nodeStack	^ self simulator currentParserState nodeStack copy! !!SmaCCParserSimulationError methodsFor: 'accessing'!stateStack	^ self simulator currentParserState stateStack copy! !!SmaCCParserSimulationError methodsFor: 'accessing'!token	^ self tag last! !!SmaCCParserSimulationError methodsFor: 'accessing'!simulator	^ self tag first! !SmaCCGrammarCompiler subclass: #SmaCCParserSimulator	instanceVariableNames: 'parserStates currentParserState currentToken scannerSimulator lastToken lastState nextScannerState'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Simulation'!!SmaCCParserSimulator methodsFor: 'setup'!setupFor: productionName	self createInitialItemSetFor: (grammar symbolNamed: productionName)! !!SmaCCParserSimulator methodsFor: 'parsing'!isAccepted	^ parserStates allSatisfy: [ :each | each isAccepted ]! !!SmaCCParserSimulator methodsFor: 'parsing'!simulateParse: aString	"Returns all possible interpretations of the parse"	scannerSimulator on: aString readStream.	self resetParser.	[ parserStates size to: 1 by: -1 do: [ :i | 		self restoreState: (parserStates at: i).		self getNextToken.		self processToken ].	self isAccepted ] whileFalse.	^ parserStates collect: [ :each | each nodeStack first ]! !!SmaCCParserSimulator methodsFor: 'parsing support'!popItems: anInteger	| items |	items := OrderedCollection new: anInteger.	anInteger		timesRepeat: [ items addFirst: currentParserState nodeStack removeLast.			currentParserState stateStack removeLast ].	^ items! !!SmaCCParserSimulator methodsFor: 'parsing support'!parserStateId	^ currentParserState stateStack last! !!SmaCCParserSimulator methodsFor: 'parsing support'!pushObject: anObject andState: anInteger	currentParserState stateStack add: anInteger.	currentParserState nodeStack add: anObject! !!SmaCCParserSimulator methodsFor: 'parsing support'!accept	currentParserState markAccepted! !!SmaCCParserSimulator methodsFor: 'parsing support'!signalErrorFrom: aSmaCCToken	SmaCCParserSimulationError		signal: 'Cannot parse input'		withTag:			{self.			aSmaCCToken}! !!SmaCCParserSimulator methodsFor: 'parsing support'!killStateFrom: aSmaCCToken	| index |	index := parserStates identityIndexOf: currentParserState.	parserStates size > 1		ifTrue: [ parserStates removeAt: index.			currentParserState := parserStates				at: (index min: parserStates size) ]		ifFalse: [ self signalErrorFrom: aSmaCCToken ]! !!SmaCCParserSimulator methodsFor: 'parsing support'!processedToken	currentToken := nil! !!SmaCCParserSimulator methodsFor: 'parsing support'!restoreState: aParserState andToken: aSmaCCToken	currentParserState := aParserState.	currentToken := aSmaCCToken! !!SmaCCParserSimulator methodsFor: 'parsing support'!restoreState: aParserState	currentParserState := aParserState.	scannerSimulator restoreState: currentParserState scannerState! !!SmaCCParserSimulator methodsFor: 'parsing support'!duplicateState	parserStates		add:			(currentParserState := SmaCCParserState				stateStack: currentParserState stateStack copy				nodeStack: currentParserState nodeStack copy				scannerState: currentParserState scannerState copy)! !!SmaCCParserSimulator methodsFor: 'parsing support'!currentParserState	^ currentParserState! !!SmaCCParserSimulator methodsFor: 'initialize-release'!buildDefinition: aString	super buildDefinition: aString.	scannerSimulator := SmaCCScannerSimulator		forGrammar: grammar		nfa: scannerCompiler createFullRegex asNFA! !!SmaCCParserSimulator methodsFor: 'private'!getNextToken	currentToken isNil		ifFalse: [ ^ self ].	lastState = currentParserState scannerState		ifTrue: [ currentToken := lastToken.			scannerSimulator restoreState: nextScannerState.			currentParserState scannerState: nextScannerState ]		ifFalse: [ lastState := currentParserState scannerState.			scannerSimulator restoreState: currentParserState scannerState.			lastToken := currentToken := scannerSimulator next.			nextScannerState := scannerSimulator currentState ].	currentParserState scannerState: nextScannerState! !!SmaCCParserSimulator methodsFor: 'private'!resetParser	lastState := nil.	currentToken := nil.	parserStates := OrderedCollection		with:			(currentParserState := SmaCCParserState				stateStack: (OrderedCollection with: 1)				nodeStack: OrderedCollection new				scannerState: (SmaCCScannerState position: 0 scope: #default))! !!SmaCCParserSimulator methodsFor: 'private'!symbolForId: id	^ grammar symbols at: id! !!SmaCCParserSimulator methodsFor: 'private'!processToken	| action state symbol itemSet |	[ currentToken notNil ]		whileTrue: [ state := currentParserState stateStack last.			currentToken ids				do: [ :id | 					id > 0						ifTrue: [ self moveOn: (self symbolForId: id) from: state ] ].			currentToken isSyntaxError				ifTrue: [ action := SmaCCRejectAction new ]				ifFalse: [ symbol := grammar symbols at: currentToken ids first.					itemSet := itemSets at: state.					action := itemSet isEmpty						ifTrue: [ SmaCCRejectAction new ]						ifFalse:							[ itemSet action: symbol prefer: (grammar preferredActionFor: symbol) ] ].			action simulateOn: self token: currentToken ]! !!SmaCCParserSimulator methodsFor: 'private-item sets'!moveOn: smaccSymbol from: state	^ shiftTable		at: (self shiftTableKeyForIndex: state symbol: smaccSymbol)		ifAbsentPut: [ self indexOfState: ((itemSets at: state) moveOn: smaccSymbol) ]! !!SmaCCParserSimulator methodsFor: 'private-item sets'!createInitialItemSetFor: smaccSymbol	| start |	startingStateMap := Dictionary new.	grammar calculateFirstSets.	start := grammar createStartingSymbolFor: smaccSymbol.	itemSets := OrderedCollection new.	itemSets add: (grammar initialItemSetFor: start).	startingStateMap at: start put: itemSets size.	shiftTable := Dictionary new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserSimulator class	instanceVariableNames: ''!!SmaCCParserSimulator class methodsFor: 'examples'!csharpIncompleteIfStatement	<gtExample>	| simulator |	(Smalltalk includesKey: #CSharpParser)		ifFalse: [ ^ nil ].	simulator := SmaCCParserSimulator		on: #CSharpParser asClass definitionString.	simulator setupFor: 'if_statement'.	[ simulator simulateParse: 'if (a == 2' ]		on: SmaCCParserSimulationError		do: [ :ex | 			self assert: ex isInputIncomplete.			^ ex ].	self error: 'Shouldn''t get here'! !!SmaCCParserSimulator class methodsFor: 'examples'!csharpInvalidToken	<gtExample>	| simulator |	(Smalltalk includesKey: #CSharpParser)		ifFalse: [ ^ nil ].	simulator := SmaCCParserSimulator		on: #CSharpParser asClass definitionString.	simulator setupFor: 'if_statement'.	[ simulator simulateParse: 'if (''' ]		on: SmaCCParserSimulationError		do: [ :ex | 			self assert: ex token isSyntaxError.			^ ex ].	self error: 'Shouldn''t get here'! !!SmaCCParserSimulator class methodsFor: 'examples'!csharpIfStatement	<gtExample>	| simulator result |	(Smalltalk includesKey: #CSharpParser)		ifFalse: [ ^ nil ].	simulator := SmaCCParserSimulator		on: #CSharpParser asClass definitionString.	simulator setupFor: 'if_statement'.	result := (simulator simulateParse: 'if (a == 2) return 4;') first.	self assert: result rhs productionSymbol name = 'if_statement'.	self assert: result items first source = 'if'.	self assert: result items second source = '('.	self assert: result items third class = SmaCCReducedItem.	self assert: result items fourth source = ')'.	self assert: result items last class = SmaCCReducedItem.	^ result! !!SmaCCParserSimulator class methodsFor: 'examples'!csharpInvalidInput	<gtExample>	| simulator |	(Smalltalk includesKey: #CSharpParser)		ifFalse: [ ^ nil ].	simulator := SmaCCParserSimulator		on: #CSharpParser asClass definitionString.	simulator setupFor: 'if_statement'.	[ simulator simulateParse: 'if (if = 3) return 3;' ]		on: SmaCCParserSimulationError		do: [ :ex | 			self assert: ex token source = 'if'.			self assert: ex token startPosition = 5.			^ ex ].	self error: 'Shouldn''t get here'! !!SmaCCParserSimulator class methodsFor: 'examples'!javaAmbiguousActions	<gtExample>	| simulator items |	(Smalltalk includesKey: #JavaParser)		ifFalse: [ ^ nil ].	simulator := SmaCCParserSimulator		on: #JavaParser asClass definitionString.	simulator setupFor: 'expression'.	items := simulator simulateParse: 'a(b)'.	self assert: items size = 1.	^ items first! !!SmaCCParserSimulator class methodsFor: 'instance creation'!on: aString	^ self new		buildDefinition: aString;		yourself! !Object subclass: #SmaCCReducedItem	instanceVariableNames: 'rhs items'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Simulation'!!SmaCCReducedItem methodsFor: 'accessing'!sourceInterval	^ self startPosition		ifNil: [ nil ]		ifNotNil: [ :pos | pos to: self stopPosition ]! !!SmaCCReducedItem methodsFor: 'accessing'!items: anObject	items := anObject! !!SmaCCReducedItem methodsFor: 'accessing'!rhs: anObject	rhs := anObject! !!SmaCCReducedItem methodsFor: 'accessing'!rhs	^ rhs! !!SmaCCReducedItem methodsFor: 'accessing'!stopPosition	items		reverseDo: [ :each | each stopPosition ifNotNil: [ :int | ^ int ] ].	^ nil! !!SmaCCReducedItem methodsFor: 'accessing'!items	^ items! !!SmaCCReducedItem methodsFor: 'accessing'!startPosition	items do: [ :each | each startPosition ifNotNil: [ :int | ^ int ] ].	^ nil! !!SmaCCReducedItem methodsFor: 'printing'!printOn: aStream	| first |	first := true.	aStream nextPut: $(.	aStream		nextPutAll: rhs productionSymbol name;		nextPutAll: ' : '.	rhs collection		with: items		do: [ :symbol :value | 			first				ifFalse: [ aStream space ].			first := false.			aStream				nextPutAll: symbol name;				nextPutAll: ' = ';				print: value ].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReducedItem class	instanceVariableNames: ''!!SmaCCReducedItem class methodsFor: 'instance creation'!reduced: aRhs with: aCollection	^ self new		rhs: aRhs;		items: aCollection;		yourself! !Object subclass: #SmaCCRegexSimulator	instanceVariableNames: 'grammar nfa actionMap'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Simulation'!!SmaCCRegexSimulator methodsFor: 'running'!matchesOn: aString do: aBlock	| states |	states := self expandEpsilonAndSymbolTransitions: (IdentitySet with: nfa).	aBlock value: 0 value: (self matchedNodesFrom: states).	1 to: aString size do: [ :i | 		states := self moveFrom: states on: (aString at: i).		states isEmpty			ifTrue: [ ^ aBlock value: i value: nil ].		aBlock value: i value: (self matchedNodesFrom: states) ]! !!SmaCCRegexSimulator methodsFor: 'private'!matchedNodesFrom: stateCollection	| indices |	indices := IdentitySet new.	stateCollection do: [ :each | indices addAll: (each action ifNil: [ #() ]) ].	^ indices collect: [ :each | actionMap at: each ]! !!SmaCCRegexSimulator methodsFor: 'private'!mapNodesToActionsFor: aNode	aNode		allNodesDo: [ :each | 			(each isKindOf: SmaCCTokenRegexNode)				ifTrue: [ (aNode topParent tokenNamed: each name value)						ifNotNil: [ :token | self mapNodesToActionsFor: token ] ].			actionMap add: each.			each regularExpression				ifNotNil: [ :re | re action: actionMap size ] ]! !!SmaCCRegexSimulator methodsFor: 'private'!buildErrorNFA	nfa := SmaCCNode new! !!SmaCCRegexSimulator methodsFor: 'private'!moveFrom: stateCollection on: aCharacter	| newStates |	newStates := IdentitySet new.	stateCollection		do: [ :each | 			each transitions				do: [ :edge | 					(edge includes: aCharacter)						ifTrue: [ newStates add: edge to ] ] ].	^ self expandEpsilonAndSymbolTransitions: newStates! !!SmaCCRegexSimulator methodsFor: 'private'!expandEpsilonAndSymbolTransitions: aCollection	| todo |	todo := OrderedCollection withAll: aCollection.	[ todo notEmpty ]		whileTrue: [ todo removeFirst transitions				do: [ :each | 					(each isEpsilonTransition or: [ each isCharacterTransition not ])						ifTrue: [ (aCollection includes: each to)								ifFalse: [ aCollection add: each to.									todo add: each to ] ] ] ].	^ aCollection! !!SmaCCRegexSimulator methodsFor: 'initialize-release'!tokenName: aString	| node regex |	node := grammar tokenNamed: aString.	node isNil		ifTrue: [ ^ self buildErrorNFA ].	actionMap := OrderedCollection new.	[ regex := SmaCCSequenceRENode nodes: {node regularExpression}.	actionMap add: node.	regex action: 1.	self mapNodesToActionsFor: node.	nfa := regex asNFA ]		ensure: [ grammar				withAllNodesDo: [ :each | each removeAttributeNamed: #regularExpression ] ]! !!SmaCCRegexSimulator methodsFor: 'initialize-release'!grammar: aSmaCCGrammarDefinitionNode	grammar := aSmaCCGrammarDefinitionNode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRegexSimulator class	instanceVariableNames: ''!!SmaCCRegexSimulator class methodsFor: 'examples'!example	<gtExample>	^ self on: SmaCCDefinitionParser definitionAST tokenName: '<name>'! !!SmaCCRegexSimulator class methodsFor: 'examples'!matchingExample	<gtExample>	self example		matchesOn: 't_1'		do: [ :i :nodes | self inform: 'Match at: ' , i printString , ' nodes: ' , nodes printString ]! !!SmaCCRegexSimulator class methodsFor: 'instance creation'!on: aSmaCCGrammarDefinitionNode tokenName: aString	^ self new		grammar: aSmaCCGrammarDefinitionNode;		tokenName: aString;		yourself! !SmaCCScanner subclass: #SmaCCScannerSimulator	instanceVariableNames: 'grammar nfa methodMap emptyId errorId'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Simulation'!!SmaCCScannerSimulator methodsFor: 'initialize-release'!nfa: aSmaCCNode	nfa := aSmaCCNode! !!SmaCCScannerSimulator methodsFor: 'initialize-release'!grammar: smaccGrammar	grammar := smaccGrammar.	self buildMethodMap! !!SmaCCScannerSimulator methodsFor: 'private'!reportLastMatch: isError	matchActions isNil		ifTrue: [ isError				ifTrue: [ matchActions := #(0) ] ]		ifFalse: [ (matchActions notEmpty				and: [ methodMap includesKey: matchActions first ])				ifTrue: [ matchActions := methodMap at: matchActions first ] ].	^ self reportLastMatch! !!SmaCCScannerSimulator methodsFor: 'private'!expandStates: aCollection	| todo ids |	todo := aCollection copy.	todo do: [ :each | self expandStates: aCollection from: each ].	ids := Set new.	aCollection		do: [ :each | each action ifNotNil: [ :action | ids addAll: action ] ].	ids notEmpty		ifTrue: [ self recordMatch: ids asSortedCollection asArray ]! !!SmaCCScannerSimulator methodsFor: 'private'!buildMethodMap	methodMap := Dictionary new.	grammar tokens		keysDo: [ :each | 			| selector |			each first = $<				ifTrue: [ selector := (each copyFrom: 2 to: each size - 1) asSymbol.					((SmaCCScanner organization						listAtCategoryNamed: #'default token handling')						includes: selector)						ifTrue: [ methodMap								at: (grammar symbols identityIndexOf: (grammar symbolNamed: each))								put: selector ] ] ]! !!SmaCCScannerSimulator methodsFor: 'private'!expandStates: aCollection from: aSmaCCNode	aSmaCCNode transitions		do: [ :each | 			(each isEpsilonTransition				or: [ each isCharacterTransition not						and: [ each transitionObjects includes: scope ] ])				ifTrue: [ (aCollection includes: each to)						ifFalse: [ aCollection add: each to.							self expandStates: aCollection from: each to ] ] ]! !!SmaCCScannerSimulator methodsFor: 'private'!moveFrom: currentStates	| newStates |	newStates := IdentitySet new.	currentStates		do: [ :each | 			each transitions				do: [ :edge | 					(edge isEpsilonTransition not						and: [ edge isCharacterTransition								and: [ edge transitionObjects includes: currentCharacter ] ])						ifTrue: [ newStates add: edge to ] ] ].	^ newStates! !!SmaCCScannerSimulator methodsFor: 'accessing'!scanForToken	| currentStates |	currentStates := IdentitySet with: nfa.	[ self expandStates: currentStates.	currentStates notEmpty and: [ stream atEnd not ] ]		whileTrue: [ self step.			currentStates := self moveFrom: currentStates ].	^ self reportLastMatch: currentStates isEmpty! !!SmaCCScannerSimulator methodsFor: 'accessing'!emptySymbolTokenId	^ emptyId		ifNil: [ emptyId := grammar symbols identityIndexOf: grammar emptySymbol ]! !!SmaCCScannerSimulator methodsFor: 'accessing'!errorTokenId	^ errorId		ifNil: [ errorId := grammar symbols identityIndexOf: grammar errorSymbol ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCScannerSimulator class	instanceVariableNames: ''!!SmaCCScannerSimulator class methodsFor: 'instance creation'!forGrammar: aSmaCCGrammar nfa: aSmaCCNode	^ self new		grammar: aSmaCCGrammar;		nfa: aSmaCCNode;		yourself! !Object subclass: #SmaCCDebugMatchResult	instanceVariableNames: 'patternNode matchedNodes matched children parent'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Pattern Matching'!!SmaCCDebugMatchResult methodsFor: 'initialize-release'!initialize	super initialize.	children := OrderedCollection new.	matchedNodes := #().	matched := nil! !!SmaCCDebugMatchResult methodsFor: 'accessing'!children	^ children! !!SmaCCDebugMatchResult methodsFor: 'accessing'!children: anObject	children := anObject! !!SmaCCDebugMatchResult methodsFor: 'accessing'!parent: anObject	parent := anObject! !!SmaCCDebugMatchResult methodsFor: 'accessing'!parent	^ parent! !!SmaCCDebugMatchResult methodsFor: 'accessing'!nodes	^ matchedNodes collect: [ :each | each node ]! !!SmaCCDebugMatchResult methodsFor: 'accessing'!patternNode: anObject	patternNode := anObject! !!SmaCCDebugMatchResult methodsFor: 'accessing'!matched	^ matched! !!SmaCCDebugMatchResult methodsFor: 'accessing'!matchedNodes	^ matchedNodes! !!SmaCCDebugMatchResult methodsFor: 'accessing'!patternNode	^ patternNode! !!SmaCCDebugMatchResult methodsFor: 'accessing'!nodes: aCollection	matchedNodes := aCollection collect: [ :each | SmaCCDebugMatchedNode forResult: self andNode: each ]! !!SmaCCDebugMatchResult methodsFor: 'accessing'!matched: aBoolean	matched := aBoolean! !!SmaCCDebugMatchResult methodsFor: 'processing'!processMatchFor: pattern and: anAstNode result: aBoolean	(self findResultFor: pattern)		nodes:			(anAstNode isCollection				ifTrue: [ anAstNode ]				ifFalse: [ Array with: anAstNode ]);		matched: aBoolean! !!SmaCCDebugMatchResult methodsFor: 'private'!createResultFor: anObject	| found search |	(patternNode isKindOf: SmaCCToken)		ifTrue: [ ^ nil ].	found := false.	search := [ :each | found := found or: [ each == anObject ] ].	patternNode nodesDo: search andTokensDo: search.	found		ifTrue: [ ^ children				add:					((self class forPattern: anObject)						parent: self;						yourself) ].	patternNode		nodesDo: [ :each | 			(self doesNode: each contain: anObject)				ifTrue: [ | result |					result := self class forPattern: each.					result parent: self.					children add: result.					^ result createResultFor: anObject ] ].	^ nil! !!SmaCCDebugMatchResult methodsFor: 'private'!doesNode: aNode contain: anObject	aNode		allNodesDo: [ :each | 			each == anObject				ifTrue: [ ^ true ] ]		andTokensDo: [ :each | 			each == anObject				ifTrue: [ ^ true ] ].	^ false! !!SmaCCDebugMatchResult methodsFor: 'private'!findResultFor: anObject	patternNode == anObject		ifTrue: [ ^ self ].	1 to: children size do: [ :i | 		| result |		result := (children at: i) findResultFor: anObject.		result notNil			ifTrue: [ [ children size > i ] whileTrue: [ children removeLast ].				^ result ] ].	^ self createResultFor: anObject! !!SmaCCDebugMatchResult methodsFor: 'inspector'!patternChildFor: aNode	^ children		detect: [ :each | each patternNode == aNode ]		ifNone: [ self class new				parent: self;				patternNode: aNode;				yourself ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!formatText: text matched: isMatched	isMatched isNil		ifTrue: [ text addAttribute: (TextColor new color: Color lightGray) ]		ifFalse: [ isMatched				ifFalse: [ text						addAttribute: (TextColor new color: Color red);						allBold ] ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!nodeChildFor: aNode	^ (children		detect: [ :each | each nodes identityIncludes: aNode ]		ifNone: [ self class new				parent: self;				nodes: {aNode};				yourself ]) matchedNodes detect: [ :each | each node == aNode ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!patternLabelFor: each	| text |	text := (each parent isNil		ifTrue: [ 'self' ]		ifFalse: [ each parent patternNode debugLabelForChild: each patternNode ]) asText.	self formatText: text matched: each matched.	^ text! !!SmaCCDebugMatchResult methodsFor: 'inspector'!allNodeChildren	| allChildren |	children isEmpty		ifTrue: [ ^ #() ].	allChildren := OrderedCollection new.	matchedNodes		do: [ :node | 			node node				nodesDo: [ :each | allChildren add: (self nodeChildFor: each) ]				andTokensDo: [ :each | allChildren add: (self nodeChildFor: each) ] ].	^ allChildren asSortedCollection: [ :a :b | a node startPosition < b node startPosition ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!nodeLabelFor: each	| text |	text := (each matchResult parent isNil		ifTrue: [ 'aNode' ]		ifFalse: [ each matchResult parent nodeLabelForChild: each node ]) asText.	self formatText: text matched: each matchResult matched.	^ text! !!SmaCCDebugMatchResult methodsFor: 'inspector'!allPatternChildren	| allChildren |	children isEmpty		ifTrue: [ ^ #() ].	allChildren := OrderedCollection new.	patternNode		nodesDo: [ :each | allChildren add: (self patternChildFor: each) ]		andTokensDo: [ :each | allChildren add: (self patternChildFor: each) ].	^ allChildren asSortedCollection: [ :a :b | a patternNode startPosition < b patternNode startPosition ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!gtInspectorIn: aComposite	<gtInspectorPresentationOrder: 1>	| tabulator |	tabulator := aComposite tabulator.	tabulator		title: 'Pattern matching';		column: [ :c | 			c				row: #patternTree;				row: #patternSource ];		column: [ :c | 			c				row: #nodeTree;				row: #nodeSource ].	tabulator transmit		to: #patternTree;		andShow: [ :p | 			p fastTreeTable				title: 'Pattern';				display: [ Array with: self ];				children: [ :each | each allPatternChildren ];				allExpanded;				column: 'Variable'					evaluated: [ :each | self patternLabelFor: each ];				column: 'Type'					evaluated: [ :each | '' ]					tags: [ :each | {each patternNode class name} ] ].	tabulator transmit		to: #patternSource;		andShow:				[ :p | p text display: [ patternNode topParent completeSource ifNil: [ '' ] ] ].	tabulator transmit		from: #patternTree port: #selection;		to: #patternSource port: #selectionInterval;		transformation: [ :e | 			e isNil				ifTrue: [ 1 to: 0 ]				ifFalse: [ e patternNode sourceInterval ] ].	tabulator transmit		to: #nodeTree;		andShow: [ :p | 			p fastTreeTable				beMultiple;				title: 'AST';				display: [ matchedNodes ];				children: [ :each | each matchResult allNodeChildren ];				allExpanded;				column: 'Variable' evaluated: [ :each | self nodeLabelFor: each ];				column: 'Type'					evaluated: [ :each | '' ]					tags: [ :each | {each node class name} ] ].	tabulator transmit		to: #nodeSource;		andShow: [ :p | 			p text				display: [ matchedNodes isEmpty						ifTrue: [ '' ]						ifFalse: [ matchedNodes first node topParent completeSource ifNil: [ '' ] ] ] ].	tabulator transmit		from: #patternTree port: #selection;		to: #nodeTree port: #selection;		transformation: [ :e | 			e isNil				ifTrue: [ #() ]				ifFalse: [ e matchedNodes ] ].	tabulator transmit		from: #nodeTree port: #selection;		to: #nodeSource port: #selectionInterval;		transformation: [ :e | 			| start end |			start := SmallInteger maxVal.			end := 0.			e				do: [ :each | 					start := start min: each node startPosition.					end := end max: each node stopPosition ].			start = SmallInteger maxVal				ifTrue: [ start := 1 ].			start to: end ]! !!SmaCCDebugMatchResult methodsFor: 'inspector'!nodeLabelForChild: aNode	^ (self nodes		detect: [ :node | 			| found |			found := false.			node nodesDo: [ :each | found := found or: [ each == aNode ] ] andTokensDo: [ :each | found := found or: [ each == aNode ] ].			found ]) debugLabelForChild: aNode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDebugMatchResult class	instanceVariableNames: ''!!SmaCCDebugMatchResult class methodsFor: 'examples'!exampleFailure	<gtExample>	| jsParser result |	jsParser := Smalltalk at: #JSParser ifAbsent: [ ^ nil ].	result := (jsParser parse: '`?a` + `?a` + `?a`' startingAt: jsParser startingStateForExpression)		debugMatch: (jsParser parse: '2 + 2 + 3' startingAt: jsParser startingStateForExpression).	self assert: result matched not.	^ result! !!SmaCCDebugMatchResult class methodsFor: 'examples'!exampleSuccess	<gtExample>	| jsParser result |	jsParser := Smalltalk at: #JSParser ifAbsent: [ ^ nil ].	result := (jsParser parse: 'f(`?a{beList}`,1,`?b{beList}`,4,`?c{beList}`)' startingAt: jsParser startingStateForExpression)		debugMatch: (jsParser parse: 'f(0,1,2,3,4)' startingAt: jsParser startingStateForExpression).	self assert: result matched.	^ result! !!SmaCCDebugMatchResult class methodsFor: 'instance creation'!forPattern: patternNode	^ self new		patternNode: patternNode;		yourself! !Object subclass: #SmaCCDebugMatchedNode	instanceVariableNames: 'matchResult node'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Pattern Matching'!!SmaCCDebugMatchedNode methodsFor: 'accessing'!matchResult	^ matchResult! !!SmaCCDebugMatchedNode methodsFor: 'accessing'!node: anObject	node := anObject! !!SmaCCDebugMatchedNode methodsFor: 'accessing'!matchResult: anObject	matchResult := anObject! !!SmaCCDebugMatchedNode methodsFor: 'accessing'!node	^ node! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDebugMatchedNode class	instanceVariableNames: ''!!SmaCCDebugMatchedNode class methodsFor: 'instance creation'!forResult: matchResult andNode: aNode	^ self new		matchResult: matchResult;		node: aNode;		yourself! !DebugAction subclass: #SmaCCDebuggingAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCDebuggingAction methodsFor: 'private'!stepUntil: aBlock context: rootContext	| context process previousContext |	process := self session process.	context := self currentContext.	(process suspendedContext findContextSuchThat: [ :c | c == context ]) ifNil: [ ^ self ].	previousContext := nil.	[ context notNil and: [ process isTerminating not and: [ process isTerminated not and: [ process suspendedContext notNil and: [ aBlock value: context ] ] ] ] ]		whileFalse: [ previousContext == context				ifFalse: [ (context findContextSuchThat: [ :c | c == rootContext ]) isNil						ifTrue: [ ^ self session updateContextTo: context ].					previousContext := context ].			context := process step: context ].	self session updateContextTo: context! !!SmaCCDebuggingAction methodsFor: 'private'!stepUntil: aBlock	self stepUntil: aBlock context: self session rootContext! !!SmaCCDebuggingAction methodsFor: 'testing'!appliesToContext: aContext	^ self session isActive! !!SmaCCDebuggingAction methodsFor: 'accessing'!help	^ ''! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDebuggingAction class	instanceVariableNames: 'icon'!DebugSession subclass: #SmaCCParserDebugSession	instanceVariableNames: 'rootContext'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCParserDebugSession methodsFor: 'private'!inputSelectionInterval	| context receiver |	context := self context		findContextSuchThat: [ :each | 			(each receiver isKindOf: SmaCCScanner)				or: [ each receiver isKindOf: SmaCCParser ] ].	context isNil		ifTrue: [ ^ 1 to: 0 ].	receiver := context receiver.	^ (receiver isKindOf: SmaCCParser)		ifTrue: [ (receiver currentToken isNil				or: [ receiver currentToken startPosition isNil ])				ifTrue: [ self scanner position + 1 to: self scanner position ]				ifFalse: [ receiver currentToken sourceInterval ] ]		ifFalse: [ self scanner debugStart + 1 to: self scanner position ]! !!SmaCCParserDebugSession methodsFor: 'private'!parserStack	| states nodes items context reduceContext |	states := self parser stateStack.	nodes := self parser nodeStack.	items := OrderedCollection new.	1 to: states size - 1 do: [ :i | 		items			addFirst:				(Array					with: (self parser symbolForTransitionFrom: (states at: i) to: (states at: i + 1))					with: (nodes at: i)) ].	context := self context		findContextSuchThat: [ :each | 			(each receiver isKindOf: SmaCCParser)				and: [ each selector = #performReduceEntry:with: ] ].	context notNil		ifTrue: [ items add: #('' '').			reduceContext := context				findContextSuchThat: [ :each | 					(each receiver isKindOf: SmaCCParser)						and: [ each selector = #reduce: ] ].			items addFirst: #('' '').			(context tempAt: 2) size to: 1 by: -1 do: [ :i | 				items					addFirst:						(Array							with: 'nodes at: ' , i printString							with: ((context tempAt: 2) at: i)) ].			items				addFirst:					(Array						with: 'Reducing:'						with:							(self parser								symbolNameFor:									(reduceContext receiver reduceTable at: (reduceContext tempAt: 1))										first)) ].	self parser currentToken		ifNotNil: [ :token | 			| stream |			stream := WriteStream on: String new.			token ids				do: [ :each | stream nextPutAll: (self parser symbolNameFor: each) ]				separatedBy: [ stream nextPut: $; ].			items				addFirst: #('' '');				addFirst: (Array with: stream contents with: token);				addFirst: (Array with: 'Lookahead:' with: '') ].	^ items! !!SmaCCParserDebugSession methodsFor: 'private'!glrParserStates	| states |	states := self parser states.	^ states isEmpty		ifTrue: [ Array with: self parser currentGLRState ]		ifFalse: [ states ]! !!SmaCCParserDebugSession methodsFor: 'accessing'!parser	^ self rootContext ifNotNil: [ :context | context receiver ]! !!SmaCCParserDebugSession methodsFor: 'accessing'!rootContext	^ rootContext		ifNil:			[ rootContext := interruptedContext				findContextSuchThat: [ :each | each selector = #parse and: [ each receiver isKindOf: SmaCCParser ] ] ]! !!SmaCCParserDebugSession methodsFor: 'accessing'!inputText	^ self scanner debugSource! !!SmaCCParserDebugSession methodsFor: 'accessing'!scanner	^ self parser scanner! !!SmaCCParserDebugSession methodsFor: 'accessing'!tokenIntervalFor: anObject	(anObject isKindOf: SequenceableCollection)		ifTrue: [ | interval |			anObject				do: [ :each | 					| newInterval |					newInterval := self tokenIntervalFor: each.					interval isNil						ifTrue: [ interval := newInterval ]						ifFalse: [ newInterval notNil								ifTrue:									[ interval := (interval first min: newInterval first) to: (interval last max: newInterval last) ] ] ].			^ interval ].	(anObject isKindOf: SmaCCToken)		ifTrue: [ (anObject startPosition notNil and: [ anObject startPosition > 0 ])				ifTrue: [ ^ anObject sourceInterval ] ].	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ | start end tokens |			start := SmallInteger maxVal.			end := 0.			tokens := OrderedCollection new.			anObject allTokensInto: tokens.			tokens				do: [ :each | 					(each startPosition notNil and: [ each startPosition > 0 ])						ifTrue: [ start := start min: each startPosition.							end := end max: each stopPosition ] ].			start <= end				ifTrue: [ ^ start to: end ] ].	(anObject isKindOf: SmaCCDeferredReduceAction)		ifTrue: [ ^ self tokenIntervalFor: anObject arguments ].	(anObject isKindOf: SmaCCDeferredChoice)		ifTrue: [ ^ self tokenIntervalFor: anObject possibleItems first ].	^ nil! !!SmaCCParserDebugSession methodsFor: 'testing'!isInsideReductionAction	self context		findContextSuchThat: [ :each | 			((each receiver isKindOf: SmaCCParser)				and: [ each selector beginsWith: 'reduceActionFor' ])				ifTrue: [ ^ true ].			each == rootContext ].	^ false! !!SmaCCParserDebugSession methodsFor: 'testing'!isScanning	^ self isScanning: self context! !!SmaCCParserDebugSession methodsFor: 'testing'!isScanning: aContext	aContext		findContextSuchThat: [ :each | 			(each receiver isKindOf: SmaCCScanner)				ifTrue: [ ^ true ].			each == rootContext ].	^ false! !!SmaCCParserDebugSession methodsFor: 'testing'!isActive	^ rootContext notNil and: [ rootContext isDead not and: [ rootContext ~= self process suspendedContext or: [ rootContext willReturn not ] ] ]! !!SmaCCParserDebugSession methodsFor: 'building'!actionLabelFor: anInteger	| type parser |	parser := self parser.	type := anInteger bitAnd: parser actionMask.	type = parser acceptAction		ifTrue: [ ^ 'Accept' ].	type = parser shiftAction		ifTrue: [ ^ 'Shift' ].	type = parser reduceAction		ifTrue: [ ^ self reduceActionName: (anInteger bitShift: -2) ].	^ 'Multiple'! !!SmaCCParserDebugSession methodsFor: 'building'!potentialStateActions	| items ids |	ids := self parser currentToken		ifNotNil: [ :token | token ids ]		ifNil: [ #() ].	items := OrderedCollection new.	self parser		actionsAndSymbolsForState: self parser stateStack last		do: [ :action :symbol | 			items				add:					(Array						with: (self parser symbolNameFor: symbol)						with: (self actionLabelFor: action)						with: ((ids includes: symbol) or: [ self parser currentToken isNil ])						with: symbol) ].	^ items		asSortedCollection: [ :a :b | 			a third = b third				ifTrue: [ a last < b last ]				ifFalse: [ a third ] ]! !!SmaCCParserDebugSession methodsFor: 'building'!reduceActionName: anInteger	| entry |	entry := self parser reduceTable at: anInteger.	^ 'Reduce(' , (entry at: 2) printString , ') as '		, (self parser symbolNameFor: entry first)! !!SmaCCParserDebugSession methodsFor: 'building'!scannerProperties	| items scanner string |	scanner := self scanner.	items := OrderedCollection new.	string := scanner outputStream		ifNil: [ '' ]		ifNotNil: [ :stream | stream contents ].	items add: (Array with: 'Scope' with: scanner scope).	self isScanning		ifTrue: [ items				add: (Array with: 'Current Character' with: scanner currentCharacter);				add: (Array with: 'Start Index' with: scanner debugStart).			string isEmpty				ifFalse: [ items						add: (Array with: 'Scan String' with: string);						add:							(Array								with: 'Match String'								with: (string copyFrom: 1 to: scanner lastOutputStreamMatchPosition));						add:							(Array								with: 'Match Type'								with:									(scanner matchActions										ifNil: [ '' ]										ifNotNil: [ :symbols | 											| stream |											stream := WriteStream on: String new.											symbols												do: [ :each | stream nextPutAll: (self parser symbolNameFor: each) ]												separatedBy: [ stream space ].											stream contents ])) ] ]		ifFalse: [ items add: (Array with: 'Position' with: scanner position) ].	^ items! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserDebugSession class	instanceVariableNames: 'maxSearchDepth'!!SmaCCParserDebugSession class methodsFor: 'testing'!isParseContext: each	^ each selector = #parse and: [ each receiver isKindOf: SmaCCParser ]! !!SmaCCParserDebugSession class methodsFor: 'testing'!handlesContext: aContext	| max count |	max := self maxSearchDepth.	count := 1.	^ (aContext		findContextSuchThat: [ :each | 			count := count + 1.			count > max				ifTrue: [ ^ false ].			self isParseContext: each ]) notNil! !!SmaCCParserDebugSession class methodsFor: 'private'!maxSearchDepth	^ maxSearchDepth ifNil: [ 500 ]! !!SmaCCParserDebugSession class methodsFor: 'private'!maxSearchDepth: anInteger	maxSearchDepth := anInteger! !GTGenericStackDebugger subclass: #SmaCCParserDebugger	instanceVariableNames: 'isGLR'	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCParserDebugger methodsFor: 'accessing'!isGLR	^ isGLR ifNil: [ false ]! !!SmaCCParserDebugger methodsFor: 'accessing'!isGLR: aBoolean	isGLR := aBoolean! !!SmaCCParserDebugger methodsFor: 'building'!buildInputIn: browser	browser transmit		fromOutsideEntityPort;		to: #input;		andShowIfNone: [ :composite | 			| text |			text := composite text.			text				title: 'Input';				display: [ self session inputText ];				withLineNumbers: true.			text with: [ :c | self installActionsForRootPragmas: #(#SmaCCDebuggingInputAction) in: c ] ].	browser transmit		from: #stack port: #selection;		to: #input port: #selectionInterval;		transformed: [ :each | self session inputSelectionInterval ].	browser transmit		from: #stackState port: #selection;		to: #input port: #selectionInterval;		transformed: [ :each | 			each notNil				ifTrue: [ (self session tokenIntervalFor: each last) ifNil: [ self session inputSelectionInterval ] ] ]! !!SmaCCParserDebugger methodsFor: 'building'!debuggerTransmissionsIn: browser	super debuggerTransmissionsIn: browser.	self buildGLRTransmissionsIn: browser.	self buildStackStateIn: browser.	self buildPotentialTokensIn: browser.	self buildScannerStateIn: browser.	self buildInputIn: browser! !!SmaCCParserDebugger methodsFor: 'building'!buildStackStateIn: browser	browser transmit		from: #stack port: #selection;		to: #stackState;		transformed: [ :context | self session parserStack ];		andShow: [ :composite | 			composite table				title: 'Parser Stack';				column: 'Symbol' evaluated: [ :each | each first ];				column: 'Value' evaluated: [ :each | each last ];				morphicSelectionAct: [ :list | list selection last inspect ]					icon: GLMUIThemeExtraIcons glamorousInspect					on: $i					entitled: 'Inspect';				with: [ :c | 					self						installActionsForRootPragmas: #(#SmaCCDebuggingParserAction)						in: c ] ]! !!SmaCCParserDebugger methodsFor: 'building'!buildPotentialTokensIn: browser	browser transmit		from: #stack port: #selection;		to: #potential;		transformed: [ :context | self session potentialStateActions ];		andShow: [ :composite | 			composite table				title: 'Possible Actions';				column: 'Symbol'					evaluated: [ :each | 					each third						ifTrue: [ each first asText allBold ]						ifFalse: [ each first asText makeAllColor: Color red ] ];				column: 'Action'					evaluated: [ :each | 					each third						ifTrue: [ each second asText allBold ]						ifFalse: [ each second asText makeAllColor: Color red ] ] ]! !!SmaCCParserDebugger methodsFor: 'building'!debuggerStructureIn: browser	browser		row: [ :row | 			row				column: #stackState span: 6;				column: #potential span: 6.			self isGLR				ifTrue: [ row column: #glrStates ] ].	browser		row: [ :row | 			row				column: #input span: 2;				column: #scannerState ];		row: [ :row | 			row				column: #stack;				column: #code ];		row: #inspector span: 0! !!SmaCCParserDebugger methodsFor: 'building'!buildScannerStateIn: browser	browser transmit		from: #stack port: #selection;		to: #scannerState;		transformed: [ :context | self session scannerProperties ];		andShow:				[ :composite | 			composite table				title: 'Scanner';				column: 'Name' evaluated: [ :each | each first ];				column: 'Value' evaluated: [ :each | each last ];				with: [ :c | self installActionsForRootPragmas: #(#SmaCCDebuggingScannerAction) in: c ] ]! !!SmaCCParserDebugger methodsFor: 'building'!buildGLRTransmissionsIn: browser	self isGLR		ifTrue:			[ browser transmit				from: #stack port: #selection;				to: #glrStates;				transformed: [ :context | self session glrParserStates ];				andShow:						[ :composite | 					composite table						title: 'GLR';						format:								[ :each | (self session parser states identityIndexOf: each) printString ] ] ]! !!SmaCCParserDebugger methodsFor: 'private'!currentInputSelectionInterval	^ self selectionIntervalForPane: #input! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserDebugger class	instanceVariableNames: 'availableAutomatically'!!SmaCCParserDebugger class methodsFor: 'tools registry'!registerToolsOn: aRegistry	aRegistry registerDebugger: self withRank: 60! !!SmaCCParserDebugger class methodsFor: 'tools registry'!register	self registerToolsOn: Smalltalk tools! !!SmaCCParserDebugger class methodsFor: 'testing'!handlesContext: aContext	^ SmaCCParserDebugSession handlesContext: aContext! !!SmaCCParserDebugger class methodsFor: 'accessing'!sessionClass	^ SmaCCParserDebugSession! !!SmaCCParserDebugger class methodsFor: 'accessing'!availableAutomatically: aBoolean	availableAutomatically := aBoolean! !!SmaCCParserDebugger class methodsFor: 'accessing'!availableAutomatically	^ availableAutomatically ifNil: [ false ]! !!SmaCCParserDebugger class methodsFor: 'accessing'!defaultTitle	^ 'SmaCCParser'! !!SmaCCParserDebugger class methodsFor: 'class initialization'!initialize	self register! !!SmaCCParserDebugger class methodsFor: 'instance creation'!on: aDebugSession	| glrClass |	glrClass := Smalltalk at: #SmaCCGLRParser ifAbsent: [ self ].	^ self basicNew		isGLR: (aDebugSession parser isKindOf: glrClass);		initialize;		session: aDebugSession! !SmaCCDebuggingAction subclass: #SmaCCParserStepAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!SmaCCParserStepAction subclass: #SmaCCParserNextTokenAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCParserNextTokenAction methodsFor: 'accessing'!defaultLabel	^ 'Next Token'! !!SmaCCParserNextTokenAction methodsFor: 'accessing'!defaultOrder	^ 100! !!SmaCCParserNextTokenAction methodsFor: 'accessing'!help	^ 'Run until we get the next token or a parse error is encountered.'! !!SmaCCParserNextTokenAction methodsFor: 'actions'!executeAction	| token |	token := self session parser currentToken.	self stepUntil: [ :context | self session parser currentToken ~~ token and: [ self session parser currentToken notNil ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserNextTokenAction class	instanceVariableNames: ''!!SmaCCParserNextTokenAction class methodsFor: 'accessing'!defaultIcon	^ icon		ifNil: [ icon := Form				extent: 15 @ 10				depth: 32				fromArray:					#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1103019710 66911484 0 1153153979 0 0 0 0 0 0 0 0 0 217314291 2523490665 4261478657 117045753 0 3526176045 3074967624 501408482 0 0 0 0 0 0 1136442556 3760135967 4027518735 1788188053 0 0 1236711094 3726713121 4044230158 1687919515 0 0 0 0 1905168014 4261478657 2774162010 401139944 0 0 0 0 167180022 2239396474 4194632965 2740739164 0 0 0 2256107897 4194632965 2139127936 133757176 0 0 0 0 33488638 1621073823 3977384466 3108390470 0 0 0 0 1637785246 3977384466 3659867429 1169865402 0 0 718656981 3258793277 4177921542 2189262205 133757176 0 0 0 0 0 384428521 2807584856 4278190080 100334330 0 3526176045 3325638969 735368404 0 0 0 0 0 0 0 0 0 1270133940 66911484 0 1286845363 50200061 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)				offset: 0 @ 0 ]! !!SmaCCParserNextTokenAction class methodsFor: 'registration'!gtActionFor: aDebugger	<gtSmaCCDebuggingParserAction>	^ self forDebugger: aDebugger! !SmaCCParserStepAction subclass: #SmaCCParserStepThroughAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCParserStepThroughAction methodsFor: 'accessing'!defaultLabel	^ 'Through Action'! !!SmaCCParserStepThroughAction methodsFor: 'accessing'!defaultOrder	^ 1! !!SmaCCParserStepThroughAction methodsFor: 'accessing'!help	^ 'Run until we perform the next action (shift or reduce) or a parse error is encountered.'! !!SmaCCParserStepThroughAction methodsFor: 'actions'!executeAction	| insidePerform performBlock |	performBlock := [ :context | (context receiver isKindOf: SmaCCParser) and: [ context selector = #performAction: ] ].	insidePerform := (self session context findContextSuchThat: performBlock) notNil.	self		stepUntil: [ :context | 			insidePerform				ifTrue: [ (context findContextSuchThat: performBlock) isNil ]				ifFalse: [ insidePerform := performBlock value: context.					false ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserStepThroughAction class	instanceVariableNames: ''!!SmaCCParserStepThroughAction class methodsFor: 'accessing'!defaultIcon	^ (Smalltalk at: #BrGlamorousIcons ifAbsent: [  ])		ifNil: [ GLMUIThemeExtraIcons glamorousOver ]		ifNotNil: [ :cls | cls over ]! !!SmaCCParserStepThroughAction class methodsFor: 'registration'!gtActionFor: aDebugger	<gtSmaCCDebuggingParserAction>	^ self forDebugger: aDebugger! !SmaCCParserStepAction subclass: #SmaCCParserStepToReduceAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCParserStepToReduceAction methodsFor: 'actions'!executeAction	| selectors |	selectors := self session parser reduceTable		inject: Set new		into: [ :sum :each | 			sum				add: (each at: 3);				yourself ].	self		stepUntil: [ :context | 			(context				findContextSuchThat: [ :each | 					(each receiver isKindOf: SmaCCParser)						and: [ selectors includes: each selector ] ]) notNil ]! !!SmaCCParserStepToReduceAction methodsFor: 'accessing'!defaultLabel	^ 'Into Reduce'! !!SmaCCParserStepToReduceAction methodsFor: 'accessing'!defaultOrder	^ 50! !!SmaCCParserStepToReduceAction methodsFor: 'accessing'!help	^ 'Run until we get to the start of a reduction action or a parse error is encountered.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserStepToReduceAction class	instanceVariableNames: ''!!SmaCCParserStepToReduceAction class methodsFor: 'registration'!gtActionFor: aDebugger	<gtSmaCCDebuggingParserAction>	^ self forDebugger: aDebugger! !!SmaCCParserStepToReduceAction class methodsFor: 'accessing'!defaultIcon	^ (Smalltalk at: #BrGlamorousIcons ifAbsent: [  ])		ifNil: [ GLMUIThemeExtraIcons glamorousInto ]		ifNotNil: [ :cls | cls into ]! !SmaCCDebuggingAction subclass: #SmaCCScannerStepToAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCScannerStepToAction methodsFor: 'accessing'!stepToIndex	^ self subclassResponsibility! !!SmaCCScannerStepToAction methodsFor: 'actions'!stepOutOfStepMethod	| stepContext |	stepContext := self session context		findContextSuchThat:			[ :each | (each receiver isKindOf: SmaCCScanner) and: [ each selector = #step ] ].	stepContext isNil		ifTrue: [ ^ self ].	self stepUntil: [ :context | false ] context: stepContext! !!SmaCCScannerStepToAction methodsFor: 'actions'!executeAction	| scanner toIndex |	toIndex := self stepToIndex.	scanner := self session scanner.	self		stepUntil: [ :context | 			scanner stream position >= toIndex				and: [ self session isScanning: context ] ].	self stepOutOfStepMethod! !SmaCCScannerStepToAction subclass: #SmaCCStepToCursorAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCStepToCursorAction methodsFor: 'accessing'!stepToIndex	^ self debugger currentInputSelectionInterval last! !!SmaCCStepToCursorAction methodsFor: 'accessing'!defaultLabel	^ 'Step to Cursor'! !!SmaCCStepToCursorAction methodsFor: 'accessing'!help	^ 'Run until we get to the cursor position or a parse error is encountered.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCStepToCursorAction class	instanceVariableNames: ''!!SmaCCStepToCursorAction class methodsFor: 'accessing'!defaultIcon	^ icon		ifNil: [ icon := Form				extent: 26 @ 18				depth: 32				fromArray:					#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1437248170 1136442556 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 551542751 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 351005675 66911484 0 0 0 3509464622 4278190080 0 0 0 0 4278190080 0 0 83622907 0 0 33488638 0 0 0 0 0 0 2841007702 4278190080 4278190080 4278190080 4278190080 0 0 3509464622 4278190080 4278190080 4278190080 4261478657 100334330 4278190080 852348365 4278190080 4278190080 4278190080 4278190080 4244767234 0 0 0 0 0 0 0 0 0 317582829 4278190080 0 0 3509464622 4278190080 367717098 33488638 4278190080 4144498696 4278190080 4278190080 4010807312 0 0 3626444583 4228055811 0 0 0 0 0 0 3225370431 4278190080 4261478657 4278190080 4278190080 0 0 3509464622 4278190080 0 0 3242081854 4278190080 4278190080 4278190080 1487382439 0 0 0 0 0 0 0 0 0 0 4278190080 2289530743 0 0 4278190080 0 0 3509464622 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 3743424544 0 0 317582829 1938590860 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 802214096 4278190080 4094364427 4278190080 4278190080 4278190080 835636942 4278190080 1403825324 4278190080 4278190080 4278190080 4278190080 2222685051 0 0 0 0 0 0 0 802214096 451274213 0 0 0 0 0 0 100334330 902482634 0 0 4278190080 0 0 651811289 785502673 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 )				offset: 0 @ 0 ]! !!SmaCCStepToCursorAction class methodsFor: 'registration'!gtActionFor: aDebugger	<gtSmaCCDebuggingInputAction>	^ self forDebugger: aDebugger! !SmaCCDebuggingAction subclass: #SmaCCStepToDebugger	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCStepToDebugger methodsFor: 'accessing'!debuggerClass	^ SmaCCParserDebugger! !!SmaCCStepToDebugger methodsFor: 'accessing'!help	^ 'Execute the current method until it starts to parse something.'! !!SmaCCStepToDebugger methodsFor: 'accessing'!defaultCategory	^ 'Step to debugger'! !!SmaCCStepToDebugger methodsFor: 'accessing'!defaultOrder	^ 200! !!SmaCCStepToDebugger methodsFor: 'accessing'!defaultLabel	^ self debuggerClass defaultTitle! !!SmaCCStepToDebugger methodsFor: 'testing'!appliesToContext: aContext	^ self debugger class ~= self debuggerClass! !!SmaCCStepToDebugger methodsFor: 'actions'!executeAction	self stepUntil: [ :context | self debuggerClass isParseContext: context ] context: self session process suspendedContext.	(self debuggerClass isParseContext: self interruptedContext)		ifTrue: [ self debugger debug: self interruptedContext using: self debuggerClass ]! !!SmaCCStepToDebugger methodsFor: 'initialize-release'!initialize	super initialize.	self needsUpdate: false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCStepToDebugger class	instanceVariableNames: ''!!SmaCCStepToDebugger class methodsFor: 'registration'!gtActionType	<gtDebuggingAction>! !SmaCCScannerStepToAction subclass: #SmaCCStepToNextCharacterAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Debugging_Support-Debugger'!!SmaCCStepToNextCharacterAction methodsFor: 'accessing'!stepToIndex	^ self session scanner stream position + 1! !!SmaCCStepToNextCharacterAction methodsFor: 'accessing'!defaultLabel	^ 'Step Next Character'! !!SmaCCStepToNextCharacterAction methodsFor: 'accessing'!help	^ 'Run until we get to the character or a parse error is encountered.'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCStepToNextCharacterAction class	instanceVariableNames: ''!!SmaCCStepToNextCharacterAction class methodsFor: 'accessing'!defaultIcon	^ icon		ifNil: [ icon := Form				extent: 12 @ 16				depth: 32				fromArray:					#(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 183891445 3526176045 4278190080 2891141971 4077653004 0 4278190080 0 0 0 0 234025714 4278190080 4044230158 1871745168 3843693082 4278190080 250737137 4278190080 0 0 0 0 3242081854 4278190080 0 0 0 3392484661 0 4278190080 0 0 0 0 3409196084 4278190080 0 0 0 0 0 4278190080 0 0 0 0 568254174 4278190080 3643156006 1002751172 3008121932 4278190080 50200061 4278190080 0 0 0 0 0 584965597 4194632965 4278190080 4244767234 1353691055 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 )				offset: 0 @ 0 ]! !!SmaCCStepToNextCharacterAction class methodsFor: 'registration'!gtActionFor: aDebugger	<gtSmaCCDebuggingScannerAction>	^ self forDebugger: aDebugger! !SmaCCParserDebugger initialize!'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.332656 pm'!!SmaCCScanner methodsFor: '*SmaCC_Debugging_Support'!debugSource	| str position |	str := self stream.	(str respondsTo: #position:)		ifFalse: [ ^ '' ].	position := str position.	^ [ str position: 0.	str contents ]		ensure: [ str position: position ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.334656 pm'!!SmaCCToken methodsFor: '*SmaCC_Debugging_Support'!gtInspectorSourceIn: aComposite inContext: aGTInspector	<gtInspectorPresentationOrder: 40>	aComposite text		title: 'Source';		withLineNumbers: true;		when: [ (aGTInspector panes reversed				collect: [ :each | (each port: #entity) value ])				anySatisfy: [ :each | 					(each isKindOf: SmaCCParseNode)						and: [ each topParent completeSource notNil ] ] ];		display: [ ((aGTInspector panes reversed				collect: [ :each | (each port: #entity) value ])				detect: [ :each | each isKindOf: SmaCCParseNode ]) topParent				completeSource ];		initialize: [ :textPresentation | 			self startPosition				ifNotNil: [ textPresentation selectionInterval: self sourceInterval ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.335656 pm'!!SmaCCNode methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	(Smalltalk includesKey: #RTView) not		ifTrue: [ ^ nil ].	composite roassal2		title: 'Graph';		initializeView: [ | nodes view shape elements |			nodes := self allStates.			view := (Smalltalk at: #RTView) new.			shape := ((Smalltalk at: #RTRoundedBox) new				borderRadius: 10;				color: Color white;				borderWidth: [ :n | 					n hasSimpleLoop						ifTrue: [ 2 ]						ifFalse: [ 1 ] ];				borderColor: [ :n | 					n == self						ifTrue: [ Color green ]						ifFalse: [ n action isNil								ifTrue: [ Color red ]								ifFalse: [ n action isEmpty										ifTrue: [ Color lightGray ]										ifFalse: [ Color black ] ] ] ];				yourself)				+					((Smalltalk at: #RTLabel) new						color: Color black;						text: [ :n | 							| label |							label := n id printString , String cr								,									(n action isSymbol										ifTrue: [ n ]										ifFalse: [ (n action ifNotNil: [ :a | a asArray ]) printString ]).							label copyFrom: 1 to: (label size min: 25) ];						yourself).			shape allOfSameSizeWithPadding.			elements := shape elementsOn: nodes.			elements @ (Smalltalk at: #RTDraggable).			view addAll: elements.			(Smalltalk at: #RTEdgeBuilder) new				view: view;				objects: nodes;				label:						[ :from :to | (from transitions detect: [ :each | each to == to ]) edgeLabel ];				shape:					((Smalltalk at: #RTStyledMultiLine) new						color: (Color blue alpha: 0.4);						arrowHead;						attachPoint: (Smalltalk at: #RTShorterDistanceAttachPoint) instance;						yourself);				connectFrom: #yourself					toAll: [ :node | node transitions collect: [ :each | each to ] ].			view @ (Smalltalk at: #RTDraggableView).			(Smalltalk at: #RTForceBasedLayout) new				charge: -6000;				nbIterations: 50;				on: elements edges: view edges.			view ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.336656 pm'!!SmaCCString methodsFor: '*SmaCC_Debugging_Support'!gtStringIn: aComposite	<gtInspectorPresentationOrder: 0>	aComposite text		title: 'String';		withLineNumbers: true;		display: [ self asString ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.337656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!isAcceptState: stateIndex	self		allActionsAndSymbolsForState: stateIndex		do: [ :action :symbol | 			action = self acceptAction				ifTrue: [ ^ true ] ].	^ false! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.338656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolForTransitionFrom: fromState to: toState	| id |	id := self symbolIdForTransitionFrom: fromState to: toState.	^ self symbolNameFor: id! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.338656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!maxReturnSizeTable	| table |	table := Array new: self transitionTable size withAll: 0.	1 to: table size do: [ :i | 		self			allActionsAndSymbolsForState: i			do: [ :action :symbol | 				(action bitAnd: self actionMask) = self reduceAction					ifTrue: [ | size |						size := (self reduceTable at: (action bitShift: -2)) at: 2.						table at: i put: ((table at: i) max: size) ] ] ].	table max		timesRepeat: [ 1 to: table size do: [ :i | 				self					allActionsAndSymbolsForState: i					do: [ :action :symbol | 						(action bitAnd: self actionMask) = self shiftAction							ifTrue: [ | size |								size := (table at: (action bitShift: -2)) - 1.								table at: i put: ((table at: i) max: size) ] ] ] ].	^ table! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.339656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolIdForTransitionFrom: fromState to: toState	| toValue |	toValue := (toState bitShift: 2) bitOr: self shiftAction.	self		allActionsAndSymbolsForState: fromState		do: [ :action :symbol | 			toValue = action				ifTrue: [ ^ symbol ] ].	^ 0! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.340656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!fillInGraphFromStack: nodeCollection returnTable: tableArray size: sizeInteger	self		allActionsAndSymbolsForState: nodeCollection last state		do: [ :action :symbol | 			| id type next name entry top stream reduction |			id := action bitShift: -2.			type := action bitAnd: self actionMask.			type = self acceptAction				ifTrue: [ nodeCollection last success: true ].			type = self shiftAction				ifTrue: [ ((tableArray at: id) > sizeInteger or: [ self isAcceptState: id ])						ifTrue: [ name := self symbolNameFor: symbol.							next := nodeCollection last addDirectLinkToNodeNamed: name state: id.							nodeCollection add: next.							[ self fillInGraphFromStack: nodeCollection returnTable: tableArray size: sizeInteger + 1 ]								ensure: [ nodeCollection removeLast ] ] ].			type = self reduceAction				ifTrue: [ entry := self reduceTable at: id.					(entry at: 2) >= sizeInteger						ifTrue: [ name := self symbolNameFor: entry first.							stream := WriteStream on: String new.							stream								nextPutAll: name;								nextPutAll: ' :'.							nodeCollection size - (entry at: 2) + 1 to: nodeCollection size do: [ :i | 								stream									nextPut: $ ;									nextPutAll: (nodeCollection at: i) name ].							stream nextPut: $;.							reduction := stream contents.							top := nodeCollection at: nodeCollection size - (entry at: 2).							nodeCollection size - (entry at: 2) + 1 to: nodeCollection size do: [ :i | (nodeCollection at: i) addReduction: reduction ].							next := top addDirectLinkToNodeNamed: name state: ((self actionForState: top state and: entry first) bitShift: -2) ] ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.341656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!roassalView	^ self roassalViewForStack: (stateStack ifNil: [ Array with: self class defaultStartingState ])! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.341656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!roassalViewForStack: stack	| shape nodes es root view |	root := self graphForStack: stack.	nodes := root allNodes.	view := (Smalltalk at: #RTView) new.	shape := (Smalltalk at: #RTEllipse) new		color: Color white;		borderColor: Color black;		width: 25;		height: 25;		yourself.	view add: (shape elementOn: root).	shape := ((Smalltalk at: #RTRoundedBox) new		borderRadius: [ :n | 			('<"' includes: n name first)				ifTrue: [ 0 ]				ifFalse: [ 10 ] ];		color: Color white;		borderColor: [ :n | 			n success				ifTrue: [ Color green ]				ifFalse: [ n isFollowed						ifTrue: [ Color black ]						ifFalse: [ Color lightGray ] ] ];		yourself)		+			((Smalltalk at: #RTLabel) new				color: [ :n | 					n success						ifTrue: [ Color green ]						ifFalse: [ n isFollowed								ifTrue: [ Color black ]								ifFalse: [ Color lightGray ] ] ];				text: [ :n | n name ];				yourself).	shape allOfSameSizeWithPadding.	es := shape		elementsOn:			(nodes copy				remove: root;				yourself).	view addAll: es.	shape := (Smalltalk at: #RTMultiLine) new.	shape orthoHorizontal.	shape color: Color black.	shape attachPoint: (Smalltalk at: #RTHorizontalAttachPoint) instance.	(Smalltalk at: #RTEdgeBuilder) new		view: view;		objects: nodes;		shape: shape;		connectTo: [ :n | n followed ].	shape := (Smalltalk at: #RTMultiLine) new.	shape orthoHorizontal.	shape color: Color lightGray.	shape attachPoint: (Smalltalk at: #RTHorizontalAttachPoint) instance.	(Smalltalk at: #RTEdgeBuilder) new		view: view;		objects: nodes;		shape: shape;		connectToAll: [ :n | n directLinks ].	view elements @ ((Smalltalk at: #RTPopup) text: [ :n | n description ]).	view @ (Smalltalk at: #RTDraggableView).	self layout: view from: root position: 0 @ 0.	^ view! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.342656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolNameFor: anInteger	^ self symbolNames at: anInteger ifAbsent: [ '?' ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.343656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	((Smalltalk includesKey: #RTView) not		or: [ ((self class class whichClassIncludesSelector: #transitionTable) >> #transitionTable) methodClass = SmaCCParser class ])		ifTrue: [ ^ nil ].	composite roassal2		title: 'Graph';		initializeView: [ self roassalView ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.344656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!layout: aView from: aNode position: aPoint	| element bottom nextLeft horizontalGap verticalGap position |	horizontalGap := 20.	verticalGap := 3.	element := aView elementFromModel: aNode.	nextLeft := aPoint x + element width + horizontalGap.	bottom := aPoint y.	aNode followed notNil		ifTrue: [ bottom := (self layout: aView from: aNode followed position: nextLeft @ bottom) + verticalGap ].	(aNode directLinks asSortedCollection: [ :a :b | a name < b name ]) do: [ :each | bottom := (self layout: aView from: each position: nextLeft @ bottom) + verticalGap ].	bottom = aPoint y		ifTrue: [ bottom := bottom + element height + verticalGap ].	bottom := bottom - verticalGap.	bottom := bottom max: aPoint y + element height.	position := aPoint x @ ((bottom + aPoint y) / 2 - (element height / 2)).	(Smalltalk at: #RTLayoutTranslator) default translateTopLeftOf: element to: position.	^ bottom! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.344656 pm'!!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!graphForStack: aCollection	| id name next graphNodeStack returnTable |	graphNodeStack := OrderedCollection new.	graphNodeStack add: (SmaCCGraphNode named: '' state: aCollection first parser: self).	2 to: aCollection size do: [ :i | 		id := self symbolIdForTransitionFrom: (aCollection at: i - 1) to: (aCollection at: i).		name := self symbolNameFor: id.		next := SmaCCGraphNode named: name state: (aCollection at: i) parser: self.		graphNodeStack last followed: next.		graphNodeStack add: next ].	returnTable := self maxReturnSizeTable.	self fillInGraphFromStack: graphNodeStack returnTable: returnTable size: 0.	^ graphNodeStack first! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.345656 pm'!!SmaCCShiftAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator		pushObject: aSmaCCToken		andState:			(aParserSimulator				moveOn: (aParserSimulator symbolForId: aSmaCCToken ids first)				from: aParserSimulator parserStateId).	aParserSimulator processedToken! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.346656 pm'!!SmaCCParserError methodsFor: '*SmaCC_Debugging_Support'!gtParserErrorInspectorViewIn: composite	<gtInspectorPresentationOrder: 1>	composite text		title: 'Error';		display: [ | source |			source := self tag scanner debugSource.			(source isEmpty and: [ self tag position > 1 ])				ifTrue: [ 'No source available' ]				ifFalse: [ (source copyFrom: 1 to: self tag position - 1) , self description , ' ->' , (source copyFrom: self tag position to: source size) ] ];		primarySelectionInterval: (self tag position to: self tag position + self description size + 2);		withLineNumbers: true! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.346656 pm'!!SmaCCReduceAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	| items |	items := aParserSimulator popItems: lr1Item rhs size.	aParserSimulator		pushObject: (SmaCCReducedItem reduced: lr1Item rhs with: items)		andState:			(aParserSimulator				moveOn: lr1Item rhs productionSymbol				from: aParserSimulator parserStateId)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.347656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtCollectionItems: aCollection type: aSymbol	^ (1 to: aCollection size) collect: [ :i | Array with: i printString with: aSymbol with: (aCollection at: i) ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.348656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtChildrenOf: each	^ (each at: 2) = #node		ifTrue: [ each last gtInspectorItems ]		ifFalse: [ (each at: 2) = #nodes				ifTrue: [ self gtCollectionItems: each last type: #node ]				ifFalse: [ (each at: 2) = #tokens						ifTrue: [ self gtCollectionItems: each last type: #token ]						ifFalse: [ #() ] ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.349656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!debugLabelForChild: anObject	self singularVariableSelectors		do: [ :each | 			(self perform: each)				do: [ :sel | 					(self perform: sel) == anObject						ifTrue: [ ^ sel ] ] ].	self compositeVariableSelectors		do: [ :each | 			(self perform: each)				do: [ :sel | 					| index |					index := (self perform: sel) identityIndexOf: anObject.					index > 0						ifTrue: [ ^ index printString , ': ' , sel ] ] ].	^ anObject class name! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.350656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorTreeIn: aComposite	<gtInspectorPresentationOrder: 30>	aComposite tabulator		with: [ :browser | 			browser title: 'Tree'.			browser row: #variables.			browser transmit				from: #variables;				toOutsidePort: #selection;				transformed: [ :each | each ifNotNil: [ each last ] ].			browser transmit				to: #variables;				andShow: [ :composite | 					composite table						display: [ Array with: (Array with: 'self' with: #node with: self) ];						children: [ :each | self gtChildrenOf: each ];						format: [ :each | each first ];						column: 'Variable' evaluated: [ :each | each first ];						column: 'Type'							evaluated: [ :each | 							(each at: 2) = #node								ifTrue: [ each last class name ]								ifFalse: [ '' ] ]							tags: [ :each | Array with: (each at: 2) ] ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.351656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtAttributesIn: aComposite	<gtInspectorPresentationOrder: 35>	| tabulator |	(attributes notNil and: [ attributes notEmpty ])		ifFalse: [ ^ self ].	tabulator := aComposite tabulator.	tabulator		title: 'Attributes';		row: #attributes.	tabulator transmit		to: #attributes;		andShow: [ :pres | 			pres fastTable				display: [ attributes keys asSortedCollection ];				column: 'Name' evaluated: [ :each | each ];				column: 'Value' evaluated: [ :each | self attributeNamed: each ifAbsent: [  ] ] ].	tabulator transmit		toOutsidePort: #selection;		from: #attributes port: #selection;		transformed: [ :name | self attributeNamed: name ifAbsent: [  ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.352656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtParentsIn: aComposite	<gtInspectorPresentationOrder: 34>	parent isNil		ifTrue: [ ^ self ].	aComposite tree		title: 'Parents';		allExpanded;		display: [ Array with: self ];		format: [ :each | each class name ];		children: [ :each | 			(each notNil and: [ each parent notNil ])				ifTrue: [ Array with: each parent ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.353656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorItems	| items |	items := OrderedCollection new.	self class allInstVarNames		do:			[ :each | 			| selector tag value |			selector := each asSymbol.			(value := self perform: selector) notNil				ifTrue:					[ tag := nil.					((self otherVariables includes: selector) or: [ self ignoredOtherVariables includes: selector ])						ifTrue: [ tag := #other ].					((self nodeVariables includes: selector) or: [ self ignoredNodeVariables includes: selector ])						ifTrue: [ tag := #node ].					(((self compositeNodeVariables includes: selector) or: [ self ignoredCompositeNodeVariables includes: selector ])						and: [ value notEmpty ])						ifTrue: [ tag := #nodes ].					((self tokenVariables includes: selector) or: [ self ignoredTokenVariables includes: selector ])						ifTrue: [ tag := #token ].					(((self compositeTokenVariables includes: selector) or: [ self ignoredCompositeTokenVariables includes: selector ])						and: [ value notEmpty ])						ifTrue: [ tag := #tokens ].					tag notNil						ifTrue: [ items add: (Array with: each with: tag with: value) ] ] ].	^ items! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.354656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!debugMatch: aNode	| process done value match context arg |	match := SmaCCDebugMatchResult forPattern: self.	done := false.	process := [ [ value := self match: aNode inContext: Dictionary new ]		ensure: [ done := true ] ] newProcess.	[ [ done ]		whileFalse: [ context := process suspendedContext.			(context isBlockContext not and: [ context method selector = #match:inContext: ])				ifTrue: [ arg := context arguments at: 1 ].			process step: process suspendedContext.			(context isDead and: [ context isBlockContext not and: [ context method selector = #match:inContext: ] ])				ifTrue: [ match processMatchFor: context receiver and: arg result: process suspendedContext top ] ] ]		ensure: [ process terminate ].	^ match! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.354656 pm'!!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorSourceIn: aComposite	<gtInspectorPresentationOrder: 40>	aComposite text		title: 'Source';		withLineNumbers: true;		display: [ self topParent completeSource ];		initialize:				[ :textPresentation | textPresentation selectionInterval: self sourceInterval ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.355656 pm'!!SmaCCPreferredCompositeAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	preferredAction simulateOn: aParserSimulator token: aSmaCCToken! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.356656 pm'!!SmaCCAcceptAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator accept.	aParserSimulator processedToken! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.357656 pm'!!AbstractFileReference methodsFor: '*SmaCC_Debugging_Support'!smaCCParseUsing: parserClass	| contents |	self		readStreamDo: [ :str | 			parserClass setEncodingOn: str.			contents := str contents ].	^ parserClass parse: contents! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.358656 pm'!!AbstractFileReference methodsFor: '*SmaCC_Debugging_Support'!gtParseInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	| extension tabulator |	extension := self extension.	extension isEmpty		ifTrue: [ ^ self ].	extension := '.' , extension.	SmaCCParser allSubclasses		do: [ :parser | 			(parser fileExtensions includes: extension)				ifTrue: [ tabulator := composite tabulator.					tabulator						title: [ parser name asString ];						row: #buttons size: 35;						row: #result.					tabulator transmit						to: #buttons;						andShow: [ :presentation | 							presentation actionList								act: [ :l | 									((tabulator paneNamed: #buttons) port: #result)										value:											([ self smaCCParseUsing: parser ]												on: SmaCCParserError												do: [ :ex | ex return: ex ]) ]									entitled: 'Parse';								act: [ [ self smaCCParseUsing: parser.									UIManager default message: 'Parses without errors' ]										on: SmaCCParserError										do: [ :ex | Processor activeProcess debug: thisContext title: ex description full: true ] ]									entitled: 'Debug' ].					tabulator transmit						from: #buttons port: #result;						to: #result;						andShow: [ :presentation :obj | 							| inspector |							inspector := GTInspector new.							inspector startOn: obj.							(presentation custom: inspector) title: 'Result' ] ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.359656 pm'!!SmaCCAmbiguousAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	| currentState uniqueActions |	currentState := aParserSimulator currentParserState.	uniqueActions := self uniqueActions.	2 to: uniqueActions size do: [ :i | 		aParserSimulator duplicateState.		(actions at: i) simulateOn: aParserSimulator token: aSmaCCToken.		aParserSimulator processToken.		aParserSimulator restoreState: currentState andToken: aSmaCCToken ].	uniqueActions first simulateOn: aParserSimulator token: aSmaCCToken! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.359656 pm'!!SmaCCAmbiguousAction methodsFor: '*SmaCC_Debugging_Support'!uniqueActions	| hasShift |	hasShift := false.	^ actions		reject: [ :each | 			| previousHasShift |			each isShift				and: [ previousHasShift := hasShift.					hasShift := true.					previousHasShift ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.360656 pm'!!SmaCCRejectAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator killStateFrom: aSmaCCToken.	aParserSimulator processedToken! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.361656 pm'!!SmaCCParseNode class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSimple	<gtExample>	^ self new! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.362656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!sourceFilesIn: aDirectory	^ aDirectory asFileReference allFiles		select: [ :each | 			| extension |			extension := '.' , each extension.			self fileExtensions includes: extension ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.363656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 14>	self new gtGraphInspectorViewIn: composite! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.363656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!filesWithParserErrorsIn: aDirectory	^ (self sourceFilesIn: aDirectory)		select: [ :each | 			[ self parseFile: each.			false ]				on: Error				do: [ :ex | ex return: true ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.364656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSmaCCParser	<gtExample>	<label: 'SmaCCParser'>		^ SmaCCDefinitionParser new.	! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:47.365656 pm'!!SmaCCToken class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSimple	<gtExample>	^ self value: 'simple'! !