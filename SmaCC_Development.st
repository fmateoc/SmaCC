Object subclass: #SmaCCGrammar	instanceVariableNames: 'type shiftReduceTable symbols scannerDefinition otherStartingSymbols classDefinitions prefix suffix codeGenerator isGLR ignoreCase ignoredVariables annotateTokens errorSymbol emptySymbol sentinelSymbol'	classVariableNames: 'IsExpressionMap IsExpressionMaxCharacter IsExpressions MaximumCharacterValue TokenNameBlock TokenNameMap'	package: 'SmaCC_Development-Model'!!SmaCCGrammar methodsFor: 'accessing'!emptySymbol	^ emptySymbol		ifNil: [ emptySymbol := self newTerminalSymbolNamed: 'E O F' ]! !!SmaCCGrammar methodsFor: 'accessing'!makeTokenIdMethodFor: aString	| token |	token := (scannerDefinition includesTokenNamed: aString)		ifTrue: [ self terminalSymbolNamed: aString ]		ifFalse:			[ self				findSymbolNamed: aString				ifAbsentAdd: [ self newTerminalSymbolNamed: aString ] ].	token createIdMethod: true! !!SmaCCGrammar methodsFor: 'accessing'!unusedSymbols	| nonTerminals problemSymbols todo |	nonTerminals := self symbols reject: [ :each | each isTerminal ].	todo := OrderedCollection withAll: self allStartingSymbols.	problemSymbols := nonTerminals asSet		reject: [ :each | todo includes: each ].	[ todo isEmpty ]		whileFalse:			[ todo removeFirst				productionsDo:					[ :rhs | 					rhs						do:							[ :each | 							(problemSymbols includes: each)								ifTrue: [ todo add: each.									problemSymbols remove: each ] ] ] ].	^ problemSymbols! !!SmaCCGrammar methodsFor: 'accessing'!addStartingSymbol: aSmaCCSymbol	(otherStartingSymbols includes: aSmaCCSymbol)		ifFalse: [ otherStartingSymbols add: aSmaCCSymbol ]! !!SmaCCGrammar methodsFor: 'accessing'!codeGenerator	^ codeGenerator! !!SmaCCGrammar methodsFor: 'accessing'!initialItemSetFor: aSmaCCSymbol	^ aSmaCCSymbol asLRItemSet		type: type;		yourself! !!SmaCCGrammar methodsFor: 'accessing'!scannerStates	^ scannerDefinition states! !!SmaCCGrammar methodsFor: 'accessing'!setStartSymbolIfNone: aSmaCCSymbol	| startSymbol |	self startSymbol notNil		ifTrue: [ ^ self ].	startSymbol := self newStartingSymbolNamed: ''.	self addSymbol: startSymbol.	startSymbol		addProduction:			(self newRHS				add: aSmaCCSymbol;				yourself)! !!SmaCCGrammar methodsFor: 'accessing'!startSymbol	^ self symbols		detect: [ :each | each isStartingSymbol ]		ifNone: [ nil ]! !!SmaCCGrammar methodsFor: 'accessing'!allStartingSymbols	"Return all starting symbols with the default starting symbol listed first."	| startingSymbols default |	default := self startSymbol.	startingSymbols := otherStartingSymbols copy.	startingSymbols remove: default symbol ifAbsent: [  ].	startingSymbols := startingSymbols		collect:			[ :each | self createStartingSymbolFor: each ].	startingSymbols addFirst: default.	^ startingSymbols! !!SmaCCGrammar methodsFor: 'accessing'!createStartingSymbolFor: smaccSymbol	^ (self newStartingSymbolNamed: smaccSymbol name)		addProduction:			(self newRHS				add: smaccSymbol;				yourself);		yourself! !!SmaCCGrammar methodsFor: 'accessing'!rhsDo: aBlock	self symbols do: [ :each | each productionsDo: aBlock ]! !!SmaCCGrammar methodsFor: 'accessing'!rootDefinition	^ classDefinitions detect: [ :each | each isRoot ] ifNone: [ nil ]! !!SmaCCGrammar methodsFor: 'accessing'!errorSymbol	^ errorSymbol		ifNil: [ errorSymbol := (SmaCCErrorTerminalSymbol name: 'error')				grammar: self;				yourself ]! !!SmaCCGrammar methodsFor: 'accessing'!sentinelSymbol	^ sentinelSymbol		ifNil: [ sentinelSymbol := self newTerminalSymbolNamed: 'S e n t i n e l' ]! !!SmaCCGrammar methodsFor: 'accessing'!preferredActionFor: aSmaCCSymbol	^ shiftReduceTable at: aSmaCCSymbol ifAbsent: [ nil ]! !!SmaCCGrammar methodsFor: 'accessing'!annotateTokens: aBoolean	annotateTokens := aBoolean! !!SmaCCGrammar methodsFor: 'accessing'!suffix	^ suffix! !!SmaCCGrammar methodsFor: 'accessing'!prefix	^ prefix! !!SmaCCGrammar methodsFor: 'accessing'!classNamed: aSymbol	^ classDefinitions		at: aSymbol		ifAbsentPut: [ SmaCCNodeClassDefinition named: aSymbol grammar: self ]! !!SmaCCGrammar methodsFor: 'accessing'!symbolNamed: aString	^self findSymbolNamed: aString ifAbsent: [ nil ]! !!SmaCCGrammar methodsFor: 'accessing'!emptySymbols	^ self symbols		select: [ :each | each isTerminal not and: [ each isEmpty ] ]! !!SmaCCGrammar methodsFor: 'accessing'!classDefinitions	| defs root |	root := self rootDefinition.	(root isNil and: [ classDefinitions notEmpty ])		ifTrue:			[ SmaCCCompilationNotification new				messageText: 'Node generation';				tag: 'Cannot generate node classes without specifying a "%root" node.';				signal ].	root isNil		ifTrue: [ ^ #() ].	defs := classDefinitions asOrderedCollection.	defs		do:			[ :each | 			(each isRoot not and: [ each superclass isNil ])				ifTrue: [ each superclass: root ] ].	^ defs! !!SmaCCGrammar methodsFor: 'accessing'!tokens	^ scannerDefinition tokens! !!SmaCCGrammar methodsFor: 'accessing'!addExtraSymbols	self addSymbol: self emptySymbol.	self addSymbol: self errorSymbol! !!SmaCCGrammar methodsFor: 'initialize-release'!initialize	super initialize.	scannerDefinition := SmaCCScannerDefinition new.	type := #LALR1.	symbols := OrderedCollection new.	shiftReduceTable := Dictionary new.	otherStartingSymbols := OrderedCollection new.	classDefinitions := Dictionary new.	prefix := suffix := ''.	isGLR := false.	ignoreCase := false.	ignoredVariables := Set new.	annotateTokens := false! !!SmaCCGrammar methodsFor: 'initialize-release'!prefix: aString	prefix := aString! !!SmaCCGrammar methodsFor: 'initialize-release'!codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator.	aSmaCCCodeGenerator grammar: self! !!SmaCCGrammar methodsFor: 'initialize-release'!scannerDefinition: aSmaCCScannerDefinition	scannerDefinition := aSmaCCScannerDefinition! !!SmaCCGrammar methodsFor: 'initialize-release'!isGLR: aBoolean	isGLR := aBoolean! !!SmaCCGrammar methodsFor: 'initialize-release'!suffix: aString	suffix := aString! !!SmaCCGrammar methodsFor: 'initialize-release'!scannerDefinition	^ scannerDefinition! !!SmaCCGrammar methodsFor: 'initialize-release'!type: aSmaCCSymbol	type := aSmaCCSymbol! !!SmaCCGrammar methodsFor: 'item creation'!newStartingSymbolNamed: aString	^ (SmaCCStartingSymbol name: 'B e g i n' , aString)		grammar: self;		yourself! !!SmaCCGrammar methodsFor: 'item creation'!newItemSet	^ SmaCCItemSet new		grammar: self;		yourself! !!SmaCCGrammar methodsFor: 'item creation'!newNonTerminalSymbolNamed: aString	^ (SmaCCNonTerminalSymbol name: aString)		grammar: self;		yourself! !!SmaCCGrammar methodsFor: 'item creation'!newRHS	^ SmaCCRHS new		grammar: self;		yourself! !!SmaCCGrammar methodsFor: 'item creation'!newTerminalSymbolNamed: aString	^ (SmaCCTerminalSymbol name: aString)		grammar: self;		yourself! !!SmaCCGrammar methodsFor: 'precedence'!setOperatorPrecedenceFor: aSmaCCSymbol to: anInteger	aSmaCCSymbol precedence: anInteger! !!SmaCCGrammar methodsFor: 'precedence'!leftPrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCReduceAction! !!SmaCCGrammar methodsFor: 'precedence'!nonAssociativePrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCRejectAction! !!SmaCCGrammar methodsFor: 'precedence'!rightPrecedenceFor: aSmaCCSymbol	shiftReduceTable at: aSmaCCSymbol put: SmaCCShiftAction! !!SmaCCGrammar methodsFor: 'private'!keywordRegularExpressionFor: aString	| regularExpressionString regex |	regularExpressionString := (aString copyFrom: 2 to: aString size - 1) copyReplaceAll: '""' with: '"'.	regex := regularExpressionString		inject: nil		into: [ :sum :each | 			sum isNil				ifTrue: [ SmaCCCharacterRENode characters: (SmaCCCharacterSet with: each) ]				ifFalse: [ sum , (SmaCCCharacterRENode characters: (SmaCCCharacterSet with: each)) ] ].	regex addStates: self scannerStates.	^ regex! !!SmaCCGrammar methodsFor: 'private'!finishBuilding	self ignoreCase		ifTrue:			[ self symbols do: [ :each | each makeCaseInsensitive ].			self mergeCaseSensitiveKeywords ].	annotateTokens		ifTrue:			[ self symbols				do: [ :each | each annotateTokenVariables: self class tokenNameBlock ] ]! !!SmaCCGrammar methodsFor: 'private'!findSymbolNamed: aString ifAbsent: aBlock	^ self symbols detect: [ :each | each name = aString ] ifNone: aBlock! !!SmaCCGrammar methodsFor: 'private'!keywordTerminalNamed: aString	^ self		findSymbolNamed: aString		ifAbsentAddFirst:			[ (self newTerminalSymbolNamed: aString)				regularExpression: (self keywordRegularExpressionFor: aString);				yourself ]! !!SmaCCGrammar methodsFor: 'private'!symbols: aCollection	symbols := aCollection! !!SmaCCGrammar methodsFor: 'private'!nonTerminalSymbolNamed: aString	^ self		findSymbolNamed: aString		ifAbsentAdd: [ self newNonTerminalSymbolNamed: aString ]! !!SmaCCGrammar methodsFor: 'private'!ignoredVariables: aCollection	ignoredVariables := aCollection asSet! !!SmaCCGrammar methodsFor: 'private'!addSymbol: aSmaCCSymbol	aSmaCCSymbol grammar: self.	self symbols add: aSmaCCSymbol.	^ aSmaCCSymbol! !!SmaCCGrammar methodsFor: 'private'!mergeCaseSensitiveKeywords	| duplicateMap |	duplicateMap := Dictionary new.	self symbols		do:			[ :each | 			(each isTerminal and: [ each name first = $" ])				ifTrue:					[ (duplicateMap						at: each name asUppercase						ifAbsentPut: [ OrderedCollection new ]) add: each ] ].	duplicateMap		keysAndValuesDo: [ :name :value | 			value size > 1				ifTrue: [ self mergeAll: value ] ]! !!SmaCCGrammar methodsFor: 'private'!terminalSymbolNamed: aString	^ self		findSymbolNamed: aString		ifAbsentAdd:			[ (self newTerminalSymbolNamed: aString)				regularExpression: (scannerDefinition tokenNamed: aString);				yourself ]! !!SmaCCGrammar methodsFor: 'private'!ignoreCase: aBoolean	ignoreCase := aBoolean! !!SmaCCGrammar methodsFor: 'private'!ignoredVariables	^ ignoredVariables! !!SmaCCGrammar methodsFor: 'private'!findSymbolNamed: aString ifAbsentAdd: aBlock	^ self		findSymbolNamed: aString		ifAbsent: [ self addSymbol: aBlock value ]! !!SmaCCGrammar methodsFor: 'private'!findSymbolNamed: aString ifAbsentAddFirst: aBlock	^ self		findSymbolNamed: aString		ifAbsent: [ self addSymbolFirst: aBlock value ]! !!SmaCCGrammar methodsFor: 'private'!mergeAll: anOrderedCollection	| new first set |	first := anOrderedCollection first.	new := self newTerminalSymbolNamed: first name asUppercase.	new regularExpression: first regularExpression.	symbols add: new before: first.	symbols removeAll: anOrderedCollection.	set := anOrderedCollection asSet.	self		rhsDo:			[ :each | 			1 to: each size do:				[ :i | 				(set includes: (each at: i))					ifTrue: [ each collection at: i put: new ] ] ]! !!SmaCCGrammar methodsFor: 'private'!symbols	^ symbols! !!SmaCCGrammar methodsFor: 'private'!calculateFirstSets	| changed |	changed := true.	[ changed ]		whileTrue:			[ changed := false.			self symbols				do: [ :each | changed := changed | each calculateFirstTerminals ] ]! !!SmaCCGrammar methodsFor: 'private'!addSymbolFirst: aSmaCCSymbol	aSmaCCSymbol grammar: self.	^ self symbols addFirst: aSmaCCSymbol! !!SmaCCGrammar methodsFor: 'testing'!hasMultipleScannerStates	^ self scannerStates size > 1! !!SmaCCGrammar methodsFor: 'testing'!isGLR	^ isGLR! !!SmaCCGrammar methodsFor: 'testing'!ignoreCase	^ ignoreCase! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCGrammar class	instanceVariableNames: ''!!SmaCCGrammar class methodsFor: 'private'!generateCharacterSetFor: aSelector	| set |	set := SmaCCCharacterSet new.	0 to: self maximumCharacterValue do: [ :i | 		| ch |		ch := Character value: i.		(ch perform: aSelector)			ifTrue: [ set add: ch ] ].	^ set! !!SmaCCGrammar class methodsFor: 'private'!charactersFor: aSymbol	| isExpressionMap |	isExpressionMap := self isExpressionMap.	^ isExpressionMap at: aSymbol ifAbsentPut: [ self generateCharacterSetFor: aSymbol ]! !!SmaCCGrammar class methodsFor: 'accessing'!isExpressions	^ IsExpressions! !!SmaCCGrammar class methodsFor: 'accessing'!implicitToken: aString	| symbol node |	symbol := (aString copyFrom: 2 to: aString size - 1) asSymbol.	(Character canUnderstand: symbol)		ifFalse: [ ^ nil ].	node := SmaCCCharacterRENode characters: (self charactersFor: symbol).	node position: SmallInteger maxVal.	"Implicit nodes have least precedence"	^ node! !!SmaCCGrammar class methodsFor: 'accessing'!isExpressions: aCollection	"Assign a collection of Character is___ selectors that can be used to create the scanner. These can make the generated scanners easier to read as a test like currentCharacter isAlphaNumeric is easier to read than a test of '(currentCharacter >= $A and: [currentCharacter <= $Z]) or: [(currentCharacter >= $a and: [currentCharacter <= $z]) or: [currentCharacter >= $0 and: [currentCharacter <= $9]]]'. If the collection is nil, SmaCC will automatically create the set of all is___ methods that are in the current image. This may result in a scanner that doesn't work in a different image. If you wish to limit the selectors that can be used, you can set them here:		self isExpressions: #(isAlphaNumeric isDigit isLetter isLiteral isLowercase isSeparator isSpecial isUppercase isVowel)		"	IsExpressions := aCollection.	IsExpressionMap := nil! !!SmaCCGrammar class methodsFor: 'accessing'!maximumCharacterValue: anInteger	MaximumCharacterValue := anInteger! !!SmaCCGrammar class methodsFor: 'accessing'!tokenNameBlock: aBlock	TokenNameBlock := aBlock! !!SmaCCGrammar class methodsFor: 'accessing'!tokenNameMap: aDictionary	TokenNameMap := aDictionary! !!SmaCCGrammar class methodsFor: 'accessing'!tokenNameBlock	^ TokenNameBlock		ifNil: [ [ :string | self defaultTokenNameFor: string ] ]! !!SmaCCGrammar class methodsFor: 'accessing'!maximumCharacterValue	^ MaximumCharacterValue! !!SmaCCGrammar class methodsFor: 'accessing'!isExpressionMap	"Creates a map from selectors that start with 'is' on Character to sets of characters. This allows generated scanners to take	full advantage of selectors that are already implemented on Character"	(IsExpressionMap isNil or: [ IsExpressionMaxCharacter ~= self maximumCharacterValue ])		ifTrue: [ | selectors |			IsExpressionMaxCharacter := self maximumCharacterValue.			IsExpressionMap := Dictionary new.			selectors := IsExpressions				ifNil: [ Character selectors select: [ :each | each size > 2 and: [ (each beginsWith: 'is') and: [ each numArgs = 0 and: [ (each at: 3) isUppercase ] ] ] ] ].			selectors				do: [ :sel | 					| string |					string := self generateCharacterSetFor: sel.					string isEmpty						ifFalse: [ IsExpressionMap at: sel put: string ] ] ].	^ IsExpressionMap! !!SmaCCGrammar class methodsFor: 'accessing'!tokenNameMap	^ TokenNameMap ifNil: [ TokenNameMap := self defaultTokenNameMap ]! !!SmaCCGrammar class methodsFor: 'accessing'!allCharacters	^ SmaCCCharacterSet withAllCharactersTo: (Character value: self maximumCharacterValue)! !!SmaCCGrammar class methodsFor: 'accessing'!defaultTokenNameFor: aString	| stream string |	stream := WriteStream on: String new.	aString		do:			[ :each | 			| value |			value := self tokenNameMap at: each ifAbsent: [ each ].			value isString				ifTrue:					[ stream						nextPutAll:							(stream position = 0								ifTrue: [ value ]								ifFalse: [ value capitalized ]) ]				ifFalse: [ stream						nextPut:							(value isAlphaNumeric								ifTrue: [ value ]								ifFalse: [ $_ ]) ] ].	string := stream contents.	string first isDigit		ifTrue: [ string := '_' , string ].	string first isUppercase		ifTrue: [ string at: 1 put: string first asLowercase ].	^ string , 'Token'! !!SmaCCGrammar class methodsFor: 'accessing'!defaultTokenNameMap	| map |	map := Dictionary new.	#(#($< 'lessThan') #($> 'greaterThan') #($= 'equal') #($( 'leftParen') #($) 'rightParen') #(${ 'leftBrace') #($} 'rightBrace') #($[ 'leftBracket') #($] 'rightBracket') #($, 'comma') #($; 'semicolon') #($- 'minus') #($+ 'plus') #($* 'times') #($/ 'divide') #($: 'colon') #($. 'period') #($? 'questionMark') #($!! 'bang') #($% 'percent') #($^ 'upArrow') #($& 'and') #($| 'or') #($~ 'tilde'))		do: [ :each | map at: each first put: each last ].	^ map! !!SmaCCGrammar class methodsFor: 'class initialization'!initialize	self maximumCharacterValue: 255.	"A good default of isExpressions -- you can set to nil to have it compute from the image"	self isExpressions: #(isAlphaNumeric isDigit isLetter isLiteral isLowercase isSeparator isSpecial isUppercase isVowel)! !SmaCCDefinitionNodeVisitor subclass: #SmaCCGrammarCreator	instanceVariableNames: 'grammar defaultClasses expansionCount'	classVariableNames: 'MaxExpansions'	package: 'SmaCC_Development-Model'!!SmaCCGrammarCreator methodsFor: 'visiting'!visitCodeProductionExpression: aCodeProdutionExpression	| items |	items := super visitCodeProductionExpression: aCodeProdutionExpression.	items do: [ :rhs | self verifyCodeToken: aCodeProdutionExpression code for: rhs ].	^ items! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitScopeDirective: aScopeDirective	| type |	type := aScopeDirective typeToken value.	(type = 'scopes' or: [ type = 'states' ])		ifTrue: [ ^ aScopeDirective names do: [ :each | grammar scannerDefinition addState: each value asSymbol ] ].	type = 'excludes'		ifTrue: [ ^ aScopeDirective names do: [ :each | grammar scannerDefinition addExcludeState: each value asSymbol ] ].	self reportErrorMessage: 'Unknown directive' on: aScopeDirective typeToken! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitProductionSymbol: aProductionSymbol	^ grammar nonTerminalSymbolNamed: aProductionSymbol name value! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitKeywordSymbol: aKeywordSymbol	^ grammar keywordTerminalNamed: aKeywordSymbol name value! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitGroupTerm: aGroupTerm	| symbol |	symbol := grammar nonTerminalSymbolNamed: aGroupTerm source.	symbol size = 0		ifTrue: [ symbol position: aGroupTerm startPosition.			aGroupTerm expressions do: [ :each | (self acceptNode: each) do: [ :rhs | symbol addProduction: rhs ] ] ].	^ symbol! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitIdDirective: anIdDirective	anIdDirective names do: [ :each | grammar makeTokenIdMethodFor: each value ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitTokenRule: aTokenRule	| symbol regex |	regex := aTokenRule regularExpression.	regex states isEmpty		ifTrue: [ regex addStates: grammar scannerDefinition nonExcludeStates ].	grammar scannerDefinition addToken: regex withName: aTokenRule name value.	symbol := grammar findSymbolNamed: aTokenRule name value ifAbsent: [ nil ].	symbol notNil		ifTrue: [ symbol regularExpression: regex ].	^ regex! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitTokenSymbol: aTokenSymbol	^ grammar		findSymbolNamed: aTokenSymbol name value		ifAbsentAdd: [ | node symbol |			symbol := grammar newTerminalSymbolNamed: aTokenSymbol name value.			(grammar scannerDefinition includesTokenNamed: aTokenSymbol name value)				ifTrue: [ symbol regularExpression: (grammar scannerDefinition tokenNamed: aTokenSymbol name value) ]				ifFalse: [ node := SmaCCGrammar implicitToken: aTokenSymbol name value.					node notNil						ifTrue: [ node addStates: grammar scannerDefinition nonExcludeStates.							symbol regularExpression: node ] ].			symbol ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitDefinitionError: anError	"We shouldn't get here, but in case someone is passing an AST with errors, signal an error."	self error: 'There was a parse error'! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitGrammarDefinition: aGrammarDefinition	self acceptNodes: aGrammarDefinition rules.	grammar addExtraSymbols.	^ grammar! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitProductionRule: aProductionRule	| symbol |	symbol := grammar nonTerminalSymbolNamed: aProductionRule name value.	symbol position: aProductionRule name startPosition.	aProductionRule expressions do: [ :each | (self acceptNode: each) do: [ :rhs | symbol addProduction: rhs ] ].	self createDefaultClassesForSymbol: aProductionRule name value.	grammar setStartSymbolIfNone: symbol.	^ symbol! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitPostfixTerm: aPostfixTerm	| operator expression symbol rhs varNameToken hasOne hasMany addBlock |	operator := aPostfixTerm operator value.	expression := self acceptNode: aPostfixTerm term.	symbol := grammar nonTerminalSymbolNamed: aPostfixTerm source.	symbol size = 0		ifTrue: [ symbol position: aPostfixTerm startPosition.			hasOne := operator = '+'.			hasMany := operator ~= '?'.			varNameToken := (aPostfixTerm term isKindOf: SmaCCSymbolNode)				ifTrue: [ aPostfixTerm term variableNameToken ].			rhs := grammar newRHS.			addBlock := [ rhs add: expression.			varNameToken notNil				ifTrue: [ rhs nameLastItem: (varNameToken value copyFrom: 2 to: varNameToken value size - 1) ] ].			hasOne				ifTrue: [ addBlock value ].			symbol addProduction: rhs.			rhs := grammar newRHS.			hasMany				ifTrue: [ rhs add: symbol ].			addBlock value.			symbol addProduction: rhs ].	^ symbol! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitSuperclassDirective: aSuperclassDirective	| superclass |	superclass := grammar classNamed: aSuperclassDirective superclass value asSymbol.	aSuperclassDirective names do: [ :each | (grammar classNamed: each value) superclass: superclass ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitStartDirective: aStartDirective	aStartDirective symbols do: [ :each | grammar addStartingSymbol: (grammar nonTerminalSymbolNamed: each value) ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitNodeNameDirective: aNodeNameDirective	| type name |	type := aNodeNameDirective typeToken value.	name := aNodeNameDirective name value.	type = 'prefix'		ifTrue: [ ^ grammar prefix: name ].	type = 'suffix'		ifTrue: [ ^ grammar suffix: name ].	type = 'root'		ifTrue: [ ^ (grammar classNamed: name asSymbol) beRoot ].	self reportErrorMessage: 'Unknown directive' on: aNodeNameDirective typeToken! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitFlagDirective: aFlagDirective	| name |	name := aFlagDirective typeToken value.	name = 'glr'		ifTrue: [ ^ grammar isGLR: true ].	name = 'ignorecase'		ifTrue: [ ^ grammar ignoreCase: true ].	name = 'annotate_tokens'		ifTrue: [ ^ grammar annotateTokens: true ].	name = 'lr1'		ifTrue: [ ^ grammar type: #LR1 ].	name = 'unicode'		ifTrue: [ ^ SmaCCGrammar maximumCharacterValue: 16rE01EF ].	name = 'byte'		ifTrue: [ ^ SmaCCGrammar maximumCharacterValue: 255 ].	self		reportErrorMessage: 'Unknown directive'		on: aFlagDirective typeToken! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitAssociativeDirective: anAssociativeDirective	| type |	type := anAssociativeDirective typeToken value = 'left'		ifTrue: [ #leftPrecedenceFor: ]		ifFalse: [ anAssociativeDirective typeToken value = 'right'				ifTrue: [ #rightPrecedenceFor: ]				ifFalse: [ #nonAssociativePrecedenceFor: ] ].	anAssociativeDirective symbols		do: [ :each | 			| symbol |			symbol := self acceptNode: each.			grammar				perform: type with: symbol;				setOperatorPrecedenceFor: symbol to: anAssociativeDirective typeToken startPosition ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitAttributeDirective: anAttributeDirective	(grammar classNamed: anAttributeDirective classname value asSymbol)		extraAttributes: (anAttributeDirective names collect: [ :each | SmaCCVariableDefinition variableName: each value ])! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitClassProductionExpression: aClassProductionExpression	| items |	items := super visitClassProductionExpression: aClassProductionExpression.	items		do: [ :rhs | 			aClassProductionExpression classname isNil				ifTrue: [ self createDefaultClassFor: rhs ]				ifFalse: [ self createClass: aClassProductionExpression classname value asSymbol for: rhs ] ].	^ items! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitErrorSymbol: anErrorSymbol	^ grammar errorSymbol! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitProductionExpression: aClassProductionExpression	expansionCount := 1.	^ (self combineItems: (self buildItemsFrom: aClassProductionExpression terms)) collect: [ :items | self generateRHS: items ]! !!SmaCCGrammarCreator methodsFor: 'visiting'!visitIgnoreVariableDirective: anIgnoreVariableDirective	grammar ignoredVariables: (anIgnoreVariableDirective names collect: [ :each | each value ])! !!SmaCCGrammarCreator methodsFor: 'testing'!isDigit: each	^ each between: $0 and: $9! !!SmaCCGrammarCreator methodsFor: 'testing'!isLetterOrDigit: each	^ (each between: $a and: $z)		or:			[ (each between: $A and: $Z)				or: [ (each between: $0 and: $9) or: [ each == $_ ] ] ]! !!SmaCCGrammarCreator methodsFor: 'private'!createDefaultClassFor: aSmaCCRHS	defaultClasses add: aSmaCCRHS.	^ aSmaCCRHS! !!SmaCCGrammarCreator methodsFor: 'private'!generateRHS: aCollection	| rhs |	rhs := grammar newRHS.	self addItems: aCollection to: rhs.	^ rhs! !!SmaCCGrammarCreator methodsFor: 'private'!createClass: aSymbol for: aSmaCCRHS	(grammar classNamed: aSymbol) addProduction: aSmaCCRHS.	^ aSmaCCRHS! !!SmaCCGrammarCreator methodsFor: 'private'!verifyCodeToken: codeToken for: aSmaCCRHS	| code |	code := codeToken value copyFrom: 2 to: codeToken value size - 1.	RBParser		parseExpression: code		onError: [ :string :position | 			self				reportErrorMessage: string				on:					(SmaCCToken						value: (code copyFrom: position to: position)						start: codeToken startPosition + position						ids: #()) ].	aSmaCCRHS reduceCodeSource: code.	aSmaCCRHS reduceCode isImmediate: codeToken value first = $[.	^ aSmaCCRHS! !!SmaCCGrammarCreator methodsFor: 'private'!addItems: aCollection to: rhs	aCollection		do: [ :each | 			rhs add: (self acceptNode: each).			each variableNameToken notNil				ifTrue: [ rhs						nameLastItem:							(each variableNameToken value								copyFrom: 2								to: each variableNameToken value size - 1) ] ]! !!SmaCCGrammarCreator methodsFor: 'private'!combineStream: aStream into: aCollection andDo: aBlock	| size position |	aStream atEnd		ifTrue: [ ^ aBlock value: aCollection copy ].	size := aCollection size.	position := aStream position + 1.	aStream next		do: [ :each | 			aCollection addAll: each.			self combineStream: aStream into: aCollection andDo: aBlock ]		separatedBy: [ [ aCollection size > size ] whileTrue: [ aCollection removeLast ].			aStream position: position ]! !!SmaCCGrammarCreator methodsFor: 'private'!buildItemsFrom: aCollection	^ aCollection		collect: [ :item | 			| items |			items := OrderedCollection new.			((item possibilities > 1 and: [ item possibilities * expansionCount <= MaxExpansions ]) or: [ item isGroup and: [ item hasReductionExpression not ] ])				ifTrue: [ expansionCount := item possibilities * expansionCount.					item alternativesDo: [ :each | items addAll: (self combineItems: (self buildItemsFrom: each)) ] ]				ifFalse: [ items add: (Array with: item) ].			items ]! !!SmaCCGrammarCreator methodsFor: 'private'!createDefaultClassesForSymbol: aString	| className index |	className := aString capitalized.	[ index := className indexOf: $_.	index > 0 and: [ className size > 1 ] ]		whileTrue: [ className := (className copyFrom: 1 to: index - 1) , (className copyFrom: index + 1 to: className size) capitalized ].	className := className asSymbol.	defaultClasses do: [ :each | self createClass: className for: each ].	defaultClasses := OrderedCollection new! !!SmaCCGrammarCreator methodsFor: 'private'!combineItems: aCollection	| items |	items := OrderedCollection new.	self combineStream: (ReadStream on: aCollection) into: OrderedCollection new andDo: [ :each | items add: each ].	^ items! !!SmaCCGrammarCreator methodsFor: 'private'!reportErrorMessage: aString on: aSmaCCToken	SmaCCParserError new		messageText: aString;		tag: aSmaCCToken;		signal! !!SmaCCGrammarCreator methodsFor: 'initialize-release'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCGrammarCreator methodsFor: 'initialize-release'!initialize	super initialize.	defaultClasses := OrderedCollection new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCGrammarCreator class	instanceVariableNames: ''!!SmaCCGrammarCreator class methodsFor: 'building'!buildGrammar: aSmaCCGrammar from: aSmaCCDefinitionNode	self new		grammar: aSmaCCGrammar;		accept: aSmaCCDefinitionNode.	^ aSmaCCGrammar! !!SmaCCGrammarCreator class methodsFor: 'class initialization'!initialize	MaxExpansions := 16! !Object subclass: #SmaCCGrammarItem	instanceVariableNames: 'variableDefinitions grammar'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCGrammarItem commentStamp: '' prior: 0!SmaCCGrammarItem is an abstract class that represents something defined by the grammar.Subclasses must implement the following messages:	accessing		modelTypes:	private		annotateTokenVariables:		basicModelTypesForVariable:into:seen:		firstTerminalsInstance Variables	grammar	<SmaCCGrammar>	the grammar that we are defined in	variableDefinitions	<OrderedCollection of: SmaCCVariableDefinition>	the variables defined by this item!!SmaCCGrammarItem methodsFor: 'accessing'!modelTypes: anIdentitySet	^ self subclassResponsibility! !!SmaCCGrammarItem methodsFor: 'accessing'!modelTypes	^ self modelTypes: IdentitySet new! !!SmaCCGrammarItem methodsFor: 'accessing'!grammar	^ grammar! !!SmaCCGrammarItem methodsFor: 'accessing'!model	^ self grammar codeGenerator model! !!SmaCCGrammarItem methodsFor: 'testing'!returnsVariableCollection	^ false! !!SmaCCGrammarItem methodsFor: 'testing'!isSubtypeOf: aSmaCCGrammarItem	^ self modelType includesClass: aSmaCCGrammarItem modelType! !!SmaCCGrammarItem methodsFor: 'testing'!returnsSingleVariable	^ false! !!SmaCCGrammarItem methodsFor: 'variables'!hasVariableNamed: aString	^ self variableDefinitions		anySatisfy: [ :each | each variableName = aString ]! !!SmaCCGrammarItem methodsFor: 'variables'!computeVariableDefinitions	^ #()! !!SmaCCGrammarItem methodsFor: 'variables'!variableDefinitions	^ variableDefinitions ifNil: [ self computeVariableDefinitions ]! !!SmaCCGrammarItem methodsFor: 'variables'!collectionVariableDefinitions	^ self variableDefinitions select: [ :each | each isCollection ]! !!SmaCCGrammarItem methodsFor: 'variables'!isCollection: aString	^ self collectionVariableDefinitions		anySatisfy: [ :each | each variableName = aString ]! !!SmaCCGrammarItem methodsFor: 'variables'!indexOfVariable: aString	self variableDefinitions		keysAndValuesDo: [ :index :each | 			each variableName = aString				ifTrue: [ ^ index ] ].	self error: 'Variable not found'! !!SmaCCGrammarItem methodsFor: 'reduce actions'!isNode	^ self modelType includesClass: (self model classFor: SmaCCParseNode)! !!SmaCCGrammarItem methodsFor: 'reduce actions'!nodeType: anIdentitySet	| node rootType |	rootType := self modelType: anIdentitySet.	node := nil.	(rootType includesClass: (self model classNamed: #SmaCCParseNode))		ifTrue:			[ node := self grammar classDefinitions				detect: [ :e | e modelClass = rootType ]				ifNone: [ nil ] ].	^ node! !!SmaCCGrammarItem methodsFor: 'reduce actions'!modelType: anIdentitySet	| types |	types := self modelTypes: anIdentitySet.	^ self grammar codeGenerator commonSupertypeOf: types! !!SmaCCGrammarItem methodsFor: 'reduce actions'!modelType	^ self modelType: IdentitySet new! !!SmaCCGrammarItem methodsFor: 'reduce actions'!nodeType	^ self nodeType: IdentitySet new! !!SmaCCGrammarItem methodsFor: 'private'!modelTypesForVariable: aString	^ self modelTypesForVariable: aString seen: IdentitySet new! !!SmaCCGrammarItem methodsFor: 'private'!firstTerminals	^ self subclassResponsibility! !!SmaCCGrammarItem methodsFor: 'private'!modelTypesForVariable: aString seen: anIdentitySet	| productionTypes |	(anIdentitySet includes: self)		ifTrue: [ ^ #() ].	anIdentitySet add: self.	productionTypes := Set new.	self		basicModelTypesForVariable: aString		into: productionTypes		seen: anIdentitySet.	^ productionTypes! !!SmaCCGrammarItem methodsFor: 'private'!annotateTokenVariables: aBlock	self subclassResponsibility! !!SmaCCGrammarItem methodsFor: 'private'!basicModelTypesForVariable: aString into: aCollection seen: anIdentitySet	self subclassResponsibility! !!SmaCCGrammarItem methodsFor: 'initialize-release'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !SmaCCGrammarItem subclass: #SmaCCRHS	instanceVariableNames: 'collection variableNameMap nodeClassDefinition productionSymbol reduceCode'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCRHS methodsFor: 'testing'!hasNamedVariable	^ variableNameMap notEmpty! !!SmaCCRHS methodsFor: 'testing'!returnsVariableCollection	^ reduceCode returnsVariableCollection! !!SmaCCRHS methodsFor: 'testing'!hasReduceAction	^ reduceCode hasReduceAction! !!SmaCCRHS methodsFor: 'testing'!hasNodeClassDefinition	^ self nodeClassDefinition notNil! !!SmaCCRHS methodsFor: 'testing'!locallyDefinesVariable: aString	^ (self indexOfVariable: aString) notNil! !!SmaCCRHS methodsFor: 'testing'!returnsSingleVariable	^ reduceCode returnsSingleVariable! !!SmaCCRHS methodsFor: 'private'!variableNameForIndex: anInteger	variableNameMap		keysAndValuesDo: [ :key :value | 			(value includes: anInteger)				ifTrue: [ ^ key ] ].	^ nil! !!SmaCCRHS methodsFor: 'private'!collection	^ collection! !!SmaCCRHS methodsFor: 'private'!firstTerminals	| items |	collection isEmpty		ifTrue: [ ^ Set with: self grammar emptySymbol ].	items := Set new.	1 to: collection size do:		[ :index | 		items addAll: (collection at: index) firstTerminals.		(items includes: self grammar emptySymbol)			ifTrue:				[ index < collection size					ifTrue: [ items remove: self grammar emptySymbol ] ]			ifFalse: [ ^ items ] ].	^ items! !!SmaCCRHS methodsFor: 'private'!unnamedSymbolsDo: aBlock	self		variablesAndSymbolsDo: [ :var :each | 			var isNil				ifTrue: [ aBlock value: each ] ]! !!SmaCCRHS methodsFor: 'private'!variableNames	^ variableNameMap keys! !!SmaCCRHS methodsFor: 'private'!variablesAndSymbolsDo: aBlock	collection		keysAndValuesDo:			[ :key :value | aBlock value: (self variableNameForIndex: key) value: value ]! !!SmaCCRHS methodsFor: 'private'!annotateTokenVariables: aBlock	collection		keysAndValuesDo:			[ :i :each | 			(each isTerminal and: [ (self variableNameForIndex: i) isNil ])				ifTrue:					[ (aBlock value: each unsafeMethodName)						ifNotNil:							[ :value | 							(variableNameMap at: value ifAbsentPut: [ OrderedCollection new ])								add: i ] ] ]! !!SmaCCRHS methodsFor: 'private'!basicModelTypesForVariable: aString into: productionTypes seen: aSet	(self symbolsForVariableName: aString)		do:			[ :symbol | 			symbol returnsSingleVariable				ifTrue:					[ productionTypes						addAll: (symbol modelTypesForVariable: symbol variableName) ]				ifFalse: [ productionTypes addAll: symbol modelTypes ] ].	self		unnamedSymbolsDo:			[ :each | 			(each hasVariableNamed: aString)				ifTrue:					[ productionTypes						addAll: (each modelTypesForVariable: aString seen: aSet) ] ]! !!SmaCCRHS methodsFor: 'variables'!indexOfVariable: aString	^ (variableNameMap at: aString ifAbsent: [ ^ nil ]) first! !!SmaCCRHS methodsFor: 'initialize-release'!initialize	super initialize.	collection := OrderedCollection new.	reduceCode := SmaCCDefaultReduceCode onRHS: self.	variableNameMap := Dictionary new! !!SmaCCRHS methodsFor: 'initialize-release'!symbol: aSmaCCNonTerminalSymbol	productionSymbol := aSmaCCNonTerminalSymbol! !!SmaCCRHS methodsFor: 'accessing'!size	^ collection size! !!SmaCCRHS methodsFor: 'accessing'!nodeClassDefinition: aSmaCCNodeClassDefinition	nodeClassDefinition := aSmaCCNodeClassDefinition! !!SmaCCRHS methodsFor: 'accessing'!variableDefinitions: aCollection	variableDefinitions := aCollection.	SmaCCVariableDefinition assignIndices: variableDefinitions! !!SmaCCRHS methodsFor: 'accessing'!nameLastItem: aString	(variableNameMap at: aString ifAbsentPut: [ OrderedCollection new ])		add: collection size! !!SmaCCRHS methodsFor: 'accessing'!modelTypes: anIdentitySet	^ reduceCode modelTypes: anIdentitySet! !!SmaCCRHS methodsFor: 'accessing'!do: aBlock	collection do: aBlock! !!SmaCCRHS methodsFor: 'accessing'!nodeClassDefinition	^ nodeClassDefinition! !!SmaCCRHS methodsFor: 'accessing'!symbolsForVariableName: aString	| indices |	indices := variableNameMap at: aString ifAbsent: [ #() ].	^ indices collect: [ :i | self at: i ]! !!SmaCCRHS methodsFor: 'accessing'!ruleNumber	^ (productionSymbol ruleNumber bitShift: 10)		+ (productionSymbol positionOf: self)! !!SmaCCRHS methodsFor: 'accessing'!at: anInteger	^ collection at: anInteger! !!SmaCCRHS methodsFor: 'accessing'!productionSymbol	^ productionSymbol! !!SmaCCRHS methodsFor: 'accessing'!add: aSmaCCSymbol	collection add: aSmaCCSymbol! !!SmaCCRHS methodsFor: 'comparing'!= aSmaCCRHS	^ self class = aSmaCCRHS class		and: [ collection = aSmaCCRHS collection ]! !!SmaCCRHS methodsFor: 'comparing'!hash	^ self class hash hashMultiply bitXor: collection hash! !!SmaCCRHS methodsFor: 'reduce actions'!reduceCode	^ reduceCode! !!SmaCCRHS methodsFor: 'reduce actions'!generateNamedVariableCollectionWarningFor: problemIndex	| stream |	stream := WriteStream on: String new.	stream		nextPutAll:			'Non terminal symbol that returns a variable collection is assigned to a variable. The non terminal should be changed to return an AST node:';		cr;		cr;		nextPutAll: self productionSymbol name;		nextPutAll: ' : '.	1 to: self size do:		[ :i | 		i == problemIndex			ifTrue: [ stream nextPutAll: '>>>' ].		stream nextPutAll: (self at: i) name.		i == problemIndex			ifTrue: [ stream nextPutAll: '<<<' ].		stream space ].	SmaCCCompilationNotification new		messageText: 'Node creation';		tag: stream contents;		signal! !!SmaCCRHS methodsFor: 'reduce actions'!componentIndex	collection		keysAndValuesDo:			[ :index :each | 			((self variableNameForIndex: index) isNil				and: [ each isSubtypeOf: self ])				ifTrue: [ ^ index ] ].	^ 0! !!SmaCCRHS methodsFor: 'reduce actions'!reduceCodeSource: aString	reduceCode := SmaCCSourceReduceCode onRHS: self source: aString! !!SmaCCRHS methodsFor: 'reduce actions'!reduceCode: aSmaCCReduceCode	reduceCode := aSmaCCReduceCode! !!SmaCCRHS methodsFor: 'reduce actions'!generateUnnamedSymbolWarningFor: problemIndex	| stream |	stream := WriteStream on: String new.	stream		nextPutAll:			'Unnamed symbol in production. Without a variable name the value will be dropped from the parsed AST.';		cr;		cr;		nextPutAll: self productionSymbol name;		nextPutAll: ' : '.	1 to: self size do:		[ :i | 		i == problemIndex			ifTrue: [ stream nextPutAll: '>>>' ].		stream nextPutAll: (self at: i) name.		i == problemIndex			ifTrue: [ stream nextPutAll: '<<<' ].		stream space ].	SmaCCCompilationNotification new		messageText: 'Node creation';		tag: stream contents;		signal! !!SmaCCRHS methodsFor: 'printing'!printOn: aStream	^ collection		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream space ]! !Object subclass: #SmaCCScannerDefinition	instanceVariableNames: 'tokens states excludeStates'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCScannerDefinition methodsFor: 'initialize-release'!initialize	super initialize.	tokens := Dictionary new.	states := Set with: self defaultState.	excludeStates := Set new! !!SmaCCScannerDefinition methodsFor: 'accessing'!tokens	^ tokens! !!SmaCCScannerDefinition methodsFor: 'accessing'!nonExcludeStates	| nonExcludeStates |	nonExcludeStates := states		reject: [ :each | self isExcludeState: each ].	nonExcludeStates add: self defaultState.	^ nonExcludeStates! !!SmaCCScannerDefinition methodsFor: 'accessing'!addState: aSymbol	states add: aSymbol! !!SmaCCScannerDefinition methodsFor: 'accessing'!addExcludeState: aSymbol	excludeStates add: aSymbol.	self addState: aSymbol! !!SmaCCScannerDefinition methodsFor: 'accessing'!states	^ states! !!SmaCCScannerDefinition methodsFor: 'accessing'!addToken: aSmaCCRENode withName: aString	tokens at: aString put: aSmaCCRENode! !!SmaCCScannerDefinition methodsFor: 'accessing'!defaultState	^ #default! !!SmaCCScannerDefinition methodsFor: 'accessing'!tokenNamed: aString	^ tokens at: aString! !!SmaCCScannerDefinition methodsFor: 'accessing'!tokenNamed: aString ifAbsentPut: aBlock	^ tokens at: aString ifAbsentPut: aBlock! !!SmaCCScannerDefinition methodsFor: 'testing'!includesTokenNamed: aString	^ tokens includesKey: aString! !!SmaCCScannerDefinition methodsFor: 'testing'!isExcludeState: aSymbol	^ excludeStates includes: aSymbol! !SmaCCGrammarItem subclass: #SmaCCSymbol	instanceVariableNames: 'name precedence firstTerminals'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCSymbol commentStamp: '' prior: 0!SmaCCSymbol is an abstract class that represents a symbol in our grammar. Symbols can be either terminal or non-terminal. Terminal symbols are mapped to tokens in the grammar and non-terminals are made up of other symbols.Subclasses must implement the following messages:	accessing		calculateFirstTerminals	testing		isTerminalInstance Variables	firstTerminals	<Set of: SmaCCTerminalSymbol>	the first terminal symbol that this can produce	name	<String>	the name of the symbol	precedence	<Integer>	the precedence for the symbol used for shift/reduce conflicts!!SmaCCSymbol methodsFor: 'variables'!computeVariableDefinitions	| variableCollections |	variableCollections := OrderedCollection new.	self		productionsDo: [ :each | variableCollections add: each variableDefinitions ].	variableDefinitions := self class		mergeOrderedVariableDefinitions: variableCollections.	SmaCCVariableDefinition assignIndices: variableDefinitions.	^ variableDefinitions! !!SmaCCSymbol methodsFor: 'private'!annotateTokenVariables: aBlock	self productionsDo: [ :each | each annotateTokenVariables: aBlock ]! !!SmaCCSymbol methodsFor: 'private'!basicModelTypesForVariable: aString into: productionTypes seen: aSet	self		productionsDo:			[ :each | 			productionTypes				addAll: (each modelTypesForVariable: aString seen: aSet) ]! !!SmaCCSymbol methodsFor: 'private'!unsafeMethodName	^ self printString! !!SmaCCSymbol methodsFor: 'private'!makeCaseInsensitive	! !!SmaCCSymbol methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: name! !!SmaCCSymbol methodsFor: 'initialize-release'!initialize	super initialize.	firstTerminals := Set new! !!SmaCCSymbol methodsFor: 'initialize-release'!name: aString	name := aString! !!SmaCCSymbol methodsFor: 'testing'!isStartingSymbol	^ false! !!SmaCCSymbol methodsFor: 'testing'!isTerminal	^ self subclassResponsibility! !!SmaCCSymbol methodsFor: 'testing'!requiresNodeType	self		productionsDo: [ :each | 			each hasNodeClassDefinition				ifTrue: [ ^ true ] ].	^ false! !!SmaCCSymbol methodsFor: 'testing'!< aSmaCCSymbol	| myPos otherPos |	myPos := self position.	otherPos := aSmaCCSymbol position.	^ myPos = otherPos		ifTrue: [ self name < aSmaCCSymbol name ]		ifFalse: [ myPos < otherPos ]! !!SmaCCSymbol methodsFor: 'accessing'!size	^ 0! !!SmaCCSymbol methodsFor: 'accessing'!precedence	^ precedence! !!SmaCCSymbol methodsFor: 'accessing'!position	^ self subclassResponsibility! !!SmaCCSymbol methodsFor: 'accessing'!name	^ name! !!SmaCCSymbol methodsFor: 'accessing'!firstTerminals	^ firstTerminals! !!SmaCCSymbol methodsFor: 'accessing'!calculateFirstTerminals	^ self subclassResponsibility! !!SmaCCSymbol methodsFor: 'accessing'!isEmptySymbol	^ self = grammar emptySymbol! !!SmaCCSymbol methodsFor: 'accessing'!precedence: anInteger	precedence := anInteger! !!SmaCCSymbol methodsFor: 'accessing'!createIdMethod	^ false! !!SmaCCSymbol methodsFor: 'accessing'!productionsDo: aBlock	! !!SmaCCSymbol methodsFor: 'accessing'!regularExpression	^ nil! !!SmaCCSymbol methodsFor: 'accessing'!safeMethodName	^ self unsafeMethodName		collect: [ :each | 			each isAlphaNumeric				ifTrue: [ each ]				ifFalse: [ $_ ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSymbol class	instanceVariableNames: ''!!SmaCCSymbol class methodsFor: 'variables'!mergeOrderedVariableDefinitions: newVariableDefinitions	| result |	result := OrderedCollection new.	newVariableDefinitions		do: [ :collection | self mergeVariableDefinitions: collection into: result ].	^ result! !!SmaCCSymbol class methodsFor: 'variables'!mergeVariableDefinitions: collection into: result	collection		do:			[ :each | 			| variable |			variable := result				detect: [ :def | def variableName = each variableName ]				ifNone: [ result add: each copy ].			each getterMethodName notNil				ifTrue: [ variable getterMethodName: each getterMethodName ].			each setterMethodName notNil				ifTrue: [ variable setterMethodName: each setterMethodName ].			each isCollection				ifTrue: [ variable isCollection: true ] ]! !!SmaCCSymbol class methodsFor: 'instance creation'!name: aString	^ self new		name: aString;		yourself! !SmaCCSymbol subclass: #SmaCCNonTerminalSymbol	instanceVariableNames: 'productions position'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCNonTerminalSymbol methodsFor: 'testing'!returnsVariableCollection	^ productions anySatisfy: [ :each | each returnsVariableCollection ]! !!SmaCCNonTerminalSymbol methodsFor: 'testing'!isEmpty	^ productions isEmpty! !!SmaCCNonTerminalSymbol methodsFor: 'testing'!isTerminal	^ false! !!SmaCCNonTerminalSymbol methodsFor: 'testing'!returnsSingleVariable	^ productions anySatisfy: [ :each | each returnsSingleVariable ]! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!positionOf: aSmaCCRHS	^ productions indexOf: aSmaCCRHS! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!position: anInteger	position ifNil: [ position := anInteger ]! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!size	^ productions size! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!position	^ (position ifNil: [ 0 ]) + 10000000! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!modelTypes: anIdentitySet	| types |	(anIdentitySet includes: self)		ifTrue: [ ^ #() ].	anIdentitySet add: self.	types := Set new.	productions		do: [ :each | types addAll: (each modelTypes: anIdentitySet) ].	anIdentitySet remove: self.	^ types! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!calculateFirstTerminals	| initialSize |	initialSize := firstTerminals size.	productions isEmpty		ifTrue: [ firstTerminals add: grammar emptySymbol ]		ifFalse: [ productions				do: [ :each | firstTerminals addAll: each firstTerminals ] ].	^ initialSize ~= firstTerminals size! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!variableName	self		productionsDo:			[ :each | 			| vars |			vars := each variableNames asArray.			vars notEmpty				ifTrue: [ ^ vars first ] ].	^ self		error:			'No variable found -- should only be called when returnsSingleVariable is true'! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!ruleNumber	^ position ifNil: [ 0 ]! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!addProduction: aSmaCCRHS	productions add: aSmaCCRHS.	aSmaCCRHS symbol: self! !!SmaCCNonTerminalSymbol methodsFor: 'accessing'!productionsDo: aBlock	productions do: aBlock! !!SmaCCNonTerminalSymbol methodsFor: 'initialize-release'!initialize	super initialize.	productions := OrderedCollection new! !SmaCCNonTerminalSymbol subclass: #SmaCCStartingSymbol	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCStartingSymbol methodsFor: 'public'!symbol	^ productions first at: 1! !!SmaCCStartingSymbol methodsFor: 'testing'!isStartingSymbol	^ true! !!SmaCCStartingSymbol methodsFor: 'accessing'!asLRItemSet	| itemSet |	itemSet := self grammar newItemSet.	productions		do:			[ :each | 			itemSet				add:					(SmaCCLR1Item						rhs: each						follow:							(SmaCCSymbolSet new								add: grammar emptySymbol;								yourself)) ].	^ itemSet! !!SmaCCStartingSymbol methodsFor: 'accessing'!compileName	^ (productions first at: 1) safeMethodName! !SmaCCSymbol subclass: #SmaCCTerminalSymbol	instanceVariableNames: 'regularExpression createIdMethod'	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCTerminalSymbol methodsFor: 'testing'!isTerminal	^ true! !!SmaCCTerminalSymbol methodsFor: 'initialize-release'!initialize	super initialize.	firstTerminals add: self.	createIdMethod := false! !!SmaCCTerminalSymbol methodsFor: 'private'!unsafeMethodName	^ name copyFrom: 2 to: name size - 1! !!SmaCCTerminalSymbol methodsFor: 'private'!calculateFirstTerminals	^ false! !!SmaCCTerminalSymbol methodsFor: 'private'!makeCaseInsensitive	regularExpression notNil		ifTrue: [ regularExpression makeCaseInsensitive ]! !!SmaCCTerminalSymbol methodsFor: 'accessing'!regularExpression: aSmaCCRegularExpressionNode	regularExpression := aSmaCCRegularExpressionNode! !!SmaCCTerminalSymbol methodsFor: 'accessing'!createIdMethod	^ createIdMethod! !!SmaCCTerminalSymbol methodsFor: 'accessing'!position	^ self regularExpression ifNil: [ SmallInteger maxVal ] ifNotNil: [ :re | re position ifNil: [ 0 ] ]! !!SmaCCTerminalSymbol methodsFor: 'accessing'!createIdMethod: aBoolean	createIdMethod := aBoolean! !!SmaCCTerminalSymbol methodsFor: 'accessing'!regularExpression	^ regularExpression! !!SmaCCTerminalSymbol methodsFor: 'accessing'!modelTypes: anIdentitySet	^ Set with: (self model classFor: SmaCCToken)! !SmaCCTerminalSymbol subclass: #SmaCCErrorTerminalSymbol	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Model'!!SmaCCErrorTerminalSymbol methodsFor: 'accessing'!modelTypes: anIdentitySet	^ Set with: (self model classFor: SmaCCErrorNode)! !SmaCCGrammar initialize!SmaCCGrammarCreator initialize!Set subclass: #SmaCCItemSet	instanceVariableNames: 'type previousItemSets grammar'	classVariableNames: ''	package: 'SmaCC_Development-Item Sets'!!SmaCCItemSet methodsFor: 'initialize-release'!initialize	(self class superclass canUnderstand: #initialize)		ifTrue: [ super initialize ].	type := #LALR1.	previousItemSets := OrderedCollection new! !!SmaCCItemSet methodsFor: 'initialize-release'!type: aSymbol	type := aSymbol! !!SmaCCItemSet methodsFor: 'testing'!isLALREqualTo: aSmaCCItemSet	^ aSmaCCItemSet size = self size		and: [ self allSatisfy: [ :each | aSmaCCItemSet includes: each ] ]! !!SmaCCItemSet methodsFor: 'testing'!isLREqualTo: anItemSet	^ anItemSet size = self size		and:			[ self				allSatisfy:					[ :each | 					| item |					(item := anItemSet itemFor: each) notNil						and: [ each isLR1EqualTo: item ] ] ]! !!SmaCCItemSet methodsFor: 'adding'!add: aSmaCCLR1Item	| index item |	aSmaCCLR1Item isNil		ifTrue: [ ^ aSmaCCLR1Item ].	index := self findElementOrNil: aSmaCCLR1Item.	item := array at: index.	item isNil		ifTrue:			[ self atNewIndex: index put: aSmaCCLR1Item.			aSmaCCLR1Item itemSet: self.			self performClosureOn: aSmaCCLR1Item ]		ifFalse: [ item mergeWith: aSmaCCLR1Item ].	^ aSmaCCLR1Item! !!SmaCCItemSet methodsFor: 'private'!performClosureOn: aSmaCCLR1Item	| nextSymbol rest first followers |	nextSymbol := aSmaCCLR1Item nextSymbol.	nextSymbol isTerminal		ifTrue: [ ^ self ].	rest := aSmaCCLR1Item rest.	first := rest firstTerminals.	followers := SmaCCSymbolSet new.	(first includes: grammar emptySymbol)		ifTrue:			[ first remove: grammar emptySymbol.			followers baseOn: aSmaCCLR1Item followers ].	followers addAll: first.	nextSymbol		productionsDo: [ :each | self add: (SmaCCLR1Item rhs: each follow: followers) ]! !!SmaCCItemSet methodsFor: 'private'!itemFor: anObject	^ array at: (self findElementOrNil: anObject)! !!SmaCCItemSet methodsFor: 'comparing'!= aSmaCCItemSet	self class = aSmaCCItemSet class		ifTrue:			[ type == #LALR1				ifTrue: [ ^ self isLALREqualTo: aSmaCCItemSet ]				ifFalse: [ ^ self isLREqualTo: aSmaCCItemSet ] ].	^ false! !!SmaCCItemSet methodsFor: 'comparing'!hash	^ self		inject: self class hash		into: [ :sum :each | sum bitXor: each hash ]! !!SmaCCItemSet methodsFor: 'printing'!printOn: aStream	| strings |	strings := OrderedCollection new: self size.	self do: [ :each | strings add: each printString ].	strings asSortedCollection		do: [ :each | 			aStream				tab;				nextPutAll: each;				cr ]! !!SmaCCItemSet methodsFor: 'accessing'!mergeWith: aSmaCCItemSet	self == aSmaCCItemSet		ifTrue: [ ^ self ].	self addAll: aSmaCCItemSet.	previousItemSets addAll: aSmaCCItemSet previousItemSets! !!SmaCCItemSet methodsFor: 'accessing'!previousItemSets	^ previousItemSets! !!SmaCCItemSet methodsFor: 'accessing'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCItemSet methodsFor: 'accessing'!grammar	^ grammar! !!SmaCCItemSet methodsFor: 'accessing'!pathInto: anOrderedCollection	| item |	self previousState isNil		ifTrue: [ ^ self ].	self previousState pathInto: anOrderedCollection.	item := self detect: [ :each | each location > 1 ].	anOrderedCollection add: (item rhs at: item location - 1)! !!SmaCCItemSet methodsFor: 'accessing'!previousItemSets: aCollection	previousItemSets := aCollection! !!SmaCCItemSet methodsFor: 'accessing'!action: aSmaCCSymbol prefer: aClass	| action |	action := nil.	self		do:			[ :each | 			| eachAction |			eachAction := each action: aSmaCCSymbol.			action := action isNil				ifTrue: [ eachAction ]				ifFalse: [ action mergeWith: eachAction prefer: aClass ] ].	action signalAllWarnings.	^ action! !!SmaCCItemSet methodsFor: 'accessing'!addPrevious: aSmaCCItemSet	previousItemSets add: aSmaCCItemSet! !!SmaCCItemSet methodsFor: 'accessing'!moveOn: aSmaCCSymbol	| anItemSet |	anItemSet := self class new.	anItemSet grammar: grammar.	anItemSet addPrevious: self.	anItemSet type: type.	self		do:			[ :each | 			each nextSymbol == aSmaCCSymbol				ifTrue: [ anItemSet add: each moveNext ] ].	^ anItemSet! !!SmaCCItemSet methodsFor: 'accessing'!path	| result |	result := OrderedCollection new.	self pathInto: result.	^ result! !!SmaCCItemSet methodsFor: 'accessing'!previousState	"Pick some previous item set"	previousItemSets isEmpty		ifTrue: [ ^ nil ].	^ previousItemSets first! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCItemSet class	instanceVariableNames: ''!!SmaCCItemSet class methodsFor: 'instance creation'!new: anInteger	^ (super new: anInteger)		initialize;		yourself! !!SmaCCItemSet class methodsFor: 'instance creation'!new	^self new: 5! !Object subclass: #SmaCCLR1Item	instanceVariableNames: 'rhs location followers itemSet'	classVariableNames: ''	package: 'SmaCC_Development-Item Sets'!!SmaCCLR1Item methodsFor: 'testing'!isLR1EqualTo: aSmaCCLR1Item	^ self followers size = aSmaCCLR1Item followers size		and:			[ self followers				allSatisfy: [ :each | aSmaCCLR1Item followers includes: each ] ]! !!SmaCCLR1Item methodsFor: 'comparing'!= aSmaCCLR1Item	^ self class == aSmaCCLR1Item class		and:			[ location = aSmaCCLR1Item location				and: [ rhs == aSmaCCLR1Item rhs						and: [ self symbol == aSmaCCLR1Item symbol ] ] ]! !!SmaCCLR1Item methodsFor: 'comparing'!hash	^ (self symbol identityHash hashMultiply bitXor: location)		hashMultiply bitXor: rhs identityHash! !!SmaCCLR1Item methodsFor: 'printing'!printOn: aStream	| i |	aStream		nextPut: $[;		nextPutAll: self symbol printString;		nextPutAll: ' :'.	i := 1.	rhs		do:			[ :each | 			i = location				ifTrue: [ aStream nextPutAll: ' . ' ].			aStream				space;				nextPutAll: each printString.			i := i + 1 ].	location > rhs size		ifTrue: [ aStream nextPutAll: ' . ' ].	aStream nextPut: $;.	followers printOn: aStream.	aStream nextPut: $]! !!SmaCCLR1Item methodsFor: 'accessing'!mergeWith: aSmaCCLR1Item	followers mergeWith: aSmaCCLR1Item followers! !!SmaCCLR1Item methodsFor: 'accessing'!precedence	| max |	self isAtEnd		ifTrue:			[ max := -1.	"If we don't have a precedence, then assume we are the lowest precedence (which will cause a shift action)."			rhs				do: [ :each | max := max max: (each precedence ifNil: [ max ]) ].			^ max ]		ifFalse: [ ^ (rhs at: location) precedence ]! !!SmaCCLR1Item methodsFor: 'accessing'!itemSet: aSmaCCItemSet	itemSet := aSmaCCItemSet! !!SmaCCLR1Item methodsFor: 'accessing'!grammar	^ rhs grammar! !!SmaCCLR1Item methodsFor: 'accessing'!symbol	^ self rhs productionSymbol! !!SmaCCLR1Item methodsFor: 'accessing'!isAtEnd	^ location > rhs size! !!SmaCCLR1Item methodsFor: 'accessing'!action: aSmaCCSymbol	self isAtEnd		ifTrue:			[ (self symbol isStartingSymbol and: [ aSmaCCSymbol isEmptySymbol ])				ifTrue: [ ^ SmaCCAcceptAction item: self ].			(followers includes: aSmaCCSymbol)				ifTrue: [ ^ SmaCCReduceAction item: self ] ]		ifFalse:			[ (rhs at: location) = aSmaCCSymbol				ifTrue: [ ^ SmaCCShiftAction item: self ] ].	^ SmaCCRejectAction item: self! !!SmaCCLR1Item methodsFor: 'accessing'!rest	| newRHS |	newRHS := self grammar newRHS.	location + 1 to: rhs size do: [ :each | newRHS add: (rhs at: each) ].	^ newRHS! !!SmaCCLR1Item methodsFor: 'accessing'!moveNext	^ self copy		followers: (followers class basedOn: followers);		location: location + 1;		yourself! !!SmaCCLR1Item methodsFor: 'accessing'!followers	^ followers! !!SmaCCLR1Item methodsFor: 'accessing'!location	^ location! !!SmaCCLR1Item methodsFor: 'accessing'!path	^ itemSet path! !!SmaCCLR1Item methodsFor: 'accessing'!nextSymbol	^ location > rhs size		ifTrue: [ self grammar sentinelSymbol ]		ifFalse: [ rhs at: location ]! !!SmaCCLR1Item methodsFor: 'accessing'!rhs	^ rhs! !!SmaCCLR1Item methodsFor: 'initialize-release'!rhs: aSmaCCRHS follow: aSmaCCSymbolCollection	rhs := aSmaCCRHS.	location := 1.	followers := aSmaCCSymbolCollection! !!SmaCCLR1Item methodsFor: 'initialize-release'!followers: aSmaCCSymbolSet	followers := aSmaCCSymbolSet! !!SmaCCLR1Item methodsFor: 'initialize-release'!location: anInteger	location := anInteger! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCLR1Item class	instanceVariableNames: ''!!SmaCCLR1Item class methodsFor: 'instance creation'!rhs: aSmaCCRHS follow: aSmaCCSymbolCollection	^ self new		rhs: aSmaCCRHS follow: aSmaCCSymbolCollection;		yourself! !Object subclass: #SmaCCSymbolTableIndex	instanceVariableNames: 'index symbol'	classVariableNames: ''	package: 'SmaCC_Development-Item Sets'!!SmaCCSymbolTableIndex methodsFor: 'accessing'!symbol: anObject	symbol := anObject! !!SmaCCSymbolTableIndex methodsFor: 'accessing'!symbol	^ symbol! !!SmaCCSymbolTableIndex methodsFor: 'accessing'!index	^ index! !!SmaCCSymbolTableIndex methodsFor: 'accessing'!index: anObject	index := anObject! !!SmaCCSymbolTableIndex methodsFor: 'comparing'!= anObject	^ self class = anObject class		and: [ self index = anObject index and: [ self symbol = anObject symbol ] ]! !!SmaCCSymbolTableIndex methodsFor: 'comparing'!hash	^ index hashMultiply bitXor: symbol hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSymbolTableIndex class	instanceVariableNames: ''!!SmaCCSymbolTableIndex class methodsFor: 'instance creation'!forIndex: anInteger symbol: aSmaCCSymbol	^ self new		index: anInteger;		symbol: aSmaCCSymbol;		yourself! !Object subclass: #SmaCCEdge	instanceVariableNames: 'toNode transitionObjects'	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCEdge commentStamp: '' prior: 0!SmaCCEdge is an edge in the DFA/NFA for the scanner. It contains the objects (characters or symbols) that we transition on and the node we transition to.Subclasses must implement the following messages:	private		dispatchTo:seen:Instance Variables:	toNode	<SmaCCNode>	the next node in the graph	transitionObjects	<Collection of: (Character | Symbol))>	the characters or states that we transition on!!SmaCCEdge methodsFor: 'accessing'!to	^ toNode! !!SmaCCEdge methodsFor: 'accessing'!transitionObjects	^ transitionObjects! !!SmaCCEdge methodsFor: 'accessing'!setClass	^ Set! !!SmaCCEdge methodsFor: 'initialize-release'!to: aSmaCCNode	toNode := aSmaCCNode! !!SmaCCEdge methodsFor: 'initialize-release'!to: aSmaCCNode on: aStringOrNil	toNode := aSmaCCNode.	transitionObjects := aStringOrNil! !!SmaCCEdge methodsFor: 'merging'!mergeWith: aSmaCCEdge	transitionObjects := Array		withAll:			(transitionObjects , aSmaCCEdge transitionObjects) asSet				asSortedCollection! !!SmaCCEdge methodsFor: 'compiling'!dispatchTo: aSmaCCCodeGenerator seen: aCollection	^ self subclassResponsibility! !!SmaCCEdge methodsFor: 'compiling'!codeSizeEstimate	"Estimate how many bytecodes will be used to generate the comparison."	^ self subclassResponsibility! !!SmaCCEdge methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: '---';		nextPutAll: self edgeLabel;		nextPutAll: '--->';		nextPutAll: toNode printString! !!SmaCCEdge methodsFor: 'printing'!edgeLabel	^ transitionObjects isNil		ifTrue: [ 'epsilon' ]		ifFalse:			[ transitionObjects				inject: ''				into: [ :sum :each | sum , each printString ] ]! !!SmaCCEdge methodsFor: 'testing'!isEpsilonTransition	^ transitionObjects isNil! !!SmaCCEdge methodsFor: 'testing'!isCharacterTransition	^ false! !!SmaCCEdge methodsFor: 'testing'!isEmpty	^ transitionObjects isEmpty! !!SmaCCEdge methodsFor: 'testing'!includes: anObject	^ transitionObjects notNil and: [ transitionObjects includes: anObject ]! !!SmaCCEdge methodsFor: 'testing'!canMergeWith: aSmaCCEdge	^ self class = aSmaCCEdge class! !!SmaCCEdge methodsFor: 'private'!remove: aCollection	transitionObjects := transitionObjects		reject: [ :each | aCollection includes: each ]! !!SmaCCEdge methodsFor: 'comparing'!= aSmaCCEdge	^ self class = aSmaCCEdge class		and:			[ self to = aSmaCCEdge to				and: [ self transitionObjects = aSmaCCEdge transitionObjects ] ]! !!SmaCCEdge methodsFor: 'comparing'!hash	^ self to hash hashMultiply bitXor: transitionObjects hash! !!SmaCCEdge methodsFor: 'comparing'!<= aSmaCCEdge	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCEdge class	instanceVariableNames: ''!!SmaCCEdge class methodsFor: 'instance creation'!to: aSmaCCNode on: aCollectionOrNil	| edge |	edge := self new.	edge to: aSmaCCNode on: aCollectionOrNil.	^ edge! !SmaCCEdge subclass: #SmaCCCharacterEdge	instanceVariableNames: 'codeSizeEstimate'	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCCharacterEdge commentStamp: '' prior: 0!SmaCCCharacterEdge is a SmaCCEdge for Characters.!!SmaCCCharacterEdge methodsFor: 'compiling'!dispatchTo: aSmaCCCodeGenerator seen: aCollection	^ aSmaCCCodeGenerator acceptCharacterEdge: self seen: aCollection! !!SmaCCCharacterEdge methodsFor: 'compiling'!codeSizeEstimate	^ codeSizeEstimate		ifNil: [ | last size |			size := 1.			last := transitionObjects first asInteger - 1.			transitionObjects				do: [ :each | 					each asInteger - 1 = last						ifFalse: [ size := size + 1 ].					last := each asInteger ].			codeSizeEstimate := size * 8 + 4 ]! !!SmaCCCharacterEdge methodsFor: 'private'!remove: aCollection	transitionObjects := transitionObjects copy.	transitionObjects smaccRemoveAll: aCollection! !!SmaCCCharacterEdge methodsFor: 'initialize-release'!to: aSmaCCNode on: aStringOrNil	toNode := aSmaCCNode.	transitionObjects := aStringOrNil notNil		ifTrue: [ SmaCCCharacterSet withAll: aStringOrNil ]		ifFalse: [ nil ]! !!SmaCCCharacterEdge methodsFor: 'accessing'!setClass	^ SmaCCCharacterSet! !!SmaCCCharacterEdge methodsFor: 'comparing'!<= aSmaCCEdge	^ self class = aSmaCCEdge class		and: [ self transitionObjects <= aSmaCCEdge transitionObjects ]! !!SmaCCCharacterEdge methodsFor: 'printing'!edgeLabel	^ transitionObjects asString! !!SmaCCCharacterEdge methodsFor: 'testing'!isCharacterTransition	^ true! !!SmaCCCharacterEdge methodsFor: 'merging'!mergeWith: aSmaCCEdge	transitionObjects := transitionObjects copy.	transitionObjects addAll: aSmaCCEdge transitionObjects! !Object subclass: #SmaCCGraphAlgorithm	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCGraphAlgorithm methodsFor: 'nodes'!mergeActionsFrom: nodeCollection into: aSmaCCNode	nodeCollection do: [ :each | aSmaCCNode addActions: each action ]! !!SmaCCGraphAlgorithm methodsFor: 'nodes'!mergeTransitionsFrom: nodeCollection into: aSmaCCNode	| transitions |	transitions := Set new.	nodeCollection		do: [ :each | each transitions do: [ :edge | transitions add: edge copy ] ].	aSmaCCNode transitions: transitions.	aSmaCCNode mergeTransitions! !!SmaCCGraphAlgorithm methodsFor: 'nodes'!createMergedNodeFrom: nodeCollection	| newNode |	newNode := SmaCCNode new.	self mergeTransitionsFrom: nodeCollection into: newNode.	self mergeActionsFrom: nodeCollection into: newNode.	^ newNode! !SmaCCGraphAlgorithm subclass: #SmaCCDuplicateNodeEliminator	instanceVariableNames: 'comparisonState root'	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCDuplicateNodeEliminator commentStamp: '' prior: 0!SmaCCDuplicateNodeEliminator removes duplicate nodes from a scanner's DFA.Instance Variables:	comparisonState	<Dictionary>	a dictionary of "equal" objects when testing nodes for equality	root	<SmaCCNode>	the root node for the DFA!!SmaCCDuplicateNodeEliminator methodsFor: 'private'!pairsDo: aBlock	| nodes |	nodes := root allStates asSortedCollection.	1 to: nodes size - 1 do:		[ :i | i + 1 to: nodes size do: [ :j | aBlock value: (nodes at: i) value: (nodes at: j) ] ]! !!SmaCCDuplicateNodeEliminator methodsFor: 'testing'!isNode: firstSmaCCNode equivalentTo: secondSmaCCNode	firstSmaCCNode = secondSmaCCNode		ifTrue: [ ^ true ].	firstSmaCCNode transitions size = secondSmaCCNode transitions size		ifFalse: [ ^ false ].	firstSmaCCNode action = secondSmaCCNode action		ifFalse: [ ^ false ].	((comparisonState at: firstSmaCCNode ifAbsent: [ #() ])		includes: secondSmaCCNode)		ifTrue: [ ^ true ].	(comparisonState at: firstSmaCCNode ifAbsentPut: [ Set new ])		add: secondSmaCCNode.	(comparisonState at: secondSmaCCNode ifAbsentPut: [ Set new ])		add: firstSmaCCNode.	firstSmaCCNode sortedTransitions		with: secondSmaCCNode sortedTransitions		do:			[ :first :second | 			first transitionObjects = second transitionObjects				ifFalse: [ ^ false ].			(self isNode: first to equivalentTo: second to)				ifFalse: [ ^ false ] ].	^ true! !!SmaCCDuplicateNodeEliminator methodsFor: 'graph copying'!copyGraph	| map |	map := Dictionary new.	self copyNodesInto: map.	self copyEdgesWith: map.	^ map at: root! !!SmaCCDuplicateNodeEliminator methodsFor: 'graph copying'!copyNodesInto: aDictionary	root allStates		do: [ :each | aDictionary at: each put: each shallowCopy ]! !!SmaCCDuplicateNodeEliminator methodsFor: 'graph copying'!copyEdgesWith: aDictionary	| todo |	todo := OrderedCollection with: root.	[ todo notEmpty ]		whileTrue:			[ | node |			node := todo removeFirst.			(aDictionary at: node)				transitions:					(node sortedTransitions						do:							[ :each | 							| copy |							copy := each copy.							copy to: (aDictionary at: each to).							copy ]) ]! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm'!mergeAllTransitions	root allStates do: [ :each | each mergeTransitions ]! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm'!removeDuplicateNodesIn: aSmaCCNode	root := aSmaCCNode.	self removeDuplicates.	self copyGraph.	^ root! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm'!mergeNodeUsing: aDictionary	| seen todo mappings |	mappings := Dictionary new.	aDictionary		keysAndValuesDo: [ :key :value | value do: [ :each | mappings at: each put: key ] ].	seen := IdentitySet new.	todo := OrderedCollection with: root.	[ todo notEmpty ]		whileTrue:			[ | node mergedNode |			node := todo removeFirst.			node transitions				do:					[ :each | 					(seen includes: each to)						ifFalse: [ todo add: each to.							seen add: each to ] ].			mergedNode := mappings at: node ifAbsent: [ nil ].			mergedNode notNil				ifTrue: [ node mergeWith: mergedNode ] ]! !!SmaCCDuplicateNodeEliminator methodsFor: 'algorithm'!removeDuplicates	| toMerge |	[ toMerge := Dictionary new.	self mergeAllTransitions.	self		pairsDo:			[ :firstNode :secondNode | 			comparisonState := Dictionary new.			(self isNode: firstNode equivalentTo: secondNode)				ifTrue: [ (toMerge at: firstNode ifAbsentPut: [ Set new ])						add: secondNode ] ].	toMerge notEmpty ]		whileTrue:			[ toMerge values				do: [ :each | each do: [ :node | toMerge removeKey: node ifAbsent: [  ] ] ].			self mergeNodeUsing: toMerge ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDuplicateNodeEliminator class	instanceVariableNames: ''!!SmaCCDuplicateNodeEliminator class methodsFor: 'algorithm'!removeDuplicateNodesIn: aSmaCCNode	^ self new removeDuplicateNodesIn: aSmaCCNode! !SmaCCGraphAlgorithm subclass: #SmaCCEpsilonRemoval	instanceVariableNames: 'nodeMap'	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCEpsilonRemoval commentStamp: '' prior: 0!SmaCCEpsilonRemoval removes all epsilon edges from the scanner's NFA.Instance Variables:	nodeMap	<Dictionary key: SmaCCNode value: SmaCCNode>	map from nodes in old graph to nodes in new graph!!SmaCCEpsilonRemoval methodsFor: 'initialize-release'!initialize	super initialize.	nodeMap := Dictionary new! !!SmaCCEpsilonRemoval methodsFor: 'algorithm'!epsilonReachableNodesFrom: aSmaCCNode	| todo reachable node |	reachable := Set with: aSmaCCNode.	todo := OrderedCollection with: aSmaCCNode.	[ todo notEmpty ]		whileTrue:			[ node := todo removeLast.			node transitions				do:					[ :each | 					(each isEpsilonTransition and: [ (reachable includes: each to) not ])						ifTrue: [ reachable add: each to.							todo add: each to ] ] ].	^ reachable! !!SmaCCEpsilonRemoval methodsFor: 'algorithm'!removeEpsilonEdgesFrom: aSmaCCNode	^ nodeMap		at: aSmaCCNode		ifAbsent: [ self createNodeWithoutEpsilonEdges: aSmaCCNode ]! !!SmaCCEpsilonRemoval methodsFor: 'algorithm'!createNodeWithoutEpsilonEdges: aSmaCCNode	| newNode newTransitions |	newNode := self		createMergedNodeFrom: (self epsilonReachableNodesFrom: aSmaCCNode).	nodeMap at: aSmaCCNode put: newNode.	newTransitions := OrderedCollection new.	newNode transitions		do:			[ :each | 			each isEpsilonTransition				ifFalse:					[ newTransitions						add:							(each class								to: (self removeEpsilonEdgesFrom: each to)								on: each transitionObjects) ] ].	newNode transitions: newTransitions.	^ newNode! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCEpsilonRemoval class	instanceVariableNames: ''!!SmaCCEpsilonRemoval class methodsFor: 'algorithm'!removeEpsilonEdgesFrom: aSmaCCNode	"Returns an equivalent graph to aSmaCCNode that doesn't contain any epsilon transitions"	^ self new removeEpsilonEdgesFrom: aSmaCCNode! !SmaCCGraphAlgorithm subclass: #SmaCCNFAtoDFA	instanceVariableNames: 'mergedStates reverseMap'	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCNFAtoDFA methodsFor: 'merging nodes'!eliminateDuplicateTransitionsIn: aSmaCCNode	| newTransitions conflictingObject |	newTransitions := aSmaCCNode transitions		collect: [ :each | each copy ].	[ conflictingObject := self someDuplicateIn: newTransitions.	conflictingObject notNil ]		whileTrue:			[ | conflictingEdges newEdge |			conflictingEdges := newTransitions				select: [ :each | each includes: conflictingObject ].			newEdge := self createEdgeMerging: conflictingEdges.			newTransitions add: newEdge ].	self setTransitionsOn: aSmaCCNode to: newTransitions! !!SmaCCNFAtoDFA methodsFor: 'merging nodes'!mergedNodeFor: nodeCollection	| mergedNodes |	mergedNodes := IdentitySet new: nodeCollection size.	nodeCollection		do: [ :each | mergedNodes addAll: (reverseMap at: each ifAbsent: [ {each} ]) ].	mergedNodes := mergedNodes asSortedCollection asArray.	^ mergedStates		at: mergedNodes		ifAbsent: [ | newNode |			newNode := self createMergedNodeFrom: mergedNodes.			reverseMap at: newNode put: mergedNodes.			mergedStates				at: mergedNodes put: newNode;				at: (Array with: newNode) put: newNode.			self eliminateDuplicateTransitionsIn: newNode.			newNode ]! !!SmaCCNFAtoDFA methodsFor: 'initialize-release'!initialize	super initialize.	mergedStates := Dictionary new.	reverseMap := IdentityDictionary new.! !!SmaCCNFAtoDFA methodsFor: 'algorithm'!convertToDFA: aSmaCCNode	^ self mergedNodeFor: (Array with: aSmaCCNode)! !!SmaCCNFAtoDFA methodsFor: 'edges'!createEdgeMerging: conflictingEdgeCollection	| newNode common newEdge |	newNode := self		mergedNodeFor: (conflictingEdgeCollection collect: [ :each | each to ]).	common := self		commonTransitionObjectsForEdges: conflictingEdgeCollection.	newEdge := conflictingEdgeCollection first class		to: newNode		on: common.	conflictingEdgeCollection do: [ :each | each remove: common ].	^ newEdge! !!SmaCCNFAtoDFA methodsFor: 'edges'!setTransitionsOn: aSmaCCNode to: edgeCollection	aSmaCCNode		transitions: (edgeCollection reject: [ :each | each isEmpty ]).	aSmaCCNode transitions		do: [ :each | each to: (self convertToDFA: each to) ]! !!SmaCCNFAtoDFA methodsFor: 'edges'!someDuplicateIn: edgeCollection	| objects |	objects := SmaCCSet new.	edgeCollection		do: [ :edge | 			(objects commonElementWith: edge transitionObjects) ifNotNil: [ :each | ^ each ].			objects addAll: edge transitionObjects ].	^ nil! !!SmaCCNFAtoDFA methodsFor: 'edges'!commonTransitionObjectsForEdges: edgeCollection	^ edgeCollection		inject: edgeCollection first transitionObjects		into: [ :sum :each | sum smaccIntersect: each transitionObjects ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCNFAtoDFA class	instanceVariableNames: ''!!SmaCCNFAtoDFA class methodsFor: 'accessing'!convertToDFA: aSmaCCNode	"Returns an equivalent DFA from the NFA specified by aSmaCCNode -- the NFA must not contain epsilon edges."	^ self new convertToDFA: aSmaCCNode! !Object subclass: #SmaCCNode	instanceVariableNames: 'transitions action id'	classVariableNames: 'NextId'	package: 'SmaCC_Development-DFA/NFA'!!SmaCCNode methodsFor: 'copying'!shallowCopy	| copy |	copy := self class new.	copy action: action.	^ copy! !!SmaCCNode methodsFor: 'compiling-scanner'!actionForSpecificRegularExpression: aSmaCCRegularExpression	| matchedAction strings startingStates first |	strings := aSmaCCRegularExpression possibleMatches.	startingStates := transitions first isCharacterTransition		ifTrue: [ Array with: self ]		ifFalse:			[ aSmaCCRegularExpression states				collect:					[ :each | 					(transitions detect: [ :edge | edge includes: each ] ifNone: [ nil ])						ifNotNil: [ :edge | edge to ] ] ].	(startingStates includes: nil)		ifTrue: [ ^ nil ].	first := true.	strings		do:			[ :each | 			startingStates				do:					[ :node | 					first						ifTrue:							[ matchedAction := node simulate: (ReadStream on: each).							first := false ]						ifFalse:							[ matchedAction = (node simulate: (ReadStream on: each))								ifFalse: [ ^ nil ] ] ] ].	^ matchedAction! !!SmaCCNode methodsFor: 'compiling-scanner'!codeSizeEstimate: methodStates	"Estimate how many bytecodes will be generated from this node and its containing nodes."	^ 8		+			(self transitions				inject: 0				into:					[ :sum :each | 					sum						+							(each codeSizeEstimate								+									((self == each to or: [ methodStates includes: each to ])										ifTrue: [ 4 ]										ifFalse: [ each to codeSizeEstimate: methodStates ])) ])! !!SmaCCNode methodsFor: 'simulating'!simulate: aStream	| char |	aStream atEnd		ifTrue: [ ^ action ].	char := aStream next.	transitions		do: [ :each | 			(each includes: char)				ifTrue: [ ^ each to simulate: aStream ] ].	^ nil! !!SmaCCNode methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPut: $(;		nextPutAll: id printString;		nextPut: $)! !!SmaCCNode methodsFor: 'comparing'!= anObject	^ self class = anObject class and: [ self id = anObject id ]! !!SmaCCNode methodsFor: 'comparing'!hash	^ id hashMultiply! !!SmaCCNode methodsFor: 'comparing'!<= aSmaCCNode	^ self id <= aSmaCCNode id! !!SmaCCNode methodsFor: 'converting'!sortedTransitions	^ transitions asSortedCollection: [ :a :b | a <= b ]! !!SmaCCNode methodsFor: 'converting'!orderNodesWithId: anInteger map: aDictionary	anInteger <= id		ifTrue: [ ^ self ].	id := aDictionary at: id ifAbsentPut: [ self getId ].	self sortedTransitions		do: [ :each | each to orderNodesWithId: anInteger map: aDictionary ]! !!SmaCCNode methodsFor: 'converting'!asNFAWithoutEpsilonTransitions	^ SmaCCEpsilonRemoval removeEpsilonEdgesFrom: self! !!SmaCCNode methodsFor: 'converting'!orderNodes	self orderNodesWithId: NextId map: Dictionary new! !!SmaCCNode methodsFor: 'converting'!asDFA	| new |	new := (SmaCCNFAtoDFA		convertToDFA: self asNFAWithoutEpsilonTransitions)		startingNodeWithoutUnnecessaryDefaultTransition.	new removeDuplicateNodes.	new orderNodes.	^ new! !!SmaCCNode methodsFor: 'testing'!hasSimpleLoop	^ transitions anySatisfy: [ :each | each to = self ]! !!SmaCCNode methodsFor: 'testing'!isTerminalNode	^ transitions isEmpty		or: [ transitions size = 1 and: [ self hasSimpleLoop ] ]! !!SmaCCNode methodsFor: 'initialize-release'!getId	^ NextId := NextId + 1! !!SmaCCNode methodsFor: 'initialize-release'!initialize	super initialize.	id := self getId.	transitions := SortedCollection new! !!SmaCCNode methodsFor: 'initialize-release'!action: anObject	anObject isNil		ifTrue: [ ^ self ].	action := anObject isSymbol		ifTrue: [ anObject ]		ifFalse: [ SortedCollection with: anObject ]! !!SmaCCNode methodsFor: 'accessing'!groupedTransitions	^ transitions		inject: OrderedCollection new		into:			[ :sum :each | 			(sum				detect: [ :edgeCollection | edgeCollection first canMergeWith: each ]				ifNone: [ sum add: OrderedCollection new ]) add: each.			sum ]! !!SmaCCNode methodsFor: 'accessing'!mergeWith: aSmaCCNode	id := aSmaCCNode id.	transitions := aSmaCCNode transitions.	action := aSmaCCNode action! !!SmaCCNode methodsFor: 'accessing'!startingNodeWithoutUnnecessaryDefaultTransition	| edge |	self transitions size = 1		ifFalse: [ ^ self ].	edge := self transitions first.	(edge includes: #default)		ifTrue: [ ^ edge to ].	^ self! !!SmaCCNode methodsFor: 'accessing'!transitions: aCollection	transitions size to: 1 by: -1 do: [ :i | transitions removeAt: i ].	transitions addAll: aCollection! !!SmaCCNode methodsFor: 'accessing'!action	^ action! !!SmaCCNode methodsFor: 'accessing'!addActions: aCollection	aCollection isNil		ifTrue: [ ^ self ].	action isNil		ifTrue: [ ^ action := aCollection copy ].	action isSymbol		ifTrue: [ ^ self ].	aCollection isSymbol		ifTrue: [ ^ action := aCollection ].	aCollection		do: [ :each | 			(action includes: each)				ifFalse: [ action add: each ] ]! !!SmaCCNode methodsFor: 'accessing'!transitions	^ transitions! !!SmaCCNode methodsFor: 'accessing'!id	^ id! !!SmaCCNode methodsFor: 'accessing'!removeDuplicateNodes	^ SmaCCDuplicateNodeEliminator removeDuplicateNodesIn: self! !!SmaCCNode methodsFor: 'accessing'!asDOTstring	| nodeStream mapStream |	nodeStream := WriteStream on: String new.	nodeStream		nextPutAll:			'digraph finite_state_machine {	rankdir=LR;	size="100,100"';		cr.	mapStream := WriteStream on: String new.	self allStates		do:			[ :each | 			nodeStream				nextPutAll: 'node [ style=filled, shape = circle, fillcolor = ';				nextPutAll:					(each action notNil						ifTrue: [ 'green' ]						ifFalse: [ 'white' ]);				nextPutAll: '];';				nextPutAll: each id printString;				nextPut: $;;				cr.			each transitions				do:					[ :trans | 					| edge |					mapStream						nextPutAll: each id printString;						nextPutAll: ' -> ';						nextPutAll: trans to id printString;						nextPutAll: '[ label = "'.					edge := trans edgeLabel displayString.					edge size > 100						ifTrue: [ edge := '...' ].					mapStream						nextPutAll: edge;						nextPutAll: '"];';						cr ] ].	mapStream nextPut: $}.	^ nodeStream contents , mapStream contents! !!SmaCCNode methodsFor: 'accessing'!allStatesInto: aSet	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	transitions do: [ :each | each to allStatesInto: aSet ]! !!SmaCCNode methodsFor: 'accessing'!allStates	| nodes |	nodes := Set new.	self allStatesInto: nodes.	^ nodes! !!SmaCCNode methodsFor: 'accessing'!mergeTransitions	self groupedTransitions		do:			[ :edges | 			| toMap |			toMap := Dictionary new.			edges				do:					[ :each | 					(toMap includesKey: each to)						ifTrue:							[ (toMap at: each to) mergeWith: each.							transitions remove: each ]						ifFalse: [ toMap at: each to put: each ] ] ]! !!SmaCCNode methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	(Smalltalk includesKey: #RTView) not		ifTrue: [ ^ nil ].	composite roassal2		title: 'Graph';		initializeView: [ | nodes view shape elements |			nodes := self allStates.			view := (Smalltalk at: #RTView) new.			shape := ((Smalltalk at: #RTRoundedBox) new				borderRadius: 10;				color: Color white;				borderWidth: [ :n | 					n hasSimpleLoop						ifTrue: [ 2 ]						ifFalse: [ 1 ] ];				borderColor: [ :n | 					n == self						ifTrue: [ Color green ]						ifFalse: [ n action isNil								ifTrue: [ Color red ]								ifFalse: [ n action isEmpty										ifTrue: [ Color lightGray ]										ifFalse: [ Color black ] ] ] ];				yourself)				+					((Smalltalk at: #RTLabel) new						color: Color black;						text: [ :n | 							| label |							label := n id printString , String cr								,									(n action isSymbol										ifTrue: [ n ]										ifFalse: [ (n action ifNotNil: [ :a | a asArray ]) printString ]).							label copyFrom: 1 to: (label size min: 25) ];						yourself).			shape allOfSameSizeWithPadding.			elements := shape elementsOn: nodes.			elements @ (Smalltalk at: #RTDraggable).			view addAll: elements.			(Smalltalk at: #RTEdgeBuilder) new				view: view;				objects: nodes;				label:						[ :from :to | (from transitions detect: [ :each | each to == to ]) edgeLabel ];				shape:					((Smalltalk at: #RTStyledMultiLine) new						color: (Color blue alpha: 0.4);						arrowHead;						attachPoint: (Smalltalk at: #RTShorterDistanceAttachPoint) instance;						yourself);				connectFrom: #yourself					toAll: [ :node | node transitions collect: [ :each | each to ] ].			view @ (Smalltalk at: #RTDraggableView).			(Smalltalk at: #RTForceBasedLayout) new				charge: -6000;				nbIterations: 50;				on: elements edges: view edges.			view ]! !!SmaCCNode methodsFor: 'edges'!addEdgeTo: aSmaCCNode	transitions add: (SmaCCEdge to: aSmaCCNode on: nil)! !!SmaCCNode methodsFor: 'edges'!addEdgeTo: aSmaCCNode onCharacters: characterCollection	transitions		add: (SmaCCCharacterEdge to: aSmaCCNode on: characterCollection)! !!SmaCCNode methodsFor: 'edges'!addEdgeTo: aSmaCCNode onStates: symbolCollection	transitions add: (SmaCCStateEdge to: aSmaCCNode on: symbolCollection)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCNode class	instanceVariableNames: ''!!SmaCCNode class methodsFor: 'class initialization'!initialize	NextId := 0! !SmaCCEdge subclass: #SmaCCStateEdge	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-DFA/NFA'!!SmaCCStateEdge commentStamp: '' prior: 0!SmaCCStateEdge is a SmaCCEdge on states (that are represented by symbols) in the scanner.!!SmaCCStateEdge methodsFor: 'comparing'!<= aSmaCCEdge	^ self class ~= aSmaCCEdge class		or: [ self transitionObjects first <= aSmaCCEdge transitionObjects first ]! !!SmaCCStateEdge methodsFor: 'compiling'!dispatchTo: aSmaCCCodeGenerator seen: aCollection	^ aSmaCCCodeGenerator acceptStateEdge: self! !!SmaCCStateEdge methodsFor: 'compiling'!codeSizeEstimate	^ 4 * transitionObjects size! !SmaCCNode initialize!Object subclass: #SmaCCClassDefinition	instanceVariableNames: 'name subclasses grammar class superclass isRoot'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCClassDefinition commentStamp: '' prior: 0!SmaCCClassDefinition is an abstract class that represents a class to be created when compiling the parser's parse trees.Instance Variables:	class	<RBClass>	the model's class object that is created	grammar	<SmaCCGrammar>	the grammar that owns this class	isRoot	<Boolean>	is this the root class that we are generating	name	<String>	the name of the class	subclasses	<Collection of: SmaCCNodeClassDefinition>	our subclasses	superclass	<SmaCCNodeClassDefinition>	our superclass!!SmaCCClassDefinition methodsFor: 'private'!rootClassName	^ Object name! !!SmaCCClassDefinition methodsFor: 'testing'!isSortedBefore: aSmaCCClassDefinition	^ self hierarchyCount < aSmaCCClassDefinition hierarchyCount		or:			[ self hierarchyCount = aSmaCCClassDefinition hierarchyCount				and: [ self name < aSmaCCClassDefinition name ] ]! !!SmaCCClassDefinition methodsFor: 'testing'!isRoot	^ isRoot! !!SmaCCClassDefinition methodsFor: 'testing'!hierarchyIncludes: aSmaCCClassDefinition	^ self = aSmaCCClassDefinition		or:			[ superclass notNil				and: [ superclass hierarchyIncludes: aSmaCCClassDefinition ] ]! !!SmaCCClassDefinition methodsFor: 'printing'!printOn: aStream	aStream		nextPutAll: self class name;		nextPutAll: '-class(';		nextPutAll: self name;		nextPut: $)! !!SmaCCClassDefinition methodsFor: 'compiling'!temporaryNameFor: fullName	^ (fullName first isVowel		ifTrue: [ 'an' ]		ifFalse: [ 'a' ]) , fullName! !!SmaCCClassDefinition methodsFor: 'compiling'!compileMethodsAndVariables	! !!SmaCCClassDefinition methodsFor: 'accessing-hierarchy'!withAllSubclasses	| classes index |	classes := OrderedCollection with: self.	index := 1.	[ index <= classes size ]		whileTrue:			[ classes addAll: (classes at: index) subclasses.			index := index + 1 ].	^ classes! !!SmaCCClassDefinition methodsFor: 'accessing-hierarchy'!addSubclass: aSmaCCClassDefinition	subclasses add: aSmaCCClassDefinition! !!SmaCCClassDefinition methodsFor: 'accessing-hierarchy'!removeSubclass: aSmaCCClassDefinition	subclasses remove: aSmaCCClassDefinition ifAbsent: [  ]! !!SmaCCClassDefinition methodsFor: 'accessing-hierarchy'!hierarchyCount	^ superclass isNil		ifTrue: [ 0 ]		ifFalse: [ superclass hierarchyCount + 1 ]! !!SmaCCClassDefinition methodsFor: 'accessing-hierarchy'!subclasses	^ subclasses! !!SmaCCClassDefinition methodsFor: 'initialize-release'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCClassDefinition methodsFor: 'initialize-release'!initialize	super initialize.	isRoot := false.	subclasses := OrderedCollection new! !!SmaCCClassDefinition methodsFor: 'initialize-release'!modelClass: aRBClass	class := aRBClass! !!SmaCCClassDefinition methodsFor: 'initialize-release'!name: anObject	name := anObject! !!SmaCCClassDefinition methodsFor: 'initialize-release'!superclass: anObject	superclass notNil		ifTrue: [ superclass removeSubclass: self ].	superclass := anObject.	superclass notNil		ifTrue: [ superclass addSubclass: self ]! !!SmaCCClassDefinition methodsFor: 'accessing'!superclass	^ superclass! !!SmaCCClassDefinition methodsFor: 'accessing'!modelClass	^ class! !!SmaCCClassDefinition methodsFor: 'accessing'!beRoot	isRoot := true! !!SmaCCClassDefinition methodsFor: 'accessing'!codeGenerator	^ grammar codeGenerator! !!SmaCCClassDefinition methodsFor: 'accessing'!name	^ name! !!SmaCCClassDefinition methodsFor: 'accessing'!temporaryVariableName	^ self temporaryNameFor: self name! !!SmaCCClassDefinition methodsFor: 'accessing'!fullName	^ self codeGenerator namespaceName , self name! !!SmaCCClassDefinition methodsFor: 'accessing'!superclassName	^ self isRoot		ifTrue: [ self rootClassName ]		ifFalse: [ superclass fullName ]! !Object subclass: #SmaCCNodeCalculation	instanceVariableNames: 'grammar classes variableSymbols singleVariableSymbols'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCNodeCalculation methodsFor: 'private'!compileVisitor	| class |	class := self codeGenerator		defineClass: grammar rootDefinition fullName , 'Visitor'		asSubclassOf: (self codeGenerator model classFor: SmaCCParseNodeVisitor).	self codeGenerator removeOldMethodsFrom: class.	self codeGenerator removeOldMethodsFrom: class theMetaClass.	(SmaCCVisitorClassDefinition forClassDefinitions: self sortedClasses)		grammar: grammar;		modelClass: class;		compileMethodsAndVariables! !!SmaCCNodeCalculation methodsFor: 'private'!compileTypes	self codeGenerator compileSymbolTypes! !!SmaCCNodeCalculation methodsFor: 'private'!defineNodeClasses	self sortedClasses		do: [ :each | self codeGenerator compileNodeClassDefinition: each ]! !!SmaCCNodeCalculation methodsFor: 'private'!compileMethodsAndVariables	self sortedClasses do: [ :each | each compileMethodsAndVariables ]! !!SmaCCNodeCalculation methodsFor: 'private'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCNodeCalculation methodsFor: 'private'!codeGenerator	^ grammar codeGenerator! !!SmaCCNodeCalculation methodsFor: 'private'!calculateVariableSymbolsFor: aSmaCCSymbol	aSmaCCSymbol isTerminal		ifTrue: [ ^ self ].	aSmaCCSymbol requiresNodeType		ifTrue: [ ^ self ].	(variableSymbols includes: aSmaCCSymbol)		ifTrue: [ ^ self ].	variableSymbols add: aSmaCCSymbol.	aSmaCCSymbol		productionsDo:			[ :rhs | 			rhs				unnamedSymbolsDo: [ :each | self calculateVariableSymbolsFor: each ] ]! !!SmaCCNodeCalculation methodsFor: 'private'!calculateVariableSymbols	variableSymbols := Set new.	grammar symbols		do:			[ :each | 			each requiresNodeType				ifTrue:					[ each						productionsDo:							[ :rhs | rhs unnamedSymbolsDo: [ :sym | self calculateVariableSymbolsFor: sym ] ] ] ].	variableSymbols := variableSymbols		select: [ :each | self hasVariables: each seen: IdentitySet new ].	singleVariableSymbols := variableSymbols		select: [ :each | self hasSingleVariableName: each ].	variableSymbols removeAll: singleVariableSymbols! !!SmaCCNodeCalculation methodsFor: 'private'!hasSingleVariableName: aSymbol using: nameSet seen: seen	(seen includes: aSymbol)		ifTrue: [ ^ true ].	seen add: aSymbol.	aSymbol		productionsDo:			[ :rhs | 			nameSet addAll: rhs variableNames.			nameSet size > 1				ifTrue: [ ^ false ].			rhs				unnamedSymbolsDo:					[ :sym | 					(self hasSingleVariableName: sym using: nameSet seen: seen)						ifFalse: [ ^ false ] ] ].	^ true! !!SmaCCNodeCalculation methodsFor: 'private'!calculateReduceActions	variableSymbols		do: [ :each | 			each				productionsDo: [ :rhs | rhs reduceCode: (SmaCCVariableReduceCode onRHS: rhs) ] ].	singleVariableSymbols		do: [ :each | 			each				productionsDo: [ :rhs | rhs reduceCode: (SmaCCSingleVariableReduceCode onRHS: rhs) ] ].	grammar		rhsDo: [ :each | 			each hasNodeClassDefinition				ifTrue: [ each reduceCode: (SmaCCCreateNodeReduceCode onRHS: each) ]				ifFalse: [ each hasReduceAction						ifFalse: [ each reduceCode: (SmaCCDefaultNodeReduceCode onRHS: each) ] ] ]! !!SmaCCNodeCalculation methodsFor: 'private'!hasSingleVariableName: aSymbol	^ self		hasSingleVariableName: aSymbol		using: Set new		seen: IdentitySet new! !!SmaCCNodeCalculation methodsFor: 'private'!hasVariables: aSmaCCSymbol seen: aSet	aSmaCCSymbol requiresNodeType		ifTrue: [ ^ false ].	(aSet includes: aSmaCCSymbol)		ifTrue: [ ^ false ].	aSet add: aSmaCCSymbol.	aSmaCCSymbol		productionsDo:			[ :each | 			each hasNamedVariable				ifTrue: [ ^ true ].			each				do: [ :symbol | 					(self hasVariables: symbol seen: aSet)						ifTrue: [ ^ true ] ] ].	^ false! !!SmaCCNodeCalculation methodsFor: 'private'!compileNodeClasses	self sortedClasses isEmpty		ifTrue: [ ^ self ].	self defineNodeClasses.	self calculateVariableSymbols.	self calculateReduceActions.	self calculateVariables.	self compileMethodsAndVariables.	self compileVisitor.	self compileTypes! !!SmaCCNodeCalculation methodsFor: 'private'!sortedClasses	^ classes		ifNil:			[ classes := grammar classDefinitions				asSortedCollection: [ :a :b | a isSortedBefore: b ] ]! !!SmaCCNodeCalculation methodsFor: 'private'!calculateVariables	SmaCCVariableCalculation calculateVariablesForGrammar: grammar! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCNodeCalculation class	instanceVariableNames: ''!!SmaCCNodeCalculation class methodsFor: 'accessing'!compileForGrammar: aSmaCCGrammar	self new		grammar: aSmaCCGrammar;		compileNodeClasses! !SmaCCClassDefinition subclass: #SmaCCNodeClassDefinition	instanceVariableNames: 'productions variables extraAttributes'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCNodeClassDefinition commentStamp: '' prior: 0!SmaCCNodeClassDefinition represents a class to compile.Instance Variables	extraAttributes	<Collection of: SmaCCVariableDefinition>	extra variables that should be added to the class	productions	<Collection of: SmaCCRHS>	all of the rhs that return/create this class	variables	<Collection of: SmaCCVariableDefinition>	the variables defined by the grammar for this class!!SmaCCNodeClassDefinition methodsFor: 'private-variables'!removeInstanceVariable: aString	| variable |	variable := self variableDefinitions		detect: [ :each | each variableName = aString ]		ifNone: [ nil ].	variable isNil		ifTrue: [ ^ self ].	variables remove: variable.	SmaCCVariableDefinition assignIndices: variables! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!modelTypesForVariable: aVariableName	| allTypes |	allTypes := Set new.	self withAllSubclasses		do:			[ :each | 			each productions				do:					[ :production | allTypes addAll: (production modelTypesForVariable: aVariableName) ] ].	^ allTypes! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!baseTypeOf: aVariableName	| allTypes aRBRootNamespace |	aRBRootNamespace := class model.	allTypes := self modelTypesForVariable: aVariableName.	allTypes		remove: (aRBRootNamespace classFor: nil class)		ifAbsent: [ nil ].	allTypes isEmpty		ifTrue: [ ^ aRBRootNamespace classFor: Object ].	allTypes := allTypes asOrderedCollection.	^ allTypes		inject: allTypes first		into:			[ :sum :each | 			| current |			current := sum.			[ current notNil and: [ (each includesClass: current) not ] ]				whileTrue: [ current := current superclass ].			current ]! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!removeDuplicateSubclassVariables	variables		do:			[ :each | 			self withAllSubclasses				do:					[ :sub | 					sub == self						ifFalse: [ sub removeInstanceVariable: each variableName ] ] ]! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!collectionVariableDefinitions	^ self variableDefinitions select: [ :each | each isCollection ]! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!subclassProductionVariables	| vars |	vars := self withAllSubclasses		collect: [ :sub | sub productionVariables ].	^ SmaCCSymbol mergeOrderedVariableDefinitions: vars! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!calculateCommonSubclassVariables	| allSubclassVars includedVariables |	allSubclassVars := Bag new.	subclasses		do: [ :each | allSubclassVars addAll: each variableDefinitions ].	includedVariables := allSubclassVars asSet		select: [ :each | (allSubclassVars occurrencesOf: each) = subclasses size ].	^ self subclassProductionVariables		select: [ :each | includedVariables includes: each ]! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!variableDefinitionNamed: aString	^ self variableDefinitions		detect: [ :each | each variableName = aString ]		ifNone:			[ superclass isNil				ifTrue: [ nil ]				ifFalse: [ superclass variableDefinitionNamed: aString ] ]! !!SmaCCNodeClassDefinition methodsFor: 'private-variables'!productionVariables	| vars |	vars := productions collect: [ :each | each variableDefinitions ].	^ SmaCCSymbol mergeOrderedVariableDefinitions: vars! !!SmaCCNodeClassDefinition methodsFor: 'initialize-release'!extraAttributes: aCollection	extraAttributes := aCollection! !!SmaCCNodeClassDefinition methodsFor: 'initialize-release'!initialize	super initialize.	productions := OrderedCollection new.	extraAttributes := OrderedCollection new! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileVariablesAndAccessors	self variableDefinitions		do: [ :each | self compileVariableAndAccessor: each ].	self extraAttributes		do: [ :each | self compileVariableAndAccessor: each ]! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!tempNodeName	^ self temporaryNameFor: grammar rootDefinition name! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileMethodsAndVariables	self		compileVariablesAndAccessors;		compileInitializeMethod;		compileHashMethod;		compileEqualMethod;		compilePostCopyMethod;		compileChildrenMethod;		compileCopyInContextMethod;		compileMatchInContextMethod;		compileVariablesMethods! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileCopyInContextMethod	self codeGenerator compileCopyInContextMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileChildrenMethod	self codeGenerator compileChildrenMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileGetterAndSetter: aSmaCCVariableDefinition	self codeGenerator		compileGetterAndSetter: aSmaCCVariableDefinition		forDefinition: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compilePostCopyMethod	self codeGenerator compilePostCopyMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileMatchInContextMethod	self codeGenerator compileMatchInContextMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileHashMethod	self codeGenerator compileHashMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!addVariable: aSmaCCVariableDefinition	self codeGenerator		addVariable: aSmaCCVariableDefinition		forDefinition: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileEqualMethod	self codeGenerator compileEqualMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileVariablesMethods	self codeGenerator compileVariablesMethods: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileInitializeMethod	self codeGenerator compileInitializeMethod: self! !!SmaCCNodeClassDefinition methodsFor: 'compiling'!compileVariableAndAccessor: aSmaCCVariableDefinition	aSmaCCVariableDefinition		baseType: (self baseTypeOf: aSmaCCVariableDefinition variableName).	aSmaCCVariableDefinition		isAlwaysAssigned: (self isAlwaysAssigned: aSmaCCVariableDefinition variableName).	self addVariable: aSmaCCVariableDefinition.	self compileGetterAndSetter: aSmaCCVariableDefinition! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!addProduction: aSmaCCRHS	productions add: aSmaCCRHS.	aSmaCCRHS nodeClassDefinition: self! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!nodeVariableDefinitions	^ self variableDefinitions		select: [ :each | each isBasePossibleNodeType ]! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!variableDefinitions	variables isNil		ifTrue:			[ variables := productions isEmpty				ifTrue: [ self calculateCommonSubclassVariables ]				ifFalse: [ self productionVariables ].			self removeDuplicateSubclassVariables.			SmaCCVariableDefinition assignIndices: variables ].	^ variables! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!productions	^ productions! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!instanceVariableNames	^ self variableDefinitions collect: [ :each | each variableName ]! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!extraAttributes	^ extraAttributes! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!variables	^ superclass isNil		ifTrue: [ self instanceVariableNames copy ]		ifFalse:			[ superclass variables				addAll: self instanceVariableNames;				yourself ]! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!fullName	^ self codeGenerator namespaceName , grammar prefix , name		, grammar suffix! !!SmaCCNodeClassDefinition methodsFor: 'accessing'!grammar	^ grammar! !!SmaCCNodeClassDefinition methodsFor: 'testing'!isAlwaysAssigned: aString	^ ((self modelTypesForVariable: aString)		includes: (class model classFor: nil class))		and:			[ self withAllSubclasses				allSatisfy:					[ :sub | 					sub productions						allSatisfy: [ :each | each locallyDefinesVariable: aString ] ] ]! !!SmaCCNodeClassDefinition methodsFor: 'testing'!isCollectionVariable: aVariableName	| definition |	definition := self variableDefinitionNamed: aVariableName.	definition notNil		ifTrue: [ ^ definition isCollection ].	^ superclass notNil		and: [ superclass isCollectionVariable: aVariableName ]! !!SmaCCNodeClassDefinition methodsFor: 'testing'!isLocalVariable: aSmaCCVariableDefinition	^ superclass isNil		or:			[ (superclass				variableDefinitionNamed: aSmaCCVariableDefinition variableName)				isNil ]! !!SmaCCNodeClassDefinition methodsFor: 'private'!rootClassName	^ SmaCCParseNode name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCNodeClassDefinition class	instanceVariableNames: ''!!SmaCCNodeClassDefinition class methodsFor: 'instance creation'!named: aSymbol grammar: aSmaCCGrammar	^ self new		name: aSymbol;		grammar: aSmaCCGrammar;		yourself! !Object subclass: #SmaCCReduceCode	instanceVariableNames: 'rhs cachedTypes'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCReduceCode commentStamp: '' prior: 0!SmaCCReduceCode represents the code to be run when we match the rhs.Subclasses must implement the following messages:	accessing		source - returns the code to be run after matching the rhs	private		basicModelTypes: - returns the types the source can return (e.g., OrderedCollection, SmaCCToken, etc.)Instance Variables	cachedTypes	<Collection of: RBClass>	the type of object that is returned when this reduce action is run	rhs	<SmaCCRHS>	the RHS that contains this reduce code!!SmaCCReduceCode methodsFor: 'accessing'!source	^ self subclassResponsibility! !!SmaCCReduceCode methodsFor: 'accessing'!model	^ rhs model! !!SmaCCReduceCode methodsFor: 'accessing'!rhs	^ rhs! !!SmaCCReduceCode methodsFor: 'accessing'!codeGenerator	^ rhs grammar codeGenerator! !!SmaCCReduceCode methodsFor: 'testing'!hasReduceAction	^ true! !!SmaCCReduceCode methodsFor: 'testing'!returnsVariableCollection	^ false! !!SmaCCReduceCode methodsFor: 'testing'!isImmediate	^ false! !!SmaCCReduceCode methodsFor: 'testing'!returnsSingleVariable	^ false! !!SmaCCReduceCode methodsFor: 'reduce actions'!reduceExpressionParseTree	^ RBParser parseExpression: self source! !!SmaCCReduceCode methodsFor: 'initialize-release'!rhs: aSmaCCRHS	rhs := aSmaCCRHS! !!SmaCCReduceCode methodsFor: 'comparing'!= anObject	^ self class = anObject class and: [ self rhs == anObject rhs ]! !!SmaCCReduceCode methodsFor: 'comparing'!hash	^ self class hash bitXor: self rhs hash! !!SmaCCReduceCode methodsFor: 'private'!basicModelTypes: aSet forIndex: index	^ (rhs at: index) modelTypes: aSet! !!SmaCCReduceCode methodsFor: 'private'!baseClassType	^ rhs grammar rootDefinition! !!SmaCCReduceCode methodsFor: 'private'!basicModelTypes: aSet	self subclassResponsibility! !!SmaCCReduceCode methodsFor: 'private'!returnedNodeIndex	^ self returnedNodeIndexFor: self reduceExpressionParseTree! !!SmaCCReduceCode methodsFor: 'private'!returnedNodeIndexFor: parseTree	| index |	parseTree isCascade		ifTrue: [ ^ self returnedNodeIndexFor: parseTree messages last ].	(parseTree isMessage and: [ parseTree selector == #yourself ])		ifTrue: [ ^ self returnedNodeIndexFor: parseTree receiver ].	(parseTree isVariable or: [ parseTree isLiteralNode ])		ifFalse: [ ^ nil ].	parseTree isVariable		ifTrue: [ index := rhs indexOfVariable: parseTree name.			(index between: 1 and: rhs size)				ifTrue: [ ^ index ] ].	(parseTree isLiteralNode and: [ parseTree value isString ])		ifFalse: [ ^ nil ].	(parseTree value allSatisfy: [ :each | each isDigit ])		ifTrue: [ index := Integer readFrom: (ReadStream on: parseTree value).			(index between: 1 and: rhs size)				ifTrue: [ ^ index ] ].	^ nil! !!SmaCCReduceCode methodsFor: 'accessing-types'!modelTypes: anIdentitySet	cachedTypes isNil		ifTrue: [ cachedTypes := self basicModelTypes: anIdentitySet ].	^ cachedTypes! !!SmaCCReduceCode methodsFor: 'accessing-types'!nodeType: anIdentitySet	| index |	index := self returnedNodeIndex.	^ index notNil		ifTrue: [ (rhs at: index) nodeType: anIdentitySet ]		ifFalse: [ self baseClassType ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReduceCode class	instanceVariableNames: ''!!SmaCCReduceCode class methodsFor: 'instance creation'!onRHS: aSmaCCRHS	^ self new		rhs: aSmaCCRHS;		yourself! !SmaCCReduceCode subclass: #SmaCCCreateNodeReduceCode	instanceVariableNames: 'classDefinition index'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCCreateNodeReduceCode commentStamp: '' prior: 0!SmaCCCreateNodeReduceCode represents a reduce action that creates a parse node.Instance Variables	classDefinition	<SmaCCClassDefinition>	the parse node class to create	index	<Integer>	index in the RHS of a symbol that returns parse node, if no symbol returns the parse node, then the index = 0!!SmaCCCreateNodeReduceCode methodsFor: 'private'!basicModelTypes: aSet	^ Array with: self classDefinition modelClass! !!SmaCCCreateNodeReduceCode methodsFor: 'accessing'!classDefinition	classDefinition isNil		ifTrue: [ classDefinition := rhs nodeClassDefinition				ifNil: [ rhs nodeType ] ].	^ classDefinition! !!SmaCCCreateNodeReduceCode methodsFor: 'accessing'!index	^ index ifNil: [ index := rhs componentIndex ]! !!SmaCCCreateNodeReduceCode methodsFor: 'accessing'!source	^ self isPullUpAction		ifTrue:			[ self codeGenerator				createNodeReduceAction: rhs				pullUpFrom: self index ]		ifFalse: [ self codeGenerator createNodeReduceAction: rhs ]! !!SmaCCCreateNodeReduceCode methodsFor: 'testing'!isPullUpAction	^ self index > 0! !!SmaCCCreateNodeReduceCode methodsFor: 'accessing-types'!nodeType: anIdentitySet	^ self classDefinition! !!SmaCCCreateNodeReduceCode methodsFor: 'comparing'!= anObject	^ super = anObject		and:			[ self classDefinition = anObject classDefinition				and: [ self index = anObject index ] ]! !!SmaCCCreateNodeReduceCode methodsFor: 'initialize-release'!index: anInteger	index := anInteger! !SmaCCReduceCode subclass: #SmaCCDefaultNodeReduceCode	instanceVariableNames: 'index'	classVariableNames: 'IsCaching'	package: 'SmaCC_Development-Compilation Model'!!SmaCCDefaultNodeReduceCode commentStamp: '' prior: 0!SmaCCDefaultNodeReduceCode represents a reduce action that returns an item in the rhs. It returns the first symbol that is a non-terminal. If all symbols are terminals, then it returns the first terminal symbol. If there aren't any symbols, then it returns nil.Instance Variables	index	<Integer>	the index in the rhs to return; if 0 then return nil!!SmaCCDefaultNodeReduceCode methodsFor: 'public'!modelTypes: anIdentitySet	"Yes, I know it is a hack"	IsCaching		ifTrue: [ ^ self basicModelTypes: anIdentitySet ].	IsCaching := true.	^ [ super modelTypes: anIdentitySet ]		ensure: [ IsCaching := false ]! !!SmaCCDefaultNodeReduceCode methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self index = anObject index ]! !!SmaCCDefaultNodeReduceCode methodsFor: 'private'!returnedNodeIndex	self index = 0		ifTrue: [ ^ nil ].	^ self index! !!SmaCCDefaultNodeReduceCode methodsFor: 'private'!basicModelTypes: aSet	^ self index = 0		ifTrue: [ Array with: (self model classFor: nil class) ]		ifFalse: [ self basicModelTypes: aSet forIndex: self index ]! !!SmaCCDefaultNodeReduceCode methodsFor: 'accessing'!signalNodeCreationWarning	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'Unable to determine what should be returned from the production. ';		nextPutAll:			(index > 0				ifTrue: [ 'A default item has been chosen, and all other ' ]				ifFalse: [ 'All ' ]);		nextPutAll: 'values will be dropped from the AST:';		cr;		cr;		nextPutAll: rhs productionSymbol name;		nextPutAll: ' : '.	1 to: rhs size do:		[ :i | 		i == index			ifTrue: [ stream nextPutAll: '>>>' ].		stream nextPutAll: (rhs at: i) name.		i == index			ifTrue: [ stream nextPutAll: '<<<' ].		stream space ].	SmaCCCompilationNotification new		messageText: 'Node creation';		tag: stream contents;		signal! !!SmaCCDefaultNodeReduceCode methodsFor: 'accessing'!index	index isNil		ifTrue:			[ rhs size to: 1 by: -1 do: [ :i | 				(rhs at: i) isTerminal					ifFalse: [ index := i ] ].			index isNil				ifTrue: [ index := 1 min: rhs size ].			(rhs size = index and: [ index <= 1 ])				ifFalse: [ self signalNodeCreationWarning ] ].	^ index! !!SmaCCDefaultNodeReduceCode methodsFor: 'accessing'!source	^ self codeGenerator defaultNodeReductionSource: self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDefaultNodeReduceCode class	instanceVariableNames: ''!!SmaCCDefaultNodeReduceCode class methodsFor: 'class initialization'!initialize	IsCaching := false! !SmaCCReduceCode subclass: #SmaCCDefaultReduceCode	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCDefaultReduceCode commentStamp: '' prior: 0!SmaCCDefaultReduceCode represents a reduce action that returns a collection of all items in the rhs.!!SmaCCDefaultReduceCode methodsFor: 'testing'!hasReduceAction	^ false! !!SmaCCDefaultReduceCode methodsFor: 'private'!basicModelTypes: aSet	^ Array with: (self model classFor: OrderedCollection)! !!SmaCCDefaultReduceCode methodsFor: 'accessing'!source	^ self codeGenerator defaultReductionSource! !SmaCCReduceCode subclass: #SmaCCSingleVariableReduceCode	instanceVariableNames: 'indices'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCSingleVariableReduceCode methodsFor: 'testing'!returnsSingleVariable	^ true! !!SmaCCSingleVariableReduceCode methodsFor: 'private'!computeIndices	indices := OrderedCollection new.	1 to: rhs size do:		[ :i | 		| symbol |		symbol := rhs at: i.		(rhs variableNameForIndex: i) notNil			ifTrue: [ indices add: i ]			ifFalse: [ symbol returnsSingleVariable					ifTrue: [ indices add: i ] ] ].	^ indices! !!SmaCCSingleVariableReduceCode methodsFor: 'private'!basicModelTypes: aSet	| types isCollection |	isCollection := false.	types := Set new.	self indices size <= 1		ifTrue: [ rhs productionSymbol				productionsDo: [ :each | 					(isCollection := isCollection or: [ each reduceCode indices size > 1 ])						ifFalse: [ each reduceCode indices notEmpty								ifTrue: [ types										addAll:											(each reduceCode												basicModelTypes: aSet												forIndex: each reduceCode indices first) ] ] ] ]		ifFalse: [ isCollection := true ].	^ isCollection		ifTrue: [ Array with: (self model classFor: OrderedCollection) ]		ifFalse: [ types asArray ]! !!SmaCCSingleVariableReduceCode methodsFor: 'accessing'!indices	^ indices ifNil: [ self computeIndices ]! !!SmaCCSingleVariableReduceCode methodsFor: 'accessing'!index	^ indices isEmpty		ifTrue: [ 0 ]		ifFalse: [ indices first ]! !!SmaCCSingleVariableReduceCode methodsFor: 'accessing'!source	^ (indices size < 2		and:			[ rhs productionSymbol variableDefinitions asArray first isCollection				not ])		ifTrue: [ self codeGenerator defaultNodeReductionSource: self ]		ifFalse: [ self codeGenerator singleVariableCollectionFor: self ]! !SmaCCReduceCode subclass: #SmaCCSourceReduceCode	instanceVariableNames: 'source isImmediate'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCSourceReduceCode commentStamp: '' prior: 0!SmaCCSourceReduceCode represents a reduce action that is specified in the grammar. In this case, it outputs the code directly into the parser.Instance Variables	source	<String>	the source to output!!SmaCCSourceReduceCode methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self source = anObject source ]! !!SmaCCSourceReduceCode methodsFor: 'initialize-release'!initialize	super initialize.	isImmediate := false! !!SmaCCSourceReduceCode methodsFor: 'initialize-release'!source: aString	source := aString! !!SmaCCSourceReduceCode methodsFor: 'private'!typesForTree: aRBProgramNode seen: aSet	aRBProgramNode isReturn		ifTrue: [ ^ self typesForTree: aRBProgramNode value seen: aSet ].	(aRBProgramNode isSequence and: [ aRBProgramNode statements notEmpty ])		ifTrue: [ | types |			types := Set withAll: (self typesForTree: aRBProgramNode statements last seen: aSet).			aRBProgramNode				nodesDo: [ :each | 					each isReturn						ifTrue: [ types addAll: (self typesForTree: each value seen: aSet) ] ].			^ types asArray ].	(aRBProgramNode isLiteralNode or: [ aRBProgramNode isVariable ])		ifTrue: [ (self returnedNodeIndexFor: aRBProgramNode)				ifNil: [ aRBProgramNode isLiteralNode						ifTrue: [ ^ Array with: (self model classFor: aRBProgramNode value class) ] ]				ifNotNil: [ :index | ^ self basicModelTypes: aSet forIndex: index ] ].	(aRBProgramNode isMessage and: [ aRBProgramNode receiver isVariable and: [ aRBProgramNode receiver name = 'SmaCCToken' ] ])		ifTrue: [ ^ Array with: (self model classFor: SmaCCToken) ].	^ Array with: (self model classFor: Object)! !!SmaCCSourceReduceCode methodsFor: 'private'!basicModelTypes: aSet	| index parseTree |	index := self returnedNodeIndex.	index notNil		ifTrue: [ ^ self basicModelTypes: aSet forIndex: index ].	parseTree := RBParser parseExpression: self source onError: [ :e :p | ^ Array with: (self model classFor: Object) ].	^ self typesForTree: parseTree seen: aSet! !!SmaCCSourceReduceCode methodsFor: 'accessing'!isImmediate: aBoolean	isImmediate := aBoolean! !!SmaCCSourceReduceCode methodsFor: 'accessing'!isImmediate	^ isImmediate! !!SmaCCSourceReduceCode methodsFor: 'accessing'!source	^ source! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSourceReduceCode class	instanceVariableNames: ''!!SmaCCSourceReduceCode class methodsFor: 'instance creation'!onRHS: aSmaCCRHS source: aString	^ (self onRHS: aSmaCCRHS)		source: aString;		yourself! !Object subclass: #SmaCCVariableCalculation	instanceVariableNames: 'grammar todo dependentsMap newVariables ourType currentRHS previousVariables'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCVariableCalculation methodsFor: 'private'!addRHS: aSmaCCRHS	(todo identityIncludes: aSmaCCRHS)		ifTrue: [ ^ self ].	todo add: aSmaCCRHS! !!SmaCCVariableCalculation methodsFor: 'private'!hasVariableNamed: aString	^ newVariables anySatisfy: [ :each | each variableName = aString ]! !!SmaCCVariableCalculation methodsFor: 'private'!setupVariableDependentsFor: aSmaCCRHS	aSmaCCRHS		variablesAndSymbolsDo:			[ :variable :symbol | 			(variable isNil or: [ symbol returnsSingleVariable ])				ifTrue: [ symbol						productionsDo: [ :rhs | self addDependent: aSmaCCRHS to: rhs ] ] ]! !!SmaCCVariableCalculation methodsFor: 'private'!addLocallyDefinedVariable: aString	(self hasVariableNamed: aString)		ifTrue: [ (self variableNamed: aString) isCollection: true ]		ifFalse: [ self addVariableNamed: aString ]! !!SmaCCVariableCalculation methodsFor: 'private'!shouldAddVariablesFrom: aSmaCCRHS	| theirType |	ourType isNil		ifTrue: [ ^ true ].	theirType := aSmaCCRHS nodeType.	theirType isNil		ifTrue: [ ^ true ].	ourType = theirType		ifTrue: [ ^ true ].	^ (theirType hierarchyIncludes: ourType) not! !!SmaCCVariableCalculation methodsFor: 'private'!calculateNewVariables	ourType := currentRHS nodeType.	newVariables := OrderedCollection new.	previousVariables := #().	currentRHS		variablesAndSymbolsDo:			[ :variable :symbol | 			variable isNil				ifTrue: [ self processUnnamedSymbol: symbol ]				ifFalse:					[ symbol returnsSingleVariable						ifTrue: [ self addRenamedVariableName: variable from: symbol ]						ifFalse: [ self addLocallyDefinedVariable: variable ] ].			previousVariables := newVariables				collect: [ :each | each variableName ] ]! !!SmaCCVariableCalculation methodsFor: 'private'!addDependent: dependentSmaCCRHS to: aSmaCCRHS	(dependentsMap at: aSmaCCRHS ifAbsentPut: [ IdentitySet new ])		add: dependentSmaCCRHS! !!SmaCCVariableCalculation methodsFor: 'private'!addExternallyDefinedVariablesFrom: aSmaCCRHS	aSmaCCRHS variableDefinitions		do:			[ :each | 			| variable |			variable := self variableNamed: each variableName.			(each isCollection				or:					[ (currentRHS locallyDefinesVariable: each variableName)						or: [ previousVariables includes: each variableName ] ])				ifTrue: [ variable isCollection: true ] ]! !!SmaCCVariableCalculation methodsFor: 'private'!recalculateDependents	(dependentsMap at: currentRHS ifAbsent: [ #() ])		do: [ :each | self addRHS: each ]! !!SmaCCVariableCalculation methodsFor: 'private'!assignVariables	currentRHS variableDefinitions: newVariables! !!SmaCCVariableCalculation methodsFor: 'private'!rhsDo: aBlock	grammar symbols		do: [ :each | 			each isStartingSymbol				ifFalse: [ each productionsDo: aBlock ] ]! !!SmaCCVariableCalculation methodsFor: 'private'!hasVariableChanges	^ newVariables		anySatisfy: [ :each | (currentRHS variableDefinitions includes: each) not ]! !!SmaCCVariableCalculation methodsFor: 'private'!calculateVariablesForGrammar: aSmaCCGrammar	grammar := aSmaCCGrammar.	dependentsMap := IdentityDictionary new.	todo := OrderedCollection new.	self setupVariableDependents.	self calculateVariables! !!SmaCCVariableCalculation methodsFor: 'private'!calculateVariablesFor: aSmaCCRHS	currentRHS := aSmaCCRHS.	self calculateNewVariables.	self hasVariableChanges		ifTrue: [ self assignVariables.			self recalculateDependents ]! !!SmaCCVariableCalculation methodsFor: 'private'!calculateVariables	self rhsDo: [ :each | self addRHS: each ].	[ todo notEmpty ]		whileTrue: [ self calculateVariablesFor: todo removeFirst ]! !!SmaCCVariableCalculation methodsFor: 'private'!setupVariableDependents	self rhsDo: [ :rhs | self setupVariableDependentsFor: rhs ]! !!SmaCCVariableCalculation methodsFor: 'private'!addVariableNamed: aString	^ newVariables add: (SmaCCVariableDefinition variableName: aString)! !!SmaCCVariableCalculation methodsFor: 'private'!addRenamedVariableName: aString from: symbol	(self hasVariableNamed: aString)		ifTrue: [ (self variableNamed: aString) isCollection: true ]		ifFalse:			[ | variable |			variable := self addVariableNamed: aString.			variable isCollection				ifFalse:					[ symbol returnsSingleVariable						ifTrue:							[ symbol								productionsDo:									[ :rhs | 									rhs variableDefinitions notEmpty										ifTrue:											[ variable												isCollection:													(variable isCollection														or: [ rhs variableDefinitions first isCollection ]) ] ] ] ] ]! !!SmaCCVariableCalculation methodsFor: 'private'!variableNamed: aString	^ newVariables		detect: [ :each | each variableName = aString ]		ifNone: [ self addVariableNamed: aString ]! !!SmaCCVariableCalculation methodsFor: 'private'!processUnnamedSymbol: aSmaCCSymbol	aSmaCCSymbol		productionsDo:			[ :rhs | 			(self shouldAddVariablesFrom: rhs)				ifTrue: [ self addExternallyDefinedVariablesFrom: rhs ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCVariableCalculation class	instanceVariableNames: ''!!SmaCCVariableCalculation class methodsFor: 'accessing'!calculateVariablesForGrammar: aSmaCCGrammar	self new calculateVariablesForGrammar: aSmaCCGrammar! !Object subclass: #SmaCCVariableDefinition	instanceVariableNames: 'variableName isCollection baseType isAlwaysAssigned getterMethodName setterMethodName index'	classVariableNames: 'PluralNameBlock PluralNames'	package: 'SmaCC_Development-Compilation Model'!!SmaCCVariableDefinition commentStamp: '' prior: 0!SmaCCVariableDefinition represents a variable for a node class.Instance Variables	baseType	<RBAbstractClass>	the type of the variable	getterMethodName	<Symbol>	the getter selector	index	<Integer>	the index of the variable (if we are pulling up a collection of variables from a symbol)	isAlwaysAssigned	<Boolean>	does the variable always have a value or can it be nil	isCollection	<Boolean>	does the variable represent a collection of values	setterMethodName	<Symbol>	the setter selector	variableName	<String>	the name of the variable!!SmaCCVariableDefinition methodsFor: 'initialize-release'!isCollection: aBoolean	isCollection := aBoolean! !!SmaCCVariableDefinition methodsFor: 'initialize-release'!baseType: modelClass	baseType := modelClass! !!SmaCCVariableDefinition methodsFor: 'initialize-release'!variableName: aString	variableName := aString! !!SmaCCVariableDefinition methodsFor: 'comparing'!= anObject	^ self class = anObject class		and:			[ self variableName = anObject variableName				and: [ self isCollection = anObject isCollection ] ]! !!SmaCCVariableDefinition methodsFor: 'comparing'!hash	^ self variableName hash bitXor: self isCollection hash! !!SmaCCVariableDefinition methodsFor: 'accessing'!setterMethodName: aString	setterMethodName := aString! !!SmaCCVariableDefinition methodsFor: 'accessing'!collectionType	^ self baseType model classFor: OrderedCollection! !!SmaCCVariableDefinition methodsFor: 'accessing'!setterMethodName	^ setterMethodName! !!SmaCCVariableDefinition methodsFor: 'accessing'!getterMethodName	^ getterMethodName! !!SmaCCVariableDefinition methodsFor: 'accessing'!getterMethodName: aString	getterMethodName := aString! !!SmaCCVariableDefinition methodsFor: 'accessing'!isBaseTokenType	^ self baseType		includesClass: (self baseType model classFor: SmaCCToken)! !!SmaCCVariableDefinition methodsFor: 'accessing'!index	^ index! !!SmaCCVariableDefinition methodsFor: 'accessing'!isBasePossibleNodeType	^ self isBaseNodeType		or:			[ (self baseType model classFor: SmaCCParseNode)				includesClass: self baseType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!isNodeCollectionType	^ self isCollection and: [ self isBaseNodeType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!isPossibleNodeCollectionType	^ self isCollection and: [ self isBasePossibleNodeType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!isNodeType	^ self isCollection not and: [ self isBaseNodeType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!isCollection	^ isCollection! !!SmaCCVariableDefinition methodsFor: 'accessing'!type	^ self isCollection		ifTrue: [ self collectionType ]		ifFalse: [ self baseType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!sourceVariableName	^ self isCollection		ifTrue: [ self class pluralNameFor: variableName ]		ifFalse: [ variableName ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!variableName	^ variableName! !!SmaCCVariableDefinition methodsFor: 'accessing'!index: anInteger	index := anInteger! !!SmaCCVariableDefinition methodsFor: 'accessing'!isAlwaysAssigned: aBoolean	isAlwaysAssigned := aBoolean! !!SmaCCVariableDefinition methodsFor: 'accessing'!isBaseNodeType	^ self baseType		includesClass: (self baseType model classFor: SmaCCParseNode)! !!SmaCCVariableDefinition methodsFor: 'accessing'!isAlwaysAssigned	^ isAlwaysAssigned or: [ self isCollection ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!isPossibleNodeType	^ self isCollection not and: [ self isBasePossibleNodeType ]! !!SmaCCVariableDefinition methodsFor: 'accessing'!baseType	^ baseType! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCVariableDefinition class	instanceVariableNames: ''!!SmaCCVariableDefinition class methodsFor: 'private'!pluralNameFor: aString	| size |	(self pluralNameBlock value: aString)		ifNotNil: [ :result | ^ result ].	size := aString size.	1 to: size do:		[ :i | 		(self pluralNames			at: (aString copyFrom: size - i + 1 to: size)			ifAbsent: [ nil ])			ifNotNil: [ :ending | ^ (aString copyFrom: 1 to: size - i) , ending ] ].	^ aString copyWith: $s! !!SmaCCVariableDefinition class methodsFor: 'accessing'!pluralNames	PluralNames isNil		ifTrue:			[ PluralNames := Dictionary new.			PluralNames				at: 's' put: 'ses';				at: 'y' put: 'ies';				at: 'x' put: 'xes';				at: 'ch' put: 'ches' ].	^ PluralNames! !!SmaCCVariableDefinition class methodsFor: 'accessing'!pluralNameBlock	^ PluralNameBlock ifNil: [ ^ [ :value | nil ] ]! !!SmaCCVariableDefinition class methodsFor: 'accessing'!pluralNames: aDictionary	PluralNames := aDictionary! !!SmaCCVariableDefinition class methodsFor: 'accessing'!assignIndices: aCollection	aCollection keysAndValuesDo: [ :index :each | each index: index ]! !!SmaCCVariableDefinition class methodsFor: 'accessing'!pluralNameBlock: aBlock	PluralNameBlock := aBlock! !!SmaCCVariableDefinition class methodsFor: 'instance creation'!variableName: aString	^ self new		variableName: aString;		isCollection: false;		yourself! !SmaCCReduceCode subclass: #SmaCCVariableReduceCode	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCVariableReduceCode commentStamp: '' prior: 0!SmaCCVariableReduceCode represents a reduce action that returns a collection of objects that represent the variables defined by the rhs. When this is pulled up into a create node, it will use the variable collection to create the node.!!SmaCCVariableReduceCode methodsFor: 'public'!returnsVariableCollection	^ true! !!SmaCCVariableReduceCode methodsFor: 'accessing'!source	^ self codeGenerator variableArrayAction: rhs! !!SmaCCVariableReduceCode methodsFor: 'private'!basicModelTypes: aSet	^ Array with: (self model classFor: OrderedCollection)! !SmaCCClassDefinition subclass: #SmaCCVisitorClassDefinition	instanceVariableNames: 'nodeClassDefinitions'	classVariableNames: ''	package: 'SmaCC_Development-Compilation Model'!!SmaCCVisitorClassDefinition commentStamp: '' prior: 0!SmaCCVisitorClassDefinition represents the visitor class for the grammar.Instance Variables	nodeClassDefinitions	<Collection of: SmaCCNodeClassDefinition>	the node classes to create the visitor for!!SmaCCVisitorClassDefinition methodsFor: 'compiling'!compileVisitMethodFor: aSmaCCNodeClassDefinition	self codeGenerator		compileVisitMethodFor: aSmaCCNodeClassDefinition		visitor: self! !!SmaCCVisitorClassDefinition methodsFor: 'compiling'!compileMethodsAndVariables	nodeClassDefinitions do: [ :each | self compileVisitMethodFor: each ].	self codeGenerator		compileAcceptNodeMethodFor: self		rootNode: grammar rootDefinition! !!SmaCCVisitorClassDefinition methodsFor: 'initialize-release'!nodeClassDefinitions: aCollection	nodeClassDefinitions := aCollection! !!SmaCCVisitorClassDefinition methodsFor: 'private'!rootClassName	^ SmaCCParseNodeVisitor name! !!SmaCCVisitorClassDefinition methodsFor: 'accessing'!name	^ self modelClass name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCVisitorClassDefinition class	instanceVariableNames: ''!!SmaCCVisitorClassDefinition class methodsFor: 'instance creation'!forClassDefinitions: aCollection	^ self new		nodeClassDefinitions: aCollection;		yourself! !SmaCCDefaultNodeReduceCode initialize!Object subclass: #SmaCCAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCAction commentStamp: '' prior: 0!SmaCCAction is an abstract class that represent actions (shift, reduce, accept, reject) in the LR parser to be performed for a specific state/symbol pair. Subclasses must implement the following messages:	accessing		id		lr1Item	private		mergeWith:prefer:!!SmaCCAction methodsFor: 'error handling'!signalAllWarnings	! !!SmaCCAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	^ self subclassResponsibility! !!SmaCCAction methodsFor: 'comparing'!= anObject	^ self class = anObject class		and: [ self symbol = anObject symbol and: [ self rhs = anObject rhs ] ]! !!SmaCCAction methodsFor: 'comparing'!hash	^ self symbol hash bitXor: self rhs hash! !!SmaCCAction methodsFor: 'testing'!isReject	^ false! !!SmaCCAction methodsFor: 'testing'!isReduce	^ false! !!SmaCCAction methodsFor: 'testing'!isShift	^ false! !!SmaCCAction methodsFor: 'testing'!isAmbiguous	^ false! !!SmaCCAction methodsFor: 'accessing'!size	^ self rhs size! !!SmaCCAction methodsFor: 'accessing'!precedence	^ self lr1Item precedence! !!SmaCCAction methodsFor: 'accessing'!preferredAction	^ self! !!SmaCCAction methodsFor: 'accessing'!symbol	^ self rhs productionSymbol! !!SmaCCAction methodsFor: 'accessing'!rhs	^ self lr1Item rhs! !!SmaCCAction methodsFor: 'accessing'!lr1Item	^ self subclassResponsibility! !!SmaCCAction methodsFor: 'accessing'!id	^ self subclassResponsibility! !SmaCCAction subclass: #SmaCCCompositeAction	instanceVariableNames: 'actions'	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCCompositeAction commentStamp: '' prior: 0!SmaCCCompositeAction is an abstract class that represents multiple actions. Subclasses must implement the following messages:	accessing		errorType		preferredActionInstance Variables:	actions	<Collection of: SmaCCAction>	all valid non-reject actions!!SmaCCCompositeAction methodsFor: 'printing'!printPathOn: aStream	self lr1Item path		do: [ :each | aStream nextPutAll: each name ]		separatedBy: [ aStream space ]! !!SmaCCCompositeAction methodsFor: 'error handling'!raiseXReduceNotification	| stream |	stream := WriteStream with: String new.	actions		do:			[ :each | 			stream nextPutAll: each lr1Item printString.			each == self preferredAction				ifTrue: [ stream nextPutAll: '	*****' ].			stream cr ].	stream cr.	self printPathOn: stream.	SmaCCCompilationNotification new		messageText: self errorType;		tag: stream contents;		signal! !!SmaCCCompositeAction methodsFor: 'error handling'!signalAllWarnings	self raiseXReduceNotification! !!SmaCCCompositeAction methodsFor: 'error handling'!errorType	self subclassResponsibility! !!SmaCCCompositeAction methodsFor: 'accessing'!lr1Item	^ self preferredAction lr1Item! !!SmaCCCompositeAction methodsFor: 'accessing'!preferredAction	self subclassResponsibility! !!SmaCCCompositeAction methodsFor: 'accessing'!id	^ self preferredAction id! !!SmaCCCompositeAction methodsFor: 'initialize-release'!initialize	super initialize.	actions := OrderedCollection new! !!SmaCCCompositeAction methodsFor: 'accessing-actions'!addActions: aSmaCCActionCollection	actions addAll: aSmaCCActionCollection! !!SmaCCCompositeAction methodsFor: 'accessing-actions'!addAction: aSmaCCAction	actions add: aSmaCCAction! !!SmaCCCompositeAction methodsFor: 'accessing-actions'!actions	^ actions! !SmaCCCompositeAction subclass: #SmaCCAmbiguousAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCAmbiguousAction commentStamp: '' prior: 0!SmaCCAmbiguousAction represents several conflicting actions for a state/symbol. If we are creating a GLR parser then all actions will be performed. Otherwise, we'll pick one of the actions to be performed preferring shift actions over reduce actions.!!SmaCCAmbiguousAction methodsFor: 'accessing-actions'!addAction: aSmaCCAction	aSmaCCAction isAmbiguous		ifTrue: [ actions addAll: aSmaCCAction actions ]		ifFalse: [ super addAction: aSmaCCAction ]! !!SmaCCAmbiguousAction methodsFor: 'accessing'!sortedActions	"When in doubt shift the token"	^ actions asSortedCollection: [ :a :b | a id <= b id ]! !!SmaCCAmbiguousAction methodsFor: 'accessing'!preferredAction	^ self sortedActions first! !!SmaCCAmbiguousAction methodsFor: 'testing'!isAmbiguous	^ true! !!SmaCCAmbiguousAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReject		ifTrue: [ ^ self ].	aSmaCCAction isAmbiguous		ifTrue: [ actions addAll: aSmaCCAction actions ]		ifFalse: [ actions add: aSmaCCAction ].	^ self! !!SmaCCAmbiguousAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	| currentState uniqueActions |	currentState := aParserSimulator currentParserState.	uniqueActions := self uniqueActions.	2 to: uniqueActions size do: [ :i | 		aParserSimulator duplicateState.		(actions at: i) simulateOn: aParserSimulator token: aSmaCCToken.		aParserSimulator processToken.		aParserSimulator restoreState: currentState andToken: aSmaCCToken ].	uniqueActions first simulateOn: aParserSimulator token: aSmaCCToken! !!SmaCCAmbiguousAction methodsFor: '*SmaCC_Debugging_Support'!uniqueActions	| hasShift |	hasShift := false.	^ actions		reject: [ :each | 			| previousHasShift |			each isShift				and: [ previousHasShift := hasShift.					hasShift := true.					previousHasShift ] ]! !!SmaCCAmbiguousAction methodsFor: 'error handling'!errorType	| sortedActions |	sortedActions := self sortedActions.	^ sortedActions first class = sortedActions last class		ifTrue: [ 'Reduce/Reduce Conflict' ]		ifFalse: [ 'Shift/Reduce Conflict' ]! !SmaCCCompositeAction subclass: #SmaCCPreferredCompositeAction	instanceVariableNames: 'preferredAction'	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCPreferredCompositeAction commentStamp: '' prior: 0!SmaCCPreferredCompositeAction is a composite action that has a preferred action. The preferred action is used in the state/symbol table.Instance Variables:	preferredAction	<SmaCCAction>	the preferred action!!SmaCCPreferredCompositeAction methodsFor: 'initialize-release'!preferredAction: aSmaCCAction	preferredAction := aSmaCCAction! !!SmaCCPreferredCompositeAction methodsFor: 'accessing'!preferredAction	^ preferredAction! !!SmaCCPreferredCompositeAction methodsFor: 'error handling'!errorType	^ 'Shift/Reduce Conflict (handled by precedence rules)'! !!SmaCCPreferredCompositeAction methodsFor: 'private'!reduceAction	^ actions detect: [ :each | each isReduce ]! !!SmaCCPreferredCompositeAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReduce		ifTrue:			[ self reduceAction = aSmaCCAction				ifTrue: [ ^ self ].			^ SmaCCAmbiguousAction new				addAction: aSmaCCAction;				addActions: actions;				yourself ].	aSmaCCAction isShift		ifTrue: [ self addAction: aSmaCCAction.			^ self ].	^ aSmaCCAction mergeWith: self prefer: aClass! !!SmaCCPreferredCompositeAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	preferredAction simulateOn: aParserSimulator token: aSmaCCToken! !SmaCCAction subclass: #SmaCCPrimitiveAction	instanceVariableNames: 'lr1Item'	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCPrimitiveAction commentStamp: '' prior: 0!SmaCCPrimitiveAction is an abstract class that represents a basic LR state/symbol action (shift, reduce, accept, or reject).Instance Variables:	lr1Item	<SmaCCLR1Item>	the item that the action is for!!SmaCCPrimitiveAction methodsFor: 'accessing'!lr1Item	^ lr1Item! !!SmaCCPrimitiveAction methodsFor: 'accessing'!id	^ self class id! !!SmaCCPrimitiveAction methodsFor: 'initialize-release'!lr1Item: aSmaCCLR1Item	lr1Item := aSmaCCLR1Item! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCPrimitiveAction class	instanceVariableNames: ''!!SmaCCPrimitiveAction class methodsFor: 'instance creation'!item: aSmaCCLR1Item	^ self new		lr1Item: aSmaCCLR1Item;		yourself! !!SmaCCPrimitiveAction class methodsFor: 'accessing'!id	^ nil! !SmaCCPrimitiveAction subclass: #SmaCCAcceptAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCAcceptAction commentStamp: '' prior: 0!SmaCCAcceptAction represents the LR accept action.!!SmaCCAcceptAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	^ self! !!SmaCCAcceptAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator accept.	aParserSimulator processedToken! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCAcceptAction class	instanceVariableNames: ''!!SmaCCAcceptAction class methodsFor: 'accessing'!id	^ 2r00! !SmaCCPrimitiveAction subclass: #SmaCCReduceAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCReduceAction commentStamp: '' prior: 0!SmaCCReduceAction represents the LR reduce action.!!SmaCCReduceAction methodsFor: 'testing'!isReduce	^ true! !!SmaCCReduceAction methodsFor: 'merging'!mergeWithReduceAction: aSmaCCAction	self = aSmaCCAction		ifTrue: [ ^ self ].	^ SmaCCAmbiguousAction new		addAction: self;		addAction: aSmaCCAction;		yourself! !!SmaCCReduceAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isReduce		ifTrue: [ ^ self mergeWithReduceAction: aSmaCCAction ].	^ aSmaCCAction mergeWith: self prefer: aClass! !!SmaCCReduceAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	| items |	items := aParserSimulator popItems: lr1Item rhs size.	aParserSimulator		pushObject: (SmaCCReducedItem reduced: lr1Item rhs with: items)		andState:			(aParserSimulator				moveOn: lr1Item rhs productionSymbol				from: aParserSimulator parserStateId)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReduceAction class	instanceVariableNames: ''!!SmaCCReduceAction class methodsFor: 'accessing'!id	^ 2r10! !!SmaCCReduceAction class methodsFor: 'instance creation'!rhs: aSmaCCRHS	^ self new		rhs: aSmaCCRHS;		yourself! !SmaCCPrimitiveAction subclass: #SmaCCRejectAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCRejectAction commentStamp: '' prior: 0!SmaCCRejectAction represents the LR reject action.!!SmaCCRejectAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	^ aSmaCCAction! !!SmaCCRejectAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator killStateFrom: aSmaCCToken.	aParserSimulator processedToken! !!SmaCCRejectAction methodsFor: 'testing'!isReject	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRejectAction class	instanceVariableNames: ''!!SmaCCRejectAction class methodsFor: 'accessing'!id	^ 2r11! !SmaCCPrimitiveAction subclass: #SmaCCShiftAction	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Actions'!!SmaCCShiftAction commentStamp: '' prior: 0!SmaCCShiftAction represents the LR shift action.!!SmaCCShiftAction methodsFor: '*SmaCC_Debugging_Support'!simulateOn: aParserSimulator token: aSmaCCToken	aParserSimulator		pushObject: aSmaCCToken		andState:			(aParserSimulator				moveOn: (aParserSimulator symbolForId: aSmaCCToken ids first)				from: aParserSimulator parserStateId).	aParserSimulator processedToken! !!SmaCCShiftAction methodsFor: 'testing'!isShift	^ true! !!SmaCCShiftAction methodsFor: 'merging'!mergeWithReduceAction: aSmaCCAction prefer: aClass	| result |	(self precedence isNil or: [ aSmaCCAction precedence isNil ])		ifTrue:			[ ^ SmaCCAmbiguousAction new				addAction: self;				addAction: aSmaCCAction;				yourself ].	result := self.	self precedence < aSmaCCAction precedence		ifTrue: [ result := aSmaCCAction ].	self precedence = aSmaCCAction precedence		ifTrue:			[ aSmaCCAction class = aClass				ifTrue: [ result := aSmaCCAction ].			aClass = SmaCCRejectAction				ifTrue: [ result := SmaCCRejectAction item: self lr1Item ] ].	^ SmaCCPreferredCompositeAction new		addAction: self;		addAction: aSmaCCAction;		preferredAction: result;		yourself! !!SmaCCShiftAction methodsFor: 'merging'!mergeWith: aSmaCCAction prefer: aClass	aSmaCCAction isShift		ifTrue: [ ^ self ].	aSmaCCAction isReduce		ifTrue: [ ^ self mergeWithReduceAction: aSmaCCAction prefer: aClass ].	^ aSmaCCAction mergeWith: self prefer: aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCShiftAction class	instanceVariableNames: ''!!SmaCCShiftAction class methodsFor: 'accessing'!id	^ 2r01! !Object subclass: #SmaCCCodeGenerator	instanceVariableNames: 'parserClass scannerClass model codeStream reduceActionCache ambiguousActions grammar defaultCategory'	classVariableNames: ''	package: 'SmaCC_Development-Compiler'!!SmaCCCodeGenerator commentStamp: '' prior: 0!SmaCCCodeGenerator is an abstract class that is used to generate code. Subclasses are used to generate code for a particular language (e.g., Smalltalk, Java, etc.).Subclasses must implement the following messages:	code generation templates		comment:		method:type:		method:type:argumentName:argumentType:		method:type:argumentName:argumentType:argumentName:argumentType:		reduceAction:		send:to:with:		send:to:with:with:		send:to:with:with:with:		superMessage:		superMessage:argument:		superMessage:argument:argument:		variableReference:in:	compiling		compileChanges		compileMethodWithoutFormattingIn:		compileScannerClassIntoParser		outputStreamClass		removeOldMethods	compiling-nodes		compileInitializeMethod:	compiling-scanner		acceptStateEdge:		closestIsExpressionsFor:seen:		compileKeywordInitializerUsing:		defineClass:asSubclassOf:		outputInvertedMatchFor:on:		outputIsSelector:on:		outputMatchFor:on:without:		scannerActionFor:		scannerClass:		selectorMap:		writeMatchingCodeFor:	private		addVariable:forDefinition:		defaultNodeReductionSource:		removeOldMethodsFrom:		send:to:		writeTransitionTableEntry:on:firstIsType:	reduction table		basicCompileSourceFor:		defaultReductionSourceInstance Variables	ambiguousActions	<SequenceableCollection of: SequenceableCollection>	the ambiguous actions for the grammar	codeStream	<Stream>	a stream for writing the code	grammar	<SmaCCGrammar>	the grammar we are compiling	model	<RBRootNamespace>	the model for the system that we are compiling	parserClass	<RBClass>	the model's class for the parser	reduceActionCache	<Dictionary key: SmaCCReduceAction value: String>	mapping from reduce actions to their code	scannerClass	<RBClass>	the model's class for the scanner!!SmaCCCodeGenerator methodsFor: 'reduction table'!singleVariableCollectionFor: reduceCode	| variable recursionIndex |	variable := reduceCode rhs productionSymbol variableDefinitions asArray first variableName.	self resetCodeStream.	recursionIndex := reduceCode indices		detect:			[:i | 			| symbol |			symbol := reduceCode rhs at: i.			symbol isNode not and: [symbol isCollection: variable]]		ifNone: [0].	self nextPutLine: (self variableDeclaration: 'result' ofType: self arrayType).	self		nextPutStatement:			(self				assignmentTo: 'result'				from:					(recursionIndex = 0						ifTrue: [self newCollectionOfSize: 2]						ifFalse: [self cast: (self argumentIndex: recursionIndex) to: self collectionType])).	reduceCode indices		do:			[:i | 			i = recursionIndex				ifFalse:					[| symbol |					symbol := reduceCode rhs at: i.					self						nextPutStatement:							((symbol isNode not and: [symbol isCollection: variable])								ifTrue:									[self										perform: (recursionIndex > i ifTrue: [#addAllFirstSendTo:with:] ifFalse: [#addAllSendTo:with:])										with: 'result'										with: (self argumentIndex: i)]								ifFalse:									[self										perform: (recursionIndex > i ifTrue: [#addFirstSendTo:with:] ifFalse: [#addSendTo:with:])										with: 'result'										with: (self argumentIndex: i)])]].	self nextPutStatement: (self return: 'result').	self nextPutLine: ''.	^self codeStream contents! !!SmaCCCodeGenerator methodsFor: 'reduction table'!pullUpVariableFrom: aSmaCCSymbol into: aSmaCCRHS index: anInteger first: aBoolean	| variableValue rhsIndex variable |	variable := aSmaCCSymbol variableDefinitions first.	variableValue := self argumentIndex: anInteger.	rhsIndex := aSmaCCRHS productionSymbol				indexOfVariable: variable variableName.	self		nextPutStatement: ((aSmaCCRHS productionSymbol				isCollection: variable variableName)					ifTrue: 						[| collectionValue |						collectionValue := self cast: (self at: 'result' index: rhsIndex)									to: self collectionType.						(aSmaCCSymbol isCollection: variable variableName)							ifTrue: 								[self									perform: (aBoolean											ifTrue: [#addAllFirstSendTo:with:]											ifFalse: [#addAllSendTo:with:])									with: collectionValue									with: (self cast: variableValue to: self collectionType)]							ifFalse: 								[self									perform: (aBoolean											ifTrue: [#addFirstSendTo:with:]											ifFalse: [#addSendTo:with:])									with: collectionValue									with: variableValue]]					ifFalse: [self assignArray: 'result' index: rhsIndex to: variableValue])! !!SmaCCCodeGenerator methodsFor: 'reduction table'!createNodeReduceAction: aSmaCCRHS	^ self createNodeReduceAction: aSmaCCRHS pullUpFrom: 0! !!SmaCCCodeGenerator methodsFor: 'reduction table'!variableArrayAction: aSmaCCRHS	| recursionIndex |	self resetCodeStream.	recursionIndex := self recursionIndexFor: aSmaCCRHS.	recursionIndex = 0		ifTrue: [self createVariableArrayFor: aSmaCCRHS]		ifFalse: [self pullUpVariableArrayFor: aSmaCCRHS index: recursionIndex].	aSmaCCRHS collection keysAndValuesDo: 			[:key :value |			key = recursionIndex				ifFalse: 					[| variableName |					variableName := aSmaCCRHS variableNameForIndex: key.					variableName isNil						ifTrue: 							[value returnsVariableCollection								ifTrue: 									[self										pullUpVariablesFrom: value										into: aSmaCCRHS										index: key										first: recursionIndex > key]								ifFalse: 									[value returnsSingleVariable										ifTrue: 											[self												pullUpVariableFrom: value												into: aSmaCCRHS												index: key												first: recursionIndex > key]										ifFalse: 											[value modelType = (self model classFor: nil class)												ifFalse: [aSmaCCRHS generateUnnamedSymbolWarningFor: key]]]]						ifFalse: 							[value returnsVariableCollection								ifTrue: [aSmaCCRHS generateNamedVariableCollectionWarningFor: key].							self								assignVariable: variableName								in: aSmaCCRHS								at: key								first: recursionIndex > key]]].	self nextPutStatement: (self return: 'result').	self nextPutLine: ''.	^self codeStream contents! !!SmaCCCodeGenerator methodsFor: 'reduction table'!defaultReductionSource	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'reduction table'!basicCompileSourceFor: aSmaCCReduceAction	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'reduction table'!pullUpVariableArrayFor: aSmaCCRHS index: recursionIndex	self nextPutLine: (self variableDeclaration: 'result' ofType: self arrayType).	self nextPutStatement: (self assignmentTo: 'result' from: (self cast: (self argumentIndex: recursionIndex) to: self collectionType))! !!SmaCCCodeGenerator methodsFor: 'reduction table'!createVariableArrayFor: aSmaCCRHS	self		nextPutLine: (self variableDeclaration: 'result' ofType: self arrayType).	self		nextPutStatement:			(self				assignmentTo: 'result'				from: (self initializeResultForReduceAction: aSmaCCRHS)).	self initializeArrayContentsToNull: aSmaCCRHS.	aSmaCCRHS productionSymbol collectionVariableDefinitions		do:			[ :each | 			self				nextPutStatement:					(self						assignArray: 'result'						index: each index						to: (self newCollectionOfSize: 2)) ]! !!SmaCCCodeGenerator methodsFor: 'reduction table'!compileSourceFor: aSmaCCReduceAction	^ reduceActionCache		at: aSmaCCReduceAction		ifAbsentPut: [ self basicCompileSourceFor: aSmaCCReduceAction ]! !!SmaCCCodeGenerator methodsFor: 'reduction table'!createNodeReduceAction: aSmaCCRHS pullUpFrom: anInteger	self resetCodeStream.	self		nextPutLine: (self variableDeclaration: 'result' ofType: aSmaCCRHS modelType name).	self		nextPutStatement:			(self				assignmentTo: 'result'				from:					(anInteger isZero						ifTrue: [ self newObject: aSmaCCRHS modelType name ]						ifFalse:							[ self								cast: (self argumentIndex: anInteger)								to: aSmaCCRHS modelType name ])).	SmaCCReduceActionGenerator		generate: aSmaCCRHS		pullUp: anInteger		on: self.	self nextPutStatement: (self return: 'result').	^ self codeStream contents! !!SmaCCCodeGenerator methodsFor: 'reduction table'!assignVariable: variableName in: aSmaCCRHS at: key first: aBoolean	| variableIndex value |	variableIndex := aSmaCCRHS productionSymbol indexOfVariable: variableName.	value := self argumentIndex: key.	self		nextPutStatement: ((aSmaCCRHS productionSymbol isCollection: variableName)				ifTrue: 					[self						perform: (aBoolean								ifTrue: [#addFirstSendTo:with:]								ifFalse: [#addSendTo:with:])						with: (self cast: (self at: 'result' index: variableIndex)								to: self collectionType)						with: value]				ifFalse: [self assignArray: 'result' index: variableIndex to: value])! !!SmaCCCodeGenerator methodsFor: 'reduction table'!pullUpVariablesFrom: aSmaCCSymbol into: aSmaCCRHS index: anInteger first: aBoolean	aSmaCCSymbol variableDefinitions do: 			[:each |			| variableValue rhsIndex |			variableValue := self argumentIndex: anInteger						subIndex: (aSmaCCSymbol indexOfVariable: each variableName).			rhsIndex := aSmaCCRHS productionSymbol indexOfVariable: each variableName.			self				nextPutStatement: ((aSmaCCRHS productionSymbol						isCollection: each variableName)							ifTrue: 								[| collectionValue |								collectionValue := self cast: (self at: 'result' index: rhsIndex)											to: self collectionType.								(aSmaCCSymbol isCollection: each variableName)									ifTrue: 										[self											perform: (aBoolean													ifTrue: [#addAllFirstSendTo:with:]													ifFalse: [#addAllSendTo:with:])											with: collectionValue											with: (self cast: variableValue to: self collectionType)]									ifFalse: 										[self											perform: (aBoolean													ifTrue: [#addFirstSendTo:with:]													ifFalse: [#addSendTo:with:])											with: collectionValue											with: variableValue]]							ifFalse: [self assignArray: 'result' index: rhsIndex to: variableValue])]! !!SmaCCCodeGenerator methodsFor: 'private'!nonKeywordNameFor: aString	| word |	word := aString.	[ self keywords includes: word ] whileTrue: [ word := '_' , word ].	^ word! !!SmaCCCodeGenerator methodsFor: 'private'!addParentAssignmentFor: aSmaCCVariableDefinition to: valueString	aSmaCCVariableDefinition isBaseNodeType		ifFalse: [ ^ self ].	aSmaCCVariableDefinition isCollection		ifTrue:			[ self				nextPutStatement:					(self						send: #setParents:to:						to: self receiverName						with:							(self								cast:									(self										variableReference: aSmaCCVariableDefinition										in: self receiverName)								to: self collectionType)						with: valueString) ]		ifFalse:			[ self				nextPutLine:					(self						notNilCheckFor:							(self								variableReference: aSmaCCVariableDefinition								in: self receiverName)).			self				nextPutStatement:					(self						send: #parent:						to:							(self								cast:									(self										variableReference: aSmaCCVariableDefinition										in: self receiverName)								to: 'ParseNode')						with: valueString).			self nextPutStatement: self endConditionalString ]! !!SmaCCCodeGenerator methodsFor: 'private'!startStaticPrivateMethod	self resetCodeStream.	self codeStream		nextPutAll: self static;		nextPutAll: self private! !!SmaCCCodeGenerator methodsFor: 'private'!maxJumpSize	^ SmallInteger maxVal! !!SmaCCCodeGenerator methodsFor: 'private'!startStaticMethod	self resetCodeStream.	self codeStream nextPutAll: self static! !!SmaCCCodeGenerator methodsFor: 'private'!writeTransitionTableMethod: stream withIndex: index withArray: array	self		startStaticPrivateMethod;		nextPutLine:			(self				method: 'transitionTable' , index printString				type: self voidType				argumentName: array				argumentType: self unsignedShortArrayArray);		nextPutStatement: stream contents;		endMethod;		compileMethodWithoutFormattingIn: parserClass! !!SmaCCCodeGenerator methodsFor: 'private'!nodeType	^ (model classFor: SmaCCParseNode) name! !!SmaCCCodeGenerator methodsFor: 'private'!keywords	^ #()! !!SmaCCCodeGenerator methodsFor: 'private'!startProtectedVirtualMethod	self resetCodeStream.	self codeStream		nextPutAll: self protected;		nextPutAll: self virtual! !!SmaCCCodeGenerator methodsFor: 'private'!model	^ model! !!SmaCCCodeGenerator methodsFor: 'private'!startPublicOverrideMethod	self resetCodeStream.	self codeStream		nextPutAll: self public;		nextPutAll: self override! !!SmaCCCodeGenerator methodsFor: 'private'!parseSourceSelector	^ self class parseSourceSelector! !!SmaCCCodeGenerator methodsFor: 'private'!outputStream	^ self outputStreamClass with: String new! !!SmaCCCodeGenerator methodsFor: 'private'!nextPutStatement: aString	self codeStream		nextPutAll: aString;		nextPutAll: self statementSeparator;		cr! !!SmaCCCodeGenerator methodsFor: 'private'!defaultNodeReductionSource: aReduction	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'private'!send: selector to: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'private'!startProtectedOverrideMethod	self resetCodeStream.	self codeStream		nextPutAll: self protected;		nextPutAll: self override! !!SmaCCCodeGenerator methodsFor: 'private'!resetCodeStream	codeStream := nil! !!SmaCCCodeGenerator methodsFor: 'private'!methodNameFor: aString	^ aString! !!SmaCCCodeGenerator methodsFor: 'private'!removeOldMethodsFrom: aRBClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'private'!writeTransitionTableEntry: anArray on: aStream firstIsType: aBoolean	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'private'!addVariable: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'private'!endMethod	self codeStream nextPutAll: self endMethodString! !!SmaCCCodeGenerator methodsFor: 'private'!compileAcceptVisitorMethod: aSmaCCNodeClassDefinition visitor: aSmaCCVisitorClassDefinition	aSmaCCNodeClassDefinition isRoot		ifTrue: [ self startPublicVirtualMethod ]		ifFalse: [ self startPublicOverrideMethod ].	self		nextPutLine:			(self				method: #acceptVisitor:				type: self objectType				argumentName: aSmaCCNodeClassDefinition tempNodeName , 'Visitor'				argumentType: aSmaCCVisitorClassDefinition fullName);		nextPutStatement:			(self				return:					(self						send: 'visit' , aSmaCCNodeClassDefinition name , ':'						to: aSmaCCNodeClassDefinition tempNodeName , 'Visitor'						with: self receiverName));		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass! !!SmaCCCodeGenerator methodsFor: 'private'!nextPutLine: aString	self codeStream		nextPutAll: aString;		cr! !!SmaCCCodeGenerator methodsFor: 'private'!recursionIndexFor: aSmaCCRHS	| vars index recursionIndex |	index := 1.	recursionIndex := 0.	vars := aSmaCCRHS productionSymbol variableDefinitions.	aSmaCCRHS do: 			[:each |			(each returnsVariableCollection and: 					[| rhsVars |					rhsVars := each variableDefinitions.					rhsVars size = vars size and: 							[(1 to: rhsVars size) allSatisfy: 									[:i |									| var otherVar |									var := rhsVars at: i.									otherVar := vars at: i.									var variableName = otherVar variableName										and: [var isCollection = otherVar isCollection]]]])				ifTrue: [recursionIndex := index].			index := index + 1].	^recursionIndex! !!SmaCCCodeGenerator methodsFor: 'private'!codeStream	codeStream isNil		ifTrue: [ codeStream := self outputStream ].	^ codeStream! !!SmaCCCodeGenerator methodsFor: 'private'!startPublicVirtualMethod	self resetCodeStream.	self codeStream		nextPutAll: self public;		nextPutAll: self virtual! !!SmaCCCodeGenerator methodsFor: 'accessing'!grammar: aSmaCCGrammar	grammar := aSmaCCGrammar! !!SmaCCCodeGenerator methodsFor: 'accessing'!objectClass	^ model classFor: Object! !!SmaCCCodeGenerator methodsFor: 'accessing'!commonSupertypeOf: aCollection	aCollection isEmpty		ifTrue: [ ^ self objectClass ].	^ aCollection		inject: aCollection anyOne		into: [ :sum :each | self commonSupertypeBetween: sum and: each ]! !!SmaCCCodeGenerator methodsFor: 'accessing'!namespaceName	^ ''! !!SmaCCCodeGenerator methodsFor: 'accessing'!commonSupertypeBetween: modelClass and: anotherModelClass	^ (anotherModelClass includesClass: modelClass)		ifTrue: [ modelClass ]		ifFalse:			[ (modelClass includesClass: anotherModelClass)				ifTrue: [ anotherModelClass ]				ifFalse:					[ self						commonSupertypeBetween: modelClass superclass						and: anotherModelClass ] ]! !!SmaCCCodeGenerator methodsFor: 'accessing'!grammar	^ grammar! !!SmaCCCodeGenerator methodsFor: 'compiling'!removeOldMethods	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileOptimizedMethodIn: modelClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileReductionTable: reductionTable	| stream |	stream := self outputStream.	stream nextPutAll: self reduceActionLiteralStart.	reductionTable		do:			[ :each | 			stream				cr;				tab;				nextPutAll: (self reduceAction: each) ]		separatedBy: [ stream nextPutAll: self literalArraySeparator ].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startProtectedOverrideMethod;		nextPutLine: (self method: 'reduceTable' type: self reduceActionArrayType);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass theMetaClass! !!SmaCCCodeGenerator methodsFor: 'compiling'!outputStreamClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling'!parserClass	^ parserClass! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileNodeClassDefinition: aSmaCCClassDefinition	| class |	class := self		defineClass: aSmaCCClassDefinition fullName		asSubclassOf: (self model classNamed: aSmaCCClassDefinition superclassName asSymbol).	aSmaCCClassDefinition modelClass: class.	self removeOldMethodsFrom: class.	self removeOldMethodsFrom: class theMetaClass! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileDefinitionComment: aString	self		startPublicVirtualMethod;		nextPutLine: (self method: #definitionComment type: self voidType);		nextPutLine: (self comment: aString);		endMethod.	self compileMethodWithoutFormattingIn: parserClass theMetaClass! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileScannerClassIntoParser	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileChanges	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling'!compileMethodWithoutFormattingIn: modelClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'initialize-release'!defaultCategory: aSymbol	defaultCategory := aSymbol! !!SmaCCCodeGenerator methodsFor: 'initialize-release'!initialize	super initialize.	reduceActionCache := Dictionary new.	ambiguousActions := OrderedCollection new! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!method: aString type: anObject argumentName: firstArgumentNameString argumentType: firstArgumentTypeString argumentName: secondArgumentNameString argumentType: secondArgumentTypeString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!argumentIndex: anInteger	^ self at: 'nodes' index: anInteger! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!method: aString type: typeString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString with: thirdArgumentString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!superMessage: aString argument: firstArgumentString argument: secondArgumentString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!reduceAction: anArray	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!variableReference: aSmaCCVariableDefinition in: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!doesNotUnderstand: failedMessage	"Use the code templates to expand the string."	^ (self class codeTemplates		at: failedMessage selector		ifAbsent: [ ^ super doesNotUnderstand: failedMessage ])		expandMacrosWithArguments: failedMessage arguments! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!superMessage: aString argument: argumentString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!variableReference: aSmaCCVariableDefinition	^ self nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!superMessage: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!method: aString type: anObject argumentName: argumentNameString argumentType: argumentTypeString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!argumentIndex: anInteger subIndex: subIndex	^ self		at: (self cast: (self argumentIndex: anInteger) to: self collectionType)		index: subIndex! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!comment: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!endIteratorString	^ self endConditionalString! !!SmaCCCodeGenerator methodsFor: 'code generation templates'!send: selectorString to: receiverString with: argumentString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!acceptStateEdge: aSmaCCStateEdge	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileIgnoreCaseMethods	self grammar ignoreCase		ifFalse: [ ^ self ].	self		startPublicOverrideMethod;		nextPutLine:			(self				method: #keywordFor:				type: self stringType				argumentName: 'aString'				argumentType: self stringType);		nextPutStatement: (self return: (self uppercaseString: 'aString'));		endMethod;		compileMethodIn: scannerClass! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!outputIsSelector: isSelector on: stream	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!acceptCharacterEdge: aSmaCCCharacterEdge seen: aCollection	| stream |	stream := WriteStream with: String new.	aSmaCCCharacterEdge transitionObjects size + aCollection size		> SmaCCGrammar maximumCharacterValue		ifTrue: [ ^ self trueValue ].	stream nextPut: $(.	aSmaCCCharacterEdge transitionObjects size		= SmaCCGrammar maximumCharacterValue		ifTrue: [ self				outputInvertedMatchFor: aSmaCCCharacterEdge				on: stream ]		ifFalse:			[ self				outputMatchFor: aSmaCCCharacterEdge				seen: aCollection				on: stream ].	stream nextPut: $).	^ stream contents! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileNode: aSmaCCNode	| methodNodes methodMap |	methodNodes := self statesToMakeIntoMethodsFor: aSmaCCNode.	methodMap := self methodNameMap: aSmaCCNode forMethods: methodNodes.	methodNodes		do:			[ :each | 			each = aSmaCCNode				ifTrue: [ self startProtectedOverrideMethod ]				ifFalse: [ self startProtectedVirtualMethod ].			self				nextPutLine:					(self						method: (methodMap at: each)						type: (model classFor: SmaCCToken) name).			self asStatement: methodMap forNode: each lastNeedsReturn: true.			self endMethod.			self compileOptimizedMethodIn: scannerClass ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!possiblyGuardNil: each around: aBlock	each isAlwaysAssigned		ifTrue: [ aBlock value ]		ifFalse:			[ self				nextPutLine:					(self						notNilCheckFor: (self variableReference: each in: self receiverName)).			aBlock				ensure: [ self nextPutStatement: self endConditionalString ] ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!outputMatchFor: aSmaCCCharacterEdge on: aStream without: aSelector	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileErrorSymbolTokenId: errorTokenId	self compileTokenIdMethodNamed: 'errorToken' withId: errorTokenId! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!methodNameMap: aSmaCCNode forMethods: methodNodes	| index methodMap |	methodMap := Dictionary new.	index := 0.	methodNodes		do:			[ :value | 			methodMap				at: value				put:					(value = aSmaCCNode						ifTrue: [ #scanForToken ]						ifFalse: [ 'scan' , (index := index + 1) printString ]) ].	^ methodMap! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!defineClass: aString asSubclassOf: aSmaCCClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!selectorMap: aDictionary	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!splitLargeNodes: methodStates	"Split nodes that might generate long jumps that may not compile (longer than 16 bit offset)."	| todo |	todo := OrderedCollection withAll: methodStates.	[ todo notEmpty ]		whileTrue: [ | node |			node := todo removeFirst.			node transitions				do: [ :edge | 					((methodStates includes: edge to) not and: [ (edge to codeSizeEstimate: methodStates) > self maxJumpSize ])						ifTrue: [ methodStates add: edge to.							todo addLast: edge to ] ] ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileStartingStateIds: startingStates	startingStates		keysAndValuesDo:			[ :symbol :position | 			self				startStaticMethod;				nextPutLine:					(self						method: 'startingStateFor' , symbol compileName						type: self unsignedShort);				nextPutStatement: (self return: position printString);				endMethod;				compileMethodIn: parserClass theMetaClass ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compilePostCopyMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!asStatement: methodMap forNode: aSmaCCNode lastNeedsReturn: aBoolean	| transitions seen |	aSmaCCNode hasSimpleLoop		ifTrue: [ self nextPutLine: self startDoWhileLoop ].	self writeMatchingCodeFor: aSmaCCNode.	transitions := self sortedTransitionsForNode: aSmaCCNode.	seen := (transitions notEmpty		ifTrue: [ transitions first setClass ]		ifFalse: [ Set ]) new.	transitions		do:			[ :each | 			each to = aSmaCCNode				ifTrue:					[ self						nextPutStatement: (self endDoWhileLoopWithClause: (each dispatchTo: self seen: seen)) ]				ifFalse:					[ self						nextPutLine: (self startIfWithClause: (each dispatchTo: self seen: seen)).					(methodMap at: each to ifAbsent: [ nil ])						ifNil:							[ self								asStatement: methodMap								forNode: each to								lastNeedsReturn: each ~= transitions last ]						ifNotNil:							[ :methodCall | 							self								nextPutStatement: (self return: (self send: methodCall to: self receiverName)) ].					self nextPutStatement: self endConditionalString ].			seen addAll: each transitionObjects ].	(aBoolean		and: [ aSmaCCNode transitions notEmpty or: [ aSmaCCNode action isNil ] ])		ifTrue:			[ self				nextPutStatement: (self return: (self send: #reportLastMatch to: self receiverName)) ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!initialMethodStatesFor: aSmaCCNode	| allStates incoming |	allStates := aSmaCCNode allStates.	incoming := Dictionary new.	allStates		do:			[ :each | 			each transitions				do:					[ :edge | 					each ~= edge to						ifTrue: [ (incoming at: edge to ifAbsentPut: [ Set new ])								add: each ] ] ].	^ allStates		select:			[ :each | 			aSmaCCNode = each				or:					[ each isTerminalNode not						and: [ (incoming at: each ifAbsent: [ #() ]) size > 1 ] ] ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!closestIsExpressionsFor: aSmaCCCharacterEdge seen: anObject	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!outputMatchFor: aSmaCCCharacterEdge seen: aCollection on: stream	| isSelectors |	isSelectors := self		closestIsExpressionsFor: aSmaCCCharacterEdge		seen: aCollection.	isSelectors		do: [ :each | self outputIsSelector: each on: stream ]		separatedBy: [ stream nextPutAll: ' or: [' ].	self		outputMatchFor: aSmaCCCharacterEdge		on: stream		without: isSelectors! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!writeMatchingCodeFor: aSmaCCNode	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileKeywordInitializerUsing: keywordMapDictionary	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileTokenIdMethodNamed: aString withId: symbolId	self		startPublicOverrideMethod;		nextPutLine: (self method: aString , 'Id' type: self unsignedShort);		nextPutStatement: (self return: symbolId printString);		endMethod;		compileMethodIn: scannerClass! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!scannerClass: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileEmptySymbolTokenId: emptySymbolId	self		compileTokenIdMethodNamed: 'emptySymbolToken'		withId: emptySymbolId! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!statesToMakeIntoMethodsFor: aSmaCCNode	| methodStates |	methodStates := self initialMethodStatesFor: aSmaCCNode.	self splitLargeNodes: methodStates.	^ methodStates asSortedCollection: [ :a :b | a id < b id ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!scannerActionFor: aString	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!sortedTransitionsForNode: aSmaCCNode	^ aSmaCCNode transitions		asSortedCollection:			[ :a :b | 			a isCharacterTransition				and:					[ b isCharacterTransition not						or:							[ | aPairs bPairs |							aPairs := self minMaxPairsFor: a without: #().							bPairs := self minMaxPairsFor: b without: #().							aPairs size < bPairs size								or:									[ aPairs size = bPairs size										and:											[ a transitionObjects size < b transitionObjects size												or: [ a transitionObjects size = b transitionObjects size and: [ a <= b ] ] ] ] ] ] ]! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!minMaxPairsFor: aSmaCCCharacterEdge without: isSelectors	| start last pairs charsLeft |	charsLeft := aSmaCCCharacterEdge transitionObjects.	isSelectors notEmpty		ifTrue: [ charsLeft := charsLeft copy.			isSelectors do: [ :each | charsLeft smaccRemoveAll: (SmaCCGrammar isExpressionMap at: each) ] ].	pairs := OrderedCollection new.	charsLeft isEmpty		ifTrue: [ ^ pairs ].	last := charsLeft first.	start := nil.	charsLeft		do: [ :each | 			last asInteger + 1 = each asInteger				ifFalse: [ start notNil						ifTrue: [ pairs add: (Array with: start with: last) ].					start := each ].			last := each ].	pairs add: (Array with: start with: last).	^ pairs! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!outputInvertedMatchFor: aSmaCCCharacterEdge on: stream	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-scanner'!compileMethodIn: modelClass	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileSymbolNames: anArray	self		startPublicVirtualMethod;		nextPutLine: (self method: 'symbolNames' type: self arrayType);		nextPutStatement: (self return: anArray storeString);		endMethod;		compileMethodIn: self parserClass theMetaClass! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileSymbolTypes	| names |	names := grammar symbols		collect:			[ :each | 			| types previousSize |			types := each modelTypes.			previousSize := types size.			types remove: (self model classFor: nil class) ifAbsent: [  ].			(types isEmpty and: [ previousSize = 1 ])				ifTrue: [ nil ]				ifFalse: [ (self commonSupertypeOf: types) name ] ].	self compileSymbolTypes: names asArray! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!ambiguousTableEntryFor: aCollection	| entry |	entry := aCollection asArray.	^ ambiguousActions		indexOf: entry		ifAbsent: [ ambiguousActions add: entry.			ambiguousActions size ]! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!parserClass: aClassOrString	| name existingClass superclass |	name := (aClassOrString isKindOf: Behavior)		ifTrue: [ aClassOrString name ]		ifFalse: [ aClassOrString ].	superclass := SmaCCParser.	existingClass := Smalltalk at: name asSymbol ifAbsent: [ nil ].	(existingClass notNil		and:			[ (existingClass superclass includesBehavior: superclass)				and: [ (existingClass includesBehavior: SmaCCGLRParser) not ] ])		ifTrue: [ superclass := existingClass superclass ].	(existingClass notNil and: [ defaultCategory isNil ])		ifTrue: [ defaultCategory := existingClass category ].	parserClass := self defineClass: name asSubclassOf: superclass! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!processTransitionTable: transitionTable	| table |	table := OrderedCollection new.	transitionTable do: [ :each | table addLast: each ].	^ table! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileSymbolTypes: anArray	! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileCacheId! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!initializeResultForReduceAction: aSmaCCRHS	^ self		newArrayOfSize: aSmaCCRHS productionSymbol variableDefinitions size! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!setGetterMethodNameTo: aSmaCCVariableDefinition withName: variableName	aSmaCCVariableDefinition		getterMethodName: (self methodNameFor: variableName)! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileAcceptNodeMethodFor: aSmaCCVisitorClassDefinition rootNode: aSmaCCClassDefinition	"Only needed if we are using a brain dead type system"	! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!glrParserClass: aClassOrString	| name existingClass superclass |	name := (aClassOrString isKindOf: Behavior)		ifTrue: [ aClassOrString name ]		ifFalse: [ aClassOrString ].	superclass := SmaCCGLRParser.	existingClass := Smalltalk at: name asSymbol ifAbsent: [ nil ].	(existingClass notNil and: [ existingClass superclass includesBehavior: superclass ])		ifTrue: [ superclass := existingClass superclass ].	(existingClass notNil and: [ defaultCategory isNil ])		ifTrue: [ defaultCategory := existingClass category ].	parserClass := self defineClass: name asSubclassOf: superclass! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileAmbiguousTransitions	| stream |	ambiguousActions isEmpty		ifTrue: [ ^ self ].	stream := self outputStream.	stream nextPutAll: self newUnsignedShortArrayArray.	ambiguousActions		do:			[ :each | self writeTransitionTableEntry: each on: stream firstIsType: false ]		separatedBy: [ stream nextPutAll: self literalArraySeparator ].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startPublicOverrideMethod;		nextPutLine:			(self				method: 'ambiguousTransitions'				type: self unsignedShortArrayArray);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass theMetaClass! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileReductionActions	! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!initializeArrayContentsToNull: aSmaCCRHS	! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileTransitionTable: transitionTable	| stream |	stream := self outputStream.	stream nextPutAll: self newUnsignedShortArrayArray.	transitionTable		do:			[ :each | self writeTransitionTableEntry: each on: stream firstIsType: true ]		separatedBy: [ stream nextPutAll: self literalArraySeparator ].	stream		cr;		tab;		nextPutAll: self endLiteralArray.	self		startPublicOverrideMethod;		nextPutLine: (self method: 'transitionTable' type: self unsignedShortArrayArray);		nextPutStatement: (self return: stream contents);		endMethod;		compileMethodWithoutFormattingIn: parserClass theMetaClass.	self compileAmbiguousTransitions! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!compileSymbolNames	| names |	names := grammar symbols collect: [ :each | each name ].	self compileSymbolNames: names asArray! !!SmaCCCodeGenerator methodsFor: 'compiling-parser'!nextPut: aCharacter	self codeStream nextPut: aCharacter! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileVariablesMethods: aSmaCCNodeClassDefinition	! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileVisitMethodFor: aSmaCCNodeClassDefinition visitor: aSmaCCVisitorClassDefinition	| tempName |	self		compileAcceptVisitorMethod: aSmaCCNodeClassDefinition		visitor: aSmaCCVisitorClassDefinition.	tempName := aSmaCCNodeClassDefinition temporaryVariableName.	self		startPublicVirtualMethod;		nextPutLine:			(self				method: 'visit' , aSmaCCNodeClassDefinition name , ':'				type: self objectType				argumentName: tempName				argumentType: aSmaCCNodeClassDefinition fullName).	self		nextPutStatement:			(self				return:					(self						send:							(aSmaCCNodeClassDefinition superclass notNil								ifTrue: [ 'visit' , aSmaCCNodeClassDefinition superclass name										, ':' ]								ifFalse: [ 'visitSmaCCParseNode:' ])						to: self receiverName						with: tempName));		endMethod;		compileMethodIn: aSmaCCVisitorClassDefinition modelClass! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileEqualMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileChildrenMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileHashMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileCopyInContextMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileGetterAndSetter: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	| type typeName variableName definer |	variableName := self		nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName.	type := aSmaCCVariableDefinition type.	self		setGetterMethodNameTo: aSmaCCVariableDefinition		withName: variableName.	definer := aSmaCCNodeClassDefinition modelClass		whoDefinesMethod: aSmaCCVariableDefinition getterMethodName asSymbol.	(definer isNil or: [ definer = self objectClass ])		ifTrue:			[ self				startPublicVirtualMethod;				nextPutLine:					(self						method: aSmaCCVariableDefinition getterMethodName						type: type name);				nextPutStatement: (self return: (self variableReference: aSmaCCVariableDefinition));				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass ].	aSmaCCVariableDefinition setterMethodName: variableName , ':'.	definer := aSmaCCNodeClassDefinition modelClass		whoDefinesMethod: aSmaCCVariableDefinition setterMethodName asSymbol.	(definer isNil or: [ definer = self objectClass ])		ifFalse: [ ^ self ].	typeName := aSmaCCNodeClassDefinition temporaryNameFor: type name.	self		startPublicVirtualMethod;		nextPutLine:			(self				method: aSmaCCVariableDefinition setterMethodName				type: self voidType				argumentName: typeName				argumentType: type name);		addParentAssignmentFor: aSmaCCVariableDefinition			to: self undefinedObject;		nextPutStatement: (self assignmentTo: variableName from: typeName);		addParentAssignmentFor: aSmaCCVariableDefinition			to: self receiverName;		endMethod;		compileMethodIn: aSmaCCNodeClassDefinition modelClass! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileInitializeMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !!SmaCCCodeGenerator methodsFor: 'compiling-nodes'!compileMatchInContextMethod: aSmaCCNodeClassDefinition	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCCodeGenerator class	instanceVariableNames: 'codeTemplates'!!SmaCCCodeGenerator class methodsFor: 'class initialization'!reset	"self reset"	codeTemplates := nil.	self allSubclassesDo: [ :each | each reset ]! !!SmaCCCodeGenerator class methodsFor: 'code generation templates'!codeTemplatesArray	^ #(#(#override '') #(#trueValue 'true'))! !!SmaCCCodeGenerator class methodsFor: 'code generation templates'!codeTemplates	^ codeTemplates		ifNil:			[ codeTemplates := IdentityDictionary new.			self codeTemplatesArray				do: [ :each | codeTemplates at: each first put: each last ].			codeTemplates ]! !!SmaCCCodeGenerator class methodsFor: 'accessing'!typeName	^ nil! !!SmaCCCodeGenerator class methodsFor: 'accessing'!parseSourceSelector	self subclassResponsibility! !Notification subclass: #SmaCCCompilationNotification	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Compiler'!!SmaCCCompilationNotification commentStamp: '' prior: 0!SmaCCCompilationNotification is a Notification that is signaled when a problem occurs when compiling the parser. It is mainly used to show the user problems with their grammar.!Object subclass: #SmaCCGrammarCompiler	instanceVariableNames: 'shiftTable itemSets startingStateMap actions parserDefinitionString scannerCompiler grammar codeGenerator reduceTable'	classVariableNames: 'OptimizeTransitionTable'	package: 'SmaCC_Development-Compiler'!!SmaCCGrammarCompiler methodsFor: 'private'!checkForUnusedSymbols	self		checkFor: grammar unusedSymbols		errorMessage: 'Unused non-terminal symbols'! !!SmaCCGrammarCompiler methodsFor: 'private'!checkFor: problemSymbols errorMessage: errorMessage	| stream |	problemSymbols isEmpty		ifTrue: [ ^ self ].	stream := WriteStream with: String new.	problemSymbols		do: [ :each | stream nextPutAll: each printString ]		separatedBy: [ stream space ].	SmaCCCompilationNotification new		messageText: errorMessage;		tag: stream contents;		signal! !!SmaCCGrammarCompiler methodsFor: 'private'!checkForEmptySymbols	self		checkFor: grammar emptySymbols		errorMessage: 'Missing non-terminal productions'! !!SmaCCGrammarCompiler methodsFor: 'reduction table'!reduceTableIndexFor: aSmaCCReduceAction	| value |	value := {(scannerCompiler symbols indexOf: aSmaCCReduceAction symbol).	aSmaCCReduceAction rhs size.	(self codeGenerator compileSourceFor: aSmaCCReduceAction).	aSmaCCReduceAction rhs ruleNumber.	aSmaCCReduceAction rhs reduceCode isImmediate}.	^ reduceTable		indexOf: value		ifAbsent: [ reduceTable				add: value;				size ]! !!SmaCCGrammarCompiler methodsFor: 'reduction table'!reduceTable	^ reduceTable! !!SmaCCGrammarCompiler methodsFor: 'compiling'!compileInto: sClass andParser: pClass	self scannerClass: sClass.	self parserClass: pClass.	self createChanges.	self codeGenerator compileChanges! !!SmaCCGrammarCompiler methodsFor: 'compiling'!compileScanner	scannerCompiler compileScanner! !!SmaCCGrammarCompiler methodsFor: 'compiling'!compileParser	self compileNodeClasses.	self codeGenerator		compileTransitionTable: self transitionTable;		compileStartingStateIds: startingStateMap;		compileReductionTable: self reduceTable;		compileReductionActions;		compileScannerClassIntoParser;		compileSymbolNames;		compileCacheId! !!SmaCCGrammarCompiler methodsFor: 'compiling'!compileNodeClasses	SmaCCNodeCalculation compileForGrammar: grammar! !!SmaCCGrammarCompiler methodsFor: 'compiling'!createChanges	self codeGenerator removeOldMethods.	self checkForEmptySymbols.	self checkForUnusedSymbols.	self compileScanner.	self compileParser.	self codeGenerator compileDefinitionComment: parserDefinitionString! !!SmaCCGrammarCompiler methodsFor: 'action table'!actionForState: anInteger on: aSmaCCSymbol	| action |	action := (itemSets at: anInteger)		action: aSmaCCSymbol		prefer: (grammar preferredActionFor: aSmaCCSymbol).	^ self idForAction: action state: anInteger on: aSmaCCSymbol! !!SmaCCGrammarCompiler methodsFor: 'action table'!shiftTableKeyForIndex: anInteger symbol: aSmaCCSymbol	^ SmaCCSymbolTableIndex forIndex: anInteger symbol: aSmaCCSymbol! !!SmaCCGrammarCompiler methodsFor: 'action table'!uniqueNonErrorActionsForTableRow: row	^ row asSet		remove: 3 ifAbsent: [  ];		asArray! !!SmaCCGrammarCompiler methodsFor: 'action table'!compressedRowStream	^ WriteStream with: Array new! !!SmaCCGrammarCompiler methodsFor: 'action table'!multipleActionTableRow: row	| stream |	stream := self compressedRowStream.	stream nextPut: 1.	row		keysAndValuesDo:			[ :index :each | 			each ~= 3				ifTrue:					[ self writeInteger: each on: stream.					self writeInteger: index on: stream ] ].	^ stream contents! !!SmaCCGrammarCompiler methodsFor: 'action table'!optimizedShiftFrom: row to: stateIndex inTable: anArray	| items action reduceEntry otherAction |	items := (anArray at: stateIndex) asSet.	items remove: SmaCCRejectAction id ifAbsent: [  ].	items size ~= 1		ifTrue: [ ^ nil ].	action := items asArray first.	(action bitAnd: 2r11) = SmaCCReduceAction id		ifFalse: [ ^ nil ].	reduceEntry := reduceTable at: (action bitShift: -2).	(reduceEntry at: 3) = #liftFirstValue:		ifFalse: [ ^ nil ].	(reduceEntry at: 2) = 1		ifFalse: [ ^ nil ].	otherAction := row at: reduceEntry first.	^ (self		optimizedShiftFrom: row		to: (otherAction bitShift: -2)		inTable: anArray) ifNil: [ otherAction ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!compressTableRow: row	| uniqueItems |	uniqueItems := self uniqueNonErrorActionsForTableRow: row.	^ uniqueItems size = 1		ifTrue: [ self				singleActionTableRow: row				forAction: uniqueItems first ]		ifFalse: [ self multipleActionTableRow: row ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!compressTable: table	^ table collect: [ :row | self compressTableRow: row ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!createTransitionTable	| table optimizedTable |	table := (1 to: itemSets size) collect: [ :index | scannerCompiler symbols collect: [ :each | self actionForState: index on: each ] ].	optimizedTable := self class optimizeTransitionTable		ifTrue: [ self optimizeTransitionTable: table ]		ifFalse: [ table ].	actions := self compressTable: optimizedTable! !!SmaCCGrammarCompiler methodsFor: 'action table'!singleActionTableRow: row forAction: anInteger	| stream |	stream := self compressedRowStream.	stream nextPut: 0.	self writeInteger: anInteger on: stream.	row		keysAndValuesDo:			[ :index :each | 			each ~= 3				ifTrue: [ self writeInteger: index on: stream ] ].	^ stream contents! !!SmaCCGrammarCompiler methodsFor: 'action table'!idForAction: aSmaCCAction state: anInteger on: aSmaCCSymbol	| index preferredAction newStateIndex |	(aSmaCCAction isAmbiguous and: [ grammar isGLR ])		ifTrue:			[ index := codeGenerator				ambiguousTableEntryFor:					(aSmaCCAction actions						collect:							[ :each | self idForAction: each state: anInteger on: aSmaCCSymbol ])						asSet asSortedCollection.			^ (index bitShift: 2) + 3 ]		ifFalse:			[ preferredAction := aSmaCCAction preferredAction.			preferredAction isShift				ifTrue:					[ newStateIndex := shiftTable						at: (self shiftTableKeyForIndex: anInteger symbol: aSmaCCSymbol).					^ (newStateIndex bitShift: 2) + preferredAction id ].			preferredAction isReduce				ifTrue:					[ ^ ((self reduceTableIndexFor: preferredAction) bitShift: 2)						+ preferredAction id ].			^ aSmaCCAction id ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!createItemSets	| itemSet newState index |	startingStateMap := Dictionary new.	grammar calculateFirstSets.	itemSets := OrderedCollection new.	grammar allStartingSymbols		do:			[ :each | 			itemSets add: (grammar initialItemSetFor: each).			startingStateMap at: each put: itemSets size ].	shiftTable := Dictionary new.	index := 1.	[ index <= itemSets size ]		whileTrue:			[ itemSet := itemSets at: index.			grammar symbols				do:					[ :each | 					newState := itemSet moveOn: each.					newState notEmpty						ifTrue:							[ shiftTable								at: (self shiftTableKeyForIndex: index symbol: each)								put: (self indexOfState: newState) ] ].			index := index + 1 ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!optimizeTransitionTable: anArray	^ anArray		collect: [ :row | 			row				collect: [ :action | 					| newShiftAction |					(action bitAnd: 2r11) = SmaCCShiftAction id						ifTrue: [ newShiftAction := self optimizedShiftFrom: row to: (action bitShift: -2) inTable: anArray ].					newShiftAction notNil						ifTrue: [ newShiftAction ]						ifFalse: [ action ] ] ]! !!SmaCCGrammarCompiler methodsFor: 'action table'!transitionTable	actions isNil		ifTrue: [ self createItemSets.			self createTransitionTable ].	^ actions! !!SmaCCGrammarCompiler methodsFor: 'action table'!writeInteger: anInteger on: aStream	aStream nextPut: anInteger! !!SmaCCGrammarCompiler methodsFor: 'action table'!indexOfState: newState	| newStateIndex |	newStateIndex := itemSets indexOf: newState.	newStateIndex = 0		ifTrue: [ itemSets add: newState.			newStateIndex := itemSets size ]		ifFalse: [ (itemSets at: newStateIndex) mergeWith: newState ].	^ newStateIndex! !!SmaCCGrammarCompiler methodsFor: 'initialize-release'!buildDefinition: definitionString	| parser tree |	scannerCompiler grammar: self grammar.	parserDefinitionString := definitionString.	parser := SmaCCDefinitionParser on: (ReadStream on: definitionString).	parser scanner parseSourceSelector: self codeGenerator parseSourceSelector.	tree := parser parse.	tree completeSource: definitionString.	SmaCCGrammarCreator buildGrammar: grammar from: tree.	grammar finishBuilding! !!SmaCCGrammarCompiler methodsFor: 'initialize-release'!codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator.	self grammar codeGenerator: aSmaCCCodeGenerator.	scannerCompiler codeGenerator: aSmaCCCodeGenerator.	^ codeGenerator! !!SmaCCGrammarCompiler methodsFor: 'initialize-release'!initialize	super initialize.	scannerCompiler := SmaCCScannerCompiler new.	startingStateMap := Dictionary new.	reduceTable := OrderedCollection new! !!SmaCCGrammarCompiler methodsFor: 'accessing'!scannerClass: aClassOrString	self codeGenerator scannerClass: aClassOrString! !!SmaCCGrammarCompiler methodsFor: 'accessing'!symbolsComment	| stream |	stream := WriteStream on: String new.	scannerCompiler symbols		keysAndValuesDo:			[ :index :each | 			stream				nextPutAll: index printString;				nextPutAll: '. ';				nextPutAll: each printString;				cr ].	^ stream contents! !!SmaCCGrammarCompiler methodsFor: 'accessing'!codeGenerator	^ codeGenerator		ifNil: [ self codeGenerator: SmaCCSmalltalkCodeGenerator new ]! !!SmaCCGrammarCompiler methodsFor: 'accessing'!parserClass: aClassOrString	grammar isGLR		ifTrue: [ self codeGenerator glrParserClass: aClassOrString ]		ifFalse: [ self codeGenerator parserClass: aClassOrString ]! !!SmaCCGrammarCompiler methodsFor: 'accessing'!parserClass	^ self codeGenerator parserClass! !!SmaCCGrammarCompiler methodsFor: 'accessing'!itemSetsComment	| stream |	stream := WriteStream on: String new.	itemSets		keysAndValuesDo:			[ :index :each | 			stream				nextPutAll: index printString;				nextPutAll: each printString;				cr ].	^ stream contents! !!SmaCCGrammarCompiler methodsFor: 'accessing'!grammar	^ grammar isNil		ifTrue: [ grammar := SmaCCGrammar new ]		ifFalse: [ grammar ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCGrammarCompiler class	instanceVariableNames: ''!!SmaCCGrammarCompiler class methodsFor: 'accessing'!optimizeTransitionTable	^ OptimizeTransitionTable ifNil: [ true ]! !!SmaCCGrammarCompiler class methodsFor: 'accessing'!optimizeTransitionTable: aBoolean	OptimizeTransitionTable := aBoolean! !!SmaCCGrammarCompiler class methodsFor: 'accessing'!toggleOptimizeTransitionTable	self optimizeTransitionTable: self optimizeTransitionTable not! !Object subclass: #SmaCCReduceActionGenerator	instanceVariableNames: 'rhs index generator variableName currentIndex currentSymbol'	classVariableNames: ''	package: 'SmaCC_Development-Compiler'!!SmaCCReduceActionGenerator methodsFor: 'reduction table'!pullUpVariable	currentSymbol variableDefinitions		keysAndValuesDo:			[ :subIndex :var | 			generator				nextPutStatement:					(var isCollection						ifTrue:							[ self								compileAddToVariable: var								from:									(generator										cast: (generator argumentIndex: currentIndex)										to: generator collectionType)								collection: true ]						ifFalse:							[ | nodesVariable |							nodesVariable := rhs nodeType								variableDefinitionNamed: var variableName.							nodesVariable isCollection								ifTrue:									[ self										compileAddToVariable: nodesVariable										from:											(generator												cast: (generator argumentIndex: currentIndex)												to: nodesVariable type name)										collection: false ]								ifFalse:									[ generator										send: nodesVariable setterMethodName										to: 'result'										with:											(generator												cast: (generator argumentIndex: currentIndex)												to: nodesVariable type name) ] ]) ]! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!generate: aSmaCCRHS pullUp: anInteger on: aCodeGenerator	rhs := aSmaCCRHS.	index := anInteger.	generator := aCodeGenerator.	rhs collection		keysAndValuesDo:			[ :i :each | 			currentIndex := i.			currentSymbol := each.			index ~= currentIndex				ifTrue:					[ variableName := rhs variableNameForIndex: currentIndex.					variableName notNil						ifTrue:							[ currentSymbol returnsVariableCollection								ifTrue: [ rhs										generateNamedVariableCollectionWarningFor: currentIndex ].							generator nextPutStatement: self connectChild ]						ifFalse: [ self pullUpChildren ] ] ]! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!getSubIndex: subIndex ofType: collectionType	^ generator		cast: (generator argumentIndex: currentIndex subIndex: subIndex)		to: collectionType! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!connectChild	| variableDefinition argument symbol isCollection |	variableDefinition := rhs nodeType		variableDefinitionNamed: variableName.	argument := generator		cast: (generator argumentIndex: currentIndex)		to: variableDefinition baseType name.	isCollection := false.	symbol := rhs at: currentIndex.	symbol returnsSingleVariable		ifTrue: [ isCollection := symbol isCollection: symbol variableName ].	^ self		compileAddToVariable: variableDefinition		from: argument		collection: isCollection! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!pullUpChildren	currentSymbol returnsVariableCollection		ifTrue: [ ^ self pullUpVariableArray ].	currentSymbol returnsSingleVariable		ifTrue: [ ^ self pullUpVariable ].	currentSymbol modelType = (generator model classFor: nil class)		ifFalse: [ rhs generateUnnamedSymbolWarningFor: currentIndex ]! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!compileAddToVariable: aSmaCCVariableDefinition from: argument collection: isCollection	^ aSmaCCVariableDefinition isCollection		ifTrue:			[ | selector var |			var := rhs nodeType				variableDefinitionNamed: aSmaCCVariableDefinition variableName.			selector := 'add'.			currentIndex < index				ifTrue: [ selector := selector , 'First' ].			selector := selector				,					(var isBaseNodeType						ifTrue: [ 'Node' ]						ifFalse: [ var isBaseTokenType								ifTrue: [ 'Token' ]								ifFalse: [ 'Object' ] ]).			isCollection				ifTrue: [ selector := selector , 's' ].			selector := (selector , ':to:') asSymbol.			generator				send: selector				to: 'result'				with: argument				with: (generator send: var getterMethodName to: 'result') ]		ifFalse:			[ generator				send: aSmaCCVariableDefinition setterMethodName				to: 'result'				with: argument ]! !!SmaCCReduceActionGenerator methodsFor: 'reduction table'!pullUpVariableArray	currentSymbol variableDefinitions		keysAndValuesDo:			[ :subIndex :var | 			generator				nextPutStatement:					(var isCollection						ifTrue:							[ | collectionType |							collectionType := generator collectionType.							self								compileAddToVariable: var								from: (self getSubIndex: subIndex ofType: collectionType)								collection: true ]						ifFalse:							[ | nodesVariable |							nodesVariable := rhs nodeType								variableDefinitionNamed: var variableName.							nodesVariable isCollection								ifTrue:									[ self										compileAddToVariable: nodesVariable										from: (self getSubIndex: subIndex ofType: nodesVariable type name)										collection: false ]								ifFalse:									[ generator										send: nodesVariable setterMethodName										to: 'result'										with:											(generator												cast: (generator argumentIndex: currentIndex subIndex: subIndex)												to: nodesVariable type name) ] ]) ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReduceActionGenerator class	instanceVariableNames: ''!!SmaCCReduceActionGenerator class methodsFor: 'accessing'!generate: aSmaCCRHS pullUp: anInteger on: aCodeGenerator	^ self new generate: aSmaCCRHS pullUp: anInteger on: aCodeGenerator! !Object subclass: #SmaCCScannerCompiler	instanceVariableNames: 'grammar codeGenerator'	classVariableNames: ''	package: 'SmaCC_Development-Compiler'!!SmaCCScannerCompiler methodsFor: 'regular expression construction'!addNormalSymbols	grammar symbols: (self symbols asSortedCollection: [ :a :b | a < b ])! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!addSpecialSymbols	grammar tokens		keysDo:			[ :each | 			(codeGenerator scannerActionFor: each) notNil				ifTrue: [ grammar terminalSymbolNamed: each ] ]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!addSpecificREsWithoutActionsTo: aRegularExpression	| dfa regex |	regex := aRegularExpression.	dfa := regex isNil		ifTrue: [ nil ]		ifFalse: [ regex asDFA ].	self		specificRegularExpressionsDo:			[ :each | 			| actions |			actions := dfa isNil				ifTrue: [ nil ]				ifFalse: [ dfa actionForSpecificRegularExpression: each ].			actions isNil				ifTrue: [ regex := regex isNil						ifTrue: [ each ]						ifFalse: [ regex | each ] ] ].	^ regex! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!addActions	self symbols		keysAndValuesDo:			[ :index :each | 			each regularExpression				ifNotNil: [ :eachRegex | eachRegex action: index ] ]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!combinedGeneralRegexes	| combinedRegex |	combinedRegex := nil.	self		generalRegularExpressionsDo:			[ :each | 			combinedRegex := combinedRegex isNil				ifTrue: [ each ]				ifFalse: [ combinedRegex | each ] ].	^ combinedRegex! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!generalRegularExpressionsDo: aBlock	self		regularExpressionsDo: [ :each | 			each isKeywordLiteral				ifFalse: [ aBlock value: each ] ]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!computeKeywordMapFor: dfa	| keywordmap |	keywordmap := Dictionary new.	self		specificRegularExpressionsDo:			[ :each | 			| actions |			actions := dfa actionForSpecificRegularExpression: each.			actions isNil				ifFalse:					[ self addActionsFrom: each to: keywordmap at: actions ] ].	^ keywordmap! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!computeSelectorMap	| selectorMap |	selectorMap := Dictionary new.	self symbols		keysAndValuesDo:			[ :index :each | 			(codeGenerator scannerActionFor: each name)				ifNotNil: [ :selector | selectorMap at: index put: selector ] ].	^ selectorMap! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!combinedRegexes	| combinedRegex |	combinedRegex := nil.	self		regularExpressionsDo: [ :each | 			combinedRegex := combinedRegex isNil				ifTrue: [ each ]				ifFalse: [ combinedRegex | each ] ].	^ combinedRegex! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!specificRegularExpressionsDo: aBlock	self		regularExpressionsDo: [ :each | 			each isKeywordLiteral				ifTrue: [ aBlock value: each ] ]! !!SmaCCScannerCompiler methodsFor: 'regular expression construction'!addActionsFrom: aRegularExpression to: aKeywordMap at: states	^ states		do:			[ :state | 			state ~= aRegularExpression action				ifTrue:					[ | keywordData |					keywordData := grammar hasMultipleScannerStates						ifTrue:							[ Array								with: aRegularExpression action								with: aRegularExpression states asSortedCollection asArray ]						ifFalse: [ aRegularExpression action ].					aRegularExpression						possibleMatchesDo:							[ :string | 							(aKeywordMap at: state ifAbsentPut: [ Dictionary new ])								at: string								put: keywordData ] ] ]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!regularExpressionsDo: aBlock	self symbols do: [ :each | each regularExpression ifNotNil: aBlock ]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!compileTokenIdMethods	(self symbols select: [ :each | each createIdMethod ])		do:			[ :each | 			codeGenerator				compileTokenIdMethodNamed: each safeMethodName				withId: (self symbols indexOf: each) ]! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!createFullRegex	self updateSymbolsAndActions.	^ self combinedRegexes! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!compileMethodsFor: regex	| keywordmap dfa selectorMap |	dfa := regex asDFA.	selectorMap := self computeSelectorMap.	keywordmap := self computeKeywordMapFor: dfa.	codeGenerator selectorMap: selectorMap.	codeGenerator compileKeywordInitializerUsing: keywordmap.	codeGenerator compileNode: dfa.	codeGenerator		compileEmptySymbolTokenId: (self symbols indexOf: grammar emptySymbol).	codeGenerator		compileErrorSymbolTokenId: (self symbols indexOf: grammar errorSymbol).	codeGenerator compileIgnoreCaseMethods! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!createRegex	self updateSymbolsAndActions.	^ self addSpecificREsWithoutActionsTo: self combinedGeneralRegexes! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!compileScanner	| regex |	regex := self createRegex.	self compileTokenIdMethods.	self compileMethodsFor: regex! !!SmaCCScannerCompiler methodsFor: 'compiling-scanner'!updateSymbolsAndActions	self addSpecialSymbols.	self addNormalSymbols.	self addActions! !!SmaCCScannerCompiler methodsFor: 'accessing'!symbols	^ grammar symbols! !!SmaCCScannerCompiler methodsFor: 'initialize-release'!codeGenerator: aSmaCCCodeGenerator	codeGenerator := aSmaCCCodeGenerator! !!SmaCCScannerCompiler methodsFor: 'initialize-release'!grammar: aGrammar	grammar := aGrammar! !SmaCCCodeGenerator subclass: #SmaCCSmalltalkCodeGenerator	instanceVariableNames: 'isExpressions parseTreeCache'	classVariableNames: 'MaxJumpSize MaxLiterals'	package: 'SmaCC_Development-Compiler'!!SmaCCSmalltalkCodeGenerator commentStamp: '' prior: 0!SmaCCSmalltalkCodeGenerator represents a code generator for Smalltalk.Instance Variables	isExpressions	<Dictionary key: String value: Symbol>	a map of strings to is??? methods on String that answer true for those strings (e.g., '0123456789' -> #isDigit)	parseTreeCache	<Dictionary key: Symbol value: RBProgramNode>	mapping from selector names to code compiled in the method!!SmaCCSmalltalkCodeGenerator methodsFor: 'testing'!hasLiteralByteArrays	^ true! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputIsSelector: isSelector on: stream	stream nextPutAll: 'currentCharacter ' , isSelector! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!compileIgnoreCaseMethods	super compileIgnoreCaseMethods.	self grammar ignoreCase		ifFalse: [ ^ self ].	scannerClass		compile:			'tokenClass	^SmaCCCaseInsensitiveToken'		classified: #generated! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputLessThanMatch: each on: stream	stream		nextPutAll: 'currentCharacter <= ';		nextPutAll: each last storeString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputStreamClass	^ WriteStream! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!maxLiterals	^ MaxLiterals! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputMatchFor: aSmaCCCharacterEdge on: stream without: isSelectors	| pairs |	pairs := self		minMaxPairsFor: aSmaCCCharacterEdge		without: isSelectors.	pairs isEmpty		ifTrue: [ stream next: isSelectors size - 1 put: $].			^ self ].	isSelectors notEmpty		ifTrue: [ stream nextPutAll: ' or: [' ].	pairs		do: [ :each | self outputMatchForTransition: each on: stream ]		separatedBy: [ stream nextPutAll: ' or: [' ].	stream next: pairs size - 1 put: $].	stream next: isSelectors size put: $]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!countLiteralsIn: aParseTree	| literals |	literals := Set new.	aParseTree		nodesDo:			[ :each | 			each isLiteralNode				ifTrue: [ each parent isLiteralNode						ifFalse: [ literals add: each value ] ].			each isMessage				ifTrue: [ literals add: each selector ] ].	^ literals size! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!maxJumpSize	^ MaxJumpSize! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputRangeMatch: each on: stream	stream		nextPutAll: '(currentCharacter between: ';		nextPutAll: each first storeString;		nextPutAll: ' and: ';		nextPutAll: each last storeString;		nextPutAll: ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputSingleCharacterMatch: each on: stream	stream		nextPutAll: 'currentCharacter == ';		nextPutAll: each first storeString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!optimizationRewriter	| rewriter |	rewriter := RBParseTreeRewriter new.	rewriter		replace:			'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3. ^`@r3].				`@.Stmts4'			with:			'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3. ^`@r3';		replace:			'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				currentCharacter == `#l ifTrue: [`@.Stmts3].				`@.Stmts4'			with:			'`@.Stmts1.				[`@.Stmts2.				currentCharacter ~~ `#l] whileTrue.				`@.Stmts3. 				`@.Stmts4';		replaceMethod:			'`name					`@.Stmts1.					`@a ifTrue: [^self `name].					`@.Stmts3'			with:			'`name					[`@.Stmts1.					`@a] whileTrue.					`@.Stmts3';		replaceMethod:			'`name					`@.Stmts1.					`@a ifTrue: [`@.Stmts2.							^self `name].					`@.Stmts3'			with:			'`name					[`@.Stmts1.					`@a] whileTrue: [`@.Stmts2].					`@.Stmts3';		replace:			'`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with:			'`@.Stmts1.				`@.Stmts2';		replace:			'`@.Stmts1.				`.Stmt.				`@.Stmts.				`@a ifTrue: [self step. `.Stmt. `@.Stmts].				`@.Stmts2'			with:			'`@.Stmts1.				`@a ifTrue: [self step].				`.Stmt.				`@.Stmts.				`@.Stmts2';		replace:			'`@.Stmts1.				true ifTrue: [`@.Stmts2. ^`@obj].				`@.Stmts3'			with:			'`@.Stmts1.				`@.Stmts2.				^`@obj';		replace:			'`@.Stmts1.				[`@.Stmts2. true] whileTrue.				^`@Stmt'			with:			'`@.Stmts1.				[`@.Stmts2. true] whileTrue.'.	self addImplementationSpecificRewritesTo: rewriter.	^ rewriter! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!commonIfTrueCodeRewriter	^ RBParseTreeRewriter new		replace:			'``@.Stmts1.				(`@a ifTrue: ``@block) `{:node :dictionary | | index myStatements |						index := node parent statements indexOf: node.						myStatements := node parent statements.						dictionary at: #size put: ``@block body statements size - (myStatements size - index).						index ~~  myStatements size and: [``@block body statements size >= (myStatements size - index) and: [							(index + 1 to: myStatements size) allSatisfy: [:each | 								(myStatements at: each) = (``@block body statements at: ``@block body statements size - (myStatements size - each))]]]						}.				``@.Stmts3'			with:			'``@.Stmts1.				`{:dictionary | RBMessageNode receiver: `@a selector: #ifTrue: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (``@block body statements copyFrom: 1 to: (dictionary at: #size)))))}.				``@.Stmts3';		yourself! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!splitSequenceFrom: aParseTree usingName: aSelector into: modelClass	| sequence statements |	statements := aParseTree body copy statements.	statements size <= 1		ifTrue: [ ^ false ].	sequence := RBSequenceNode statements: OrderedCollection new.	[ (self countLiteralsIn: sequence) < self maxLiterals		and: [ statements notEmpty ] ]		whileTrue: [ sequence addNodeFirst: statements removeLast ].	sequence removeNode: sequence statements first.	sequence statements size <= 1		ifTrue: [ ^ false ].	sequence statements size		timesRepeat: [ aParseTree body removeNode: aParseTree body statements last ].	aParseTree body		addNode:			(RBReturnNode				value:					(RBMessageNode						receiver: (RBVariableNode named: 'self')						selector: aSelector)).	self		compileScannerTree: (RBMethodNode selector: aSelector body: sequence)		into: modelClass.	^ true! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!rewriters	| rewriters |	rewriters := OrderedCollection new.	rewriters add: self commonIfTrueCodeRewriter.	rewriters add: self optimizationRewriter.	rewriters add: self scanStringRewriter.	^ rewriters! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputMatchForTransition: each on: stream	each first = each last		ifTrue: [ ^ self outputSingleCharacterMatch: each on: stream ].	each first = (Character value: 0)		ifTrue: [ ^ self outputLessThanMatch: each on: stream ].	each last = (Character value: SmaCCGrammar maximumCharacterValue)		ifTrue: [ ^ self outputGreaterThanMatch: each on: stream ].	self outputRangeMatch: each on: stream! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!closestIsExpressionsFor: aSmaCCCharacterEdge seen: aCollection	| expressions |	expressions := OrderedCollection new.	self isExpressions		keysAndValuesDo: [ :string :selector | 			| isInString |			isInString := false.			((string				allSatisfy: [ :each | 					(aSmaCCCharacterEdge transitionObjects includes: each)						ifTrue: [ isInString := true ]						ifFalse: [ aCollection includes: each ] ]) and: [ isInString ])				ifTrue: [ expressions add: selector ] ].	(expressions isEmpty		or: [ (self minMaxPairsFor: aSmaCCCharacterEdge without: expressions) size				> (self minMaxPairsFor: aSmaCCCharacterEdge without: #()) size ])		ifTrue: [ ^ #() ].	expressions size > 1		ifTrue: [ | strings newExpressions |			strings := expressions				collect: [ :each | 					each						->							((self isExpressions keyAtValue: each)								select: [ :char | aSmaCCCharacterEdge transitionObjects includes: char ]) ].			strings := strings				asSortedCollection: [ :a :b | 					a value size > b value size						or: [ a value size = b value size								and: [ (self isExpressions keyAtValue: a key) size										< (self isExpressions keyAtValue: b key) size ] ] ].			newExpressions := OrderedCollection with: strings first.			2 to: strings size do: [ :i | 				| left |				left := (strings at: i) value.				newExpressions					do: [ :each | left := left reject: [ :char | each value includes: char ] ].				left notEmpty					ifTrue: [ newExpressions add: (strings at: i) ] ].			expressions := newExpressions collect: [ :each | each key ] ].	^ expressions! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!writeMatchingCodeFor: aSmaCCNode	| matchedItem |	(aSmaCCNode action notNil and: [ aSmaCCNode action size > 0 ])		ifTrue:			[ matchedItem := aSmaCCNode action asArray.			self codeStream				nextPutAll:					(aSmaCCNode transitions isEmpty						ifTrue: [ '^self recordAndReportMatch:' ]						ifFalse: [ 'self recordMatch: ' ]).			matchedItem isSymbol				ifTrue: [ self codeStream nextPutAll: matchedItem storeString ]				ifFalse:					[ self codeStream nextPutAll: '#('.					matchedItem						do: [ :each | self codeStream nextPutAll: each storeString ]						separatedBy: [ self codeStream nextPut: $  ].					self codeStream nextPut: $) ].			self codeStream				nextPut: $.;				cr ].	(aSmaCCNode transitions		anySatisfy: [ :each | each isCharacterTransition ])		ifTrue: [ self nextPutLine: 'self step.' ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!compileKeywordInitializerUsing: keywordMapDictionary	| stream dataStream |	keywordMapDictionary isEmpty		ifTrue: [ ^ self ].	stream := WriteStream with: String new.	stream nextPutAll: 'initializeKeywordMap'.	stream nextPutAll: ' keywordMap :=  Dictionary new. '.	dataStream := WriteStream with: Array new.	keywordMapDictionary		keysAndValuesDo:			[ :key :value | 			value keys asSortedCollection				do:					[ :each | 					dataStream						nextPut:							(Array with: key with: each with: (value at: each)) ] ].	stream		nextPutAll: '#(';		cr.	dataStream contents		do:			[ :each | 			stream nextPutAll: '#('.			each				do: [ :item | item storeOn: stream ]				separatedBy: [ stream nextPut: $  ].			stream nextPut: $) ]		separatedBy: [ stream cr ].	stream nextPut: $).	stream		nextPutAll:			' do: [:each | (keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2) put: each last]. ^keywordMap'.	scannerClass theMetaClass		compile: (RBParser parseMethod: stream contents) formattedCode		classified: #'generated-initialization'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!compileScannerTree: tree into: modelClass	| i |	i := 1.	[ (self countLiteralsIn: tree) > self maxLiterals		and:			[ (self				splitIfTrueBranchFrom: tree				usingName: (tree selector , 'X' , i printString) asSymbol				into: modelClass)				or:					[ self						splitSequenceFrom: tree						usingName: (tree selector , 'X' , i printString) asSymbol						into: modelClass ] ] ] whileTrue: [ i := i + 1 ].	modelClass compile: tree formattedCode classified: #generated! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputGreaterThanMatch: each on: stream	stream		nextPutAll: 'currentCharacter >= ';		nextPutAll: each first storeString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!scanStringRewriter	^ RBParseTreeRewriter new		replace:			'self step. currentCharacter == `#l1 ifTrue: [self step. currentCharacter == `#l2 ifTrue: `@b]. `@.Stmts'			with:			'(self scanForString: `{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)}) ifTrue: `@b. `@.Stmts';		replace:			'(self scanForString: `#l1) ifTrue: [self step. currentCharacter == `#l2 ifTrue: `@b]. `@.Stmts'			with:			'(self scanForString: `{RBLiteralNode value: (`#l1 value copyWith: `#l2 value)}) ifTrue: `@b. `@.Stmts';		replace:			'self recordMatch: `@m. self step. currentCharacter == `#l1 ifTrue: [self recordMatch: `@m. self step. currentCharacter == `#l2 ifTrue: `@b]. `@.Stmts'			with:			'self recordMatch: `@m. (self scanForString: `{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)}) ifTrue: `@b. `@.Stmts';		replace:			'self recordMatch: `@m. (self scanForString: `#l1) ifTrue: [self recordMatch: `@m. self step. currentCharacter == `#l2 ifTrue: `@b]. `@.Stmts'			with:			'self recordMatch: `@m. (self scanForString: `{RBLiteralNode value: (`#l1 value copyWith: `#l2 value)}) ifTrue: `@b. `@.Stmts';		yourself! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!scannerActionFor: aString	| selector current |	aString size > 2		ifFalse: [ ^ nil ].	selector := (aString copyFrom: 2 to: aString size - 1) asSymbol.	selector numArgs = 0		ifFalse: [ ^ nil ].	((SmaCCScanner organization listAtCategoryNamed: #'default token handling') includes: selector)		ifTrue: [ ^ selector ].	current := scannerClass.	[ current notNil and: [ current superclass notNil and: [ current name ~= #SmaCCScanner ] ] ]		whileTrue: [ (current directlyDefinesMethod: selector)				ifTrue: [ ^ selector ].			current := current superclass ].	^ nil! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!outputInvertedMatchFor: aSmaCCCharacterEdge on: stream	| char |	char := Character		value:			((0 to: SmaCCGrammar maximumCharacterValue)				detect:					[ :each | 					(aSmaCCCharacterEdge transitionObjects						includes: (Character value: each)) not ]).	stream		nextPutAll: 'currentCharacter ~~ ';		nextPutAll: char storeString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!splitIfTrueBranchFrom: aParseTree usingName: aSelector into: modelClass	| blocks |	blocks := SortedCollection sortBlock: [ :a :b | a key > b key ].	aParseTree body		nodesDo:			[ :each | 			(each isBlock				and:					[ each parent isMessage						and:							[ each parent selector = #ifTrue:								and: [ each body lastIsReturn or: [ each containsReturn not ] ] ] ])				ifTrue:					[ | literalCount |					literalCount := self countLiteralsIn: each.					literalCount > 2						ifTrue: [ blocks add: literalCount -> each ] ] ].	blocks notEmpty		ifTrue:			[ | blockToExtract method body |			blockToExtract := blocks first value.			method := RBMethodNode				selector: aSelector				body: blockToExtract body copy.			body := RBMessageNode				receiver: (RBVariableNode named: 'self')				selector: aSelector.			blockToExtract containsReturn				ifTrue: [ body := RBReturnNode value: body ].			blockToExtract				replaceNode: blockToExtract body				withNode: (RBSequenceNode statements: (OrderedCollection with: body)).			self compileScannerTree: method into: modelClass.			^ true ].	^ false! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-scanner'!acceptStateEdge: aSmaCCStateEdge	^ aSmaCCStateEdge transitionObjects size = 1		ifTrue: [ 'scope == #'				, aSmaCCStateEdge transitionObjects asArray first ]		ifFalse:			[ '(' , aSmaCCStateEdge transitionObjects asArray storeString				, ' includes: scope)' ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-parser'!writeTransitionTableEntry: anArray on: aStream firstIsType: aBoolean	| startIndex |	aStream cr.	self hasLiteralByteArrays		ifTrue:			[ aStream nextPutAll: '#['.			aBoolean				ifTrue: [ aStream print: anArray first.					startIndex := 2 ]				ifFalse: [ startIndex := 1 ].			startIndex to: anArray size do:				[ :i | 				aStream					nextPutAll: self literalArraySeparator;					print: ((anArray at: i) bitShift: -8);					nextPutAll: self literalArraySeparator;					print: ((anArray at: i) bitAnd: 16rFF) ].			aStream nextPut: $] ]		ifFalse:			[ aStream nextPutAll: '#('.			anArray				do: [ :each | aStream print: each ]				separatedBy: [ aStream nextPutAll: self literalArraySeparator ].			aStream nextPut: $) ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-parser'!compileSymbolTypes: anArray	self		startPublicVirtualMethod;		nextPutLine: (self method: 'symbolTypes' type: self arrayType);		nextPutStatement: (self return: anArray storeString);		endMethod;		compileMethodIn: self parserClass theMetaClass! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-parser'!compileCacheId	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'cacheId';		cr;		tab;		nextPutAll: '^''';		nextPutAll: DateAndTime now printString;		nextPut: $'.	parserClass theMetaClass compile: stream contents classified: #'generated-accessing'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-parser'!compileScannerClassIntoParser	| stream |	stream := WriteStream with: String new.	stream		nextPutAll: 'scannerClass';		cr;		tab;		nextPutAll: '^';		nextPutAll: scannerClass name.	parserClass theMetaClass		compile: stream contents		classified: #'generated-accessing'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileEqualMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileChildrenMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileMatchInContextMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileHashMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileCopyInContextMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compilePostCopyMethod: aSmaCCNodeClassDefinition	! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling-nodes'!compileVariablesMethods: aSmaCCNodeClassDefinition	| compileBlock allVariables class |	allVariables := OrderedCollection new.	class := aSmaCCNodeClassDefinition.	[ class notNil ]		whileTrue:			[ allVariables addAll: class variableDefinitions.			class := class superclass ].	compileBlock := [ :variables :methodName | 	| vars ignoredVars |	ignoredVars := variables		select: [ :each | grammar ignoredVariables includes: each variableName ].	vars := variables		reject: [ :each | grammar ignoredVariables includes: each variableName ].	(vars		anySatisfy: [ :each | aSmaCCNodeClassDefinition isLocalVariable: each ])		ifTrue:			[ self				startPublicOverrideMethod;				nextPutLine: (self method: methodName type: self collectionType);				nextPutStatement:					(self						return:							(vars collect: [ :each | each getterMethodName asSymbol ]) asArray								storeString);				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass ].	(ignoredVars		anySatisfy: [ :each | aSmaCCNodeClassDefinition isLocalVariable: each ])		ifTrue:			[ | ignoredMethodName |			ignoredMethodName := methodName copy.			ignoredMethodName at: 1 put: ignoredMethodName first asUppercase.			ignoredMethodName := 'ignored' , ignoredMethodName.			self				startPublicOverrideMethod;				nextPutLine: (self method: ignoredMethodName type: self collectionType);				nextPutStatement:					(self						return:							(ignoredVars collect: [ :each | each getterMethodName asSymbol ])								asArray storeString);				endMethod;				compileMethodIn: aSmaCCNodeClassDefinition modelClass ] ].	compileBlock		value:			(allVariables				select: [ :each | each isBaseNodeType and: [ each isCollection not ] ])			value: 'nodeVariables';		value:			(allVariables				select: [ :each | each isBaseNodeType and: [ each isCollection ] ])			value: 'compositeNodeVariables';		value:			(allVariables				select: [ :each | each isBaseTokenType and: [ each isCollection not ] ])			value: 'tokenVariables';		value:			(allVariables				select: [ :each | each isBaseTokenType and: [ each isCollection ] ])			value: 'compositeTokenVariables';		value:			(allVariables				select: [ :each | each isBaseTokenType not and: [ each isBaseNodeType not ] ])			value: 'otherVariables'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'initialize-release'!initialize	super initialize.	model := RBNamespace new		name: 'Compile Scanner/Parser';		yourself.	parseTreeCache := Dictionary new! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!method: aString type: anObject argumentName: firstArgumentNameString argumentType: firstArgumentTypeString argumentName: secondArgumentNameString argumentType: secondArgumentTypeString	| keywords |	keywords := aString asSymbol keywords.	^ keywords first , ' ' , firstArgumentNameString , ' '		, keywords last , ' ' , secondArgumentNameString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!superMessage: aString argument: firstArgumentString argument: secondArgumentString	| keywords |	keywords := aString asSymbol keywords.	^ 'super ' , keywords first , ' (' , firstArgumentString , ') '		, keywords last , ' (' , secondArgumentString , ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString with: thirdArgumentString	| keywords |	keywords := selectorString asSymbol keywords.	^ '(' , receiverString , ') ' , keywords first , ' ('		, firstArgumentString , ') ' , (keywords at: 2) , ' ('		, secondArgumentString , ') ' , keywords last , ' ('		, thirdArgumentString , ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!method: aString type: typeString	^ aString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!variableReference: aSmaCCVariableDefinition in: aString	^ '(' , aString , ') ' , aSmaCCVariableDefinition getterMethodName! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!reduceAction: anArray	^ anArray storeString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!superMessage: aString argument: argumentString	^ 'super ' , aString , ' (' , argumentString , ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!superMessage: aString	^ 'super ' , aString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!method: aString type: anObject argumentName: argumentNameString argumentType: argumentTypeString	^ aString , ' ' , argumentNameString! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!comment: aString	^ '"' , (aString trim copyReplaceAll: '"' with: '""') , '"'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'code generation templates'!send: selectorString to: receiverString with: argumentString	^ '(' , receiverString , ') ' , selectorString , ' ('		, argumentString , ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'accessing'!scannerClass: aClassOrString	(aClassOrString isKindOf: Behavior)		ifTrue: [ scannerClass := model classFor: aClassOrString ]		ifFalse:			[ scannerClass := model classNamed: aClassOrString asSymbol.			scannerClass isNil				ifTrue:					[ scannerClass := self						defineClass: aClassOrString						asSubclassOf: SmaCCScanner ] ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'accessing'!selectorMap: aDictionary	| arrayMap |	aDictionary isEmpty		ifTrue: [ ^ self ].	arrayMap := Array new: aDictionary keys asSortedCollection last.	aDictionary		keysAndValuesDo: [ :key :value | arrayMap at: key put: value ].	self		startPublicOverrideMethod;		nextPutLine: (self method: 'tokenActions' type: self collectionType);		nextPutStatement: (self return: arrayMap storeString);		endMethod;		compileMethodIn: self scannerClass! !!SmaCCSmalltalkCodeGenerator methodsFor: 'accessing'!changes	^ model changes! !!SmaCCSmalltalkCodeGenerator methodsFor: 'accessing'!scannerClass	^ scannerClass! !!SmaCCSmalltalkCodeGenerator methodsFor: 'reduction table'!defaultNodeReductionSource: aReduction	aReduction index = 0		ifTrue: [ ^ 'nil' ].	^ '''' , aReduction index printString , ''''! !!SmaCCSmalltalkCodeGenerator methodsFor: 'reduction table'!basicCompileSourceFor: aSmaCCReduceAction	| parseTree rewriter methodName existing |	parseTree := RBParser		parseExpression: aSmaCCReduceAction rhs reduceCode source.	(parseTree isLiteralNode		and: [ parseTree value isSymbol				and: [ parseTree value numArgs <= 1						and: [ self parserClass definesMethod: parseTree value ] ] ])		ifTrue: [ ^ parseTree value ].	rewriter := self parseTreeRewriterFor: aSmaCCReduceAction rhs.	rewriter executeTree: parseTree.	parseTree := rewriter tree.	methodName := ('reduceActionFor'		, aSmaCCReduceAction symbol safeMethodName		,			(aSmaCCReduceAction symbol positionOf: aSmaCCReduceAction rhs)				printString , ':') asSymbol.	parseTree isSequence		ifFalse:			[ parseTree := RBSequenceNode statements: (Array with: parseTree) ].	parseTree := RBMethodNode		selector: methodName		arguments: (Array with: (RBVariableNode named: 'nodes'))		body: parseTree.	parseTree addReturn.	existing := self findExistingMethodFor: parseTree.	existing notNil		ifTrue: [ ^ existing ].	self parserClass		compile: parseTree formattedCode		classified: 'generated-reduction actions'.	^ methodName! !!SmaCCSmalltalkCodeGenerator methodsFor: 'reduction table'!findExistingMethodFor: aRBMethodNode	| potentialSelectors |	potentialSelectors := #(#liftFirstValue: #liftLastValue: #liftSecondValue: #nil #stringValue:)		asSet.	potentialSelectors		addAll: (self parserClass selectors select: [ :each | each numArgs <= 1 ]).	^ potentialSelectors		detect:			[ :each | 			| parseTree |			parseTree := self parserParseTreeFor: each.			parseTree notNil				and:					[ aRBMethodNode body						equalTo: parseTree body						exceptForVariables: aRBMethodNode argumentNames ] ]		ifNone: [ nil ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'reduction table'!parseTreeRewriterFor: aSmaCCRHS	| rewriter |	rewriter := RBParseTreeRewriter new.	1 to: aSmaCCRHS size do:		[ :i | 		rewriter			replace: i printString storeString			with: '(nodes at: ' , i printString , ')'.		(aSmaCCRHS variableNameForIndex: i)			ifNotNil:				[ :name | rewriter replace: name with: '(nodes at: ' , i printString , ')' ] ].	^ rewriter! !!SmaCCSmalltalkCodeGenerator methodsFor: 'reduction table'!defaultReductionSource	^ '#reduceFor:'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!send: selector to: aString	^ '(' , aString , ') ' , selector! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!generatedMethodsIn: aRBClass	^ aRBClass selectors		select:			[ :each | 			(aRBClass protocolsFor: each)				anySatisfy: [ :protocol | protocol notNil and: [ 'generated*' match: protocol ] ] ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!addImplementationSpecificRewritesTo: rewriter	rewriter		replace:			'`{:node :dict | (node isLiteralNode and: [(node value isKindOf: Character) and: [(node value codePoint between: 32 and: 126) not]]) ifTrue: [dict at: ''literal'' put: node. true] ifFalse: [false]}'			with: '(Character value: `{:dict | RBLiteralNode value: (dict at: ''literal'') value codePoint})';		replace:			'``@.Stmts1.				(`@a ifTrue: [``@.Stmts2]) `{:node :dictionary | | index myStatements |						index := node parent statements indexOf: node.						myStatements := node parent statements.						dictionary at: #size put: ``@.Stmts2 size - (myStatements size - index).						index ~~  myStatements size and: [``@.Stmts2 size >= (myStatements size - index) and: [							(index + 1 to: myStatements size) allSatisfy: [:each | 								(myStatements at: each) = (``@.Stmts2 at: ``@.Stmts2 size - (myStatements size - each))]]]						}.				``@.Stmts3'			with:			'``@.Stmts1.				`{:dictionary | RBMessageNode receiver: `@a selector: #ifTrue: arguments: (Array with: (RBBlockNode body: (RBSequenceNode statements: (``@.Stmts2 copyFrom: 1 to: (dictionary at: #size)))))}.				``@.Stmts3';		replace: 'currentCharacter == `#l1 or: [currentCharacter == `#l2]'			with:			'`{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)} includes: currentCharacter';		replace: 'currentCharacter == `#l1 or: [currentCharacter == `#l2 or: `@a]'			with:			'(`{RBLiteralNode value: (String with: `#l1 value with: `#l2 value)} includes: currentCharacter) or: `@a';		replace: '(`#l1 includes: currentCharacter) or: [currentCharacter == `#l2]'			with:			'`{RBLiteralNode value: `#l1 value , (String with: `#l2 value)} includes: currentCharacter';		replace:			'(`#l1 includes: currentCharacter) or: [currentCharacter == `#l2 or: `@a]'			with:			'(`{RBLiteralNode value: `#l1 value , (String with: `#l2 value)} includes: currentCharacter) or: `@a';		replace:			'`@.Stmts1.				currentCharacter isLiteral ifTrue: [`@.Stmts2].				`@.Stmts3'			with:			'`@.Stmts1.				`@.Stmts2'.	rewriter		replace: 'currentCharacter == (Character value: `@a)'		with: 'currentCharacter = (Character value: `@a)'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!send: selectorString to: receiverString with: firstArgumentString with: secondArgumentString	| keywords |	keywords := selectorString asSymbol keywords.	^ '(' , receiverString , ') ' , keywords first , ' ('		, firstArgumentString , ') ' , keywords last , ' ('		, secondArgumentString , ')'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!isExpressions	isExpressions isNil		ifTrue: [ self initializeIsExpressions ].	^ isExpressions! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!parserParseTreeFor: aSelector	^ parseTreeCache		at: aSelector		ifAbsentPut:			[ | definingClass |			definingClass := self parserClass whoDefinesMethod: aSelector.			definingClass parseTreeFor: aSelector ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!keywords	^ self class keywords! !!SmaCCSmalltalkCodeGenerator methodsFor: 'private'!initializeIsExpressions	| expressions |	isExpressions := Dictionary new.	expressions := SmaCCGrammar isExpressionMap.	(expressions keys asSortedCollection: [ :a :b | a size > b size or: [ a size = b size and: [ a > b ] ] ])		do: [ :key | isExpressions at: (expressions at: key) put: key ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!compileMethodIn: modelClass	modelClass compile: self formattedCode classified: #generated! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeOldMethods	self		removeOldMethodsFrom: scannerClass;		removeOldMethodsFrom: scannerClass theMetaClass;		removeOldMethodsFrom: parserClass;		removeOldMethodsFrom: parserClass theMetaClass! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!compileOptimizedMethodIn: modelClass	| tree |	tree := RBParser parseMethod: self codeStream contents.	self rewriters		do: [ :each | [ each executeTree: tree ] whileTrue: [ tree := each tree ] ].	self compileScannerTree: tree into: modelClass! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeUnnecessaryClassChanges	| allChanges classChanges |	allChanges := self changes changes copy.	(allChanges		allSatisfy: [ :each | (each isKindOf: RBCompositeRefactoryChange) not ])		ifFalse: [ ^ self ].	classChanges := allChanges		select:			[ :each | 			(each isKindOf: RBAddClassChange)				and:					[ each changeClass notNil						and: [ each changeClass superclass name = each superclassName ] ] ].	classChanges		do:			[ :each | 			| addVars variables existingVariables |			addVars := allChanges				select:					[ :change | 					(change isKindOf: RBAddInstanceVariableChange)						and: [ each changeClass = change changeClass ] ].			variables := addVars				inject: Set new				into:					[ :sum :change | 					sum						add: change variable;						yourself ].			variables addAll: each instanceVariableNames.			existingVariables := each changeClass instVarNames.			(existingVariables size = variables size				and:					[ existingVariables asSortedCollection asArray						= variables asSortedCollection asArray ])				ifTrue:					[ self removeChange: each.					addVars do: [ :change | self removeChange: change ] ] ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeUnnecessaryChanges	self removeUnnecessaryMethodChanges.	self removeUnnecessaryClassChanges! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!defineClass: aString asSubclassOf: aBehavior	| current variables |	current := Smalltalk at: aString asSymbol ifAbsent: [ Object ].	variables := ''.	(current includesBehavior: SmaCCParser) | (current includesBehavior: SmaCCScanner)		ifTrue:			[ | stream |			stream := WriteStream on: String new.			current instVarNames				do: [ :each | 					stream						nextPutAll: each;						space ].			variables := stream contents ].	model		defineClass:			aBehavior name , ' subclass: #' , aString , ' instanceVariableNames: ''' , variables				,					(''' classVariableNames: '''' poolDictionaries: '''' category: '''						, (defaultCategory ifNil: [ RPackage defaultPackageName ]) , ''' ').	^ model classNamed: aString asSymbol! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeChange: aRBChange	| index |	index := self changes changes identityIndexOf: aRBChange.	index > 0		ifFalse: [ ^ self ].	self changes changes removeAt: index! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!formattedCode	^ (RBParser parseMethod: self codeStream contents) formattedCode! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!compileInitializeMethod: aSmaCCNodeClassDefinition	| stream |	((aSmaCCNodeClassDefinition modelClass definesMethod: #initialize)		and: [ aSmaCCNodeClassDefinition collectionVariableDefinitions isEmpty ])		ifTrue: [ ^ self ].	stream := WriteStream on: String new.	stream nextPutAll: 'initialize'.	(aSmaCCNodeClassDefinition modelClass superclass		definesMethod: #initialize)		ifTrue: [ stream				cr;				tab;				nextPutAll: 'super initialize.' ].	aSmaCCNodeClassDefinition collectionVariableDefinitions		do:			[ :each | 			stream				cr;				tab;				nextPutAll: (self nonKeywordNameFor: each sourceVariableName);				nextPutAll: ' := OrderedCollection new: 2.' ].	aSmaCCNodeClassDefinition modelClass		compile: stream contents		classified: #'generated-initialize-release'! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!addVariable: aSmaCCVariableDefinition forDefinition: aSmaCCNodeClassDefinition	| instVarName |	instVarName := self		nonKeywordNameFor: aSmaCCVariableDefinition sourceVariableName.	(aSmaCCNodeClassDefinition modelClass		definesInstanceVariable: instVarName)		ifTrue: [ ^ self ].	aSmaCCNodeClassDefinition modelClass addInstanceVariable: instVarName! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!compileChanges	self removeUnnecessaryChanges.	RBRefactoryChangeManager instance performChange: self changes.	parserClass realClass ifNotNil: [ :each | each resetCaches ].	scannerClass realClass		ifNotNil: [ :each | each initializeKeywordMap ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!compileMethodWithoutFormattingIn: modelClass	| code |	code := self codeStream contents.	code := code trim.	modelClass compile: code classified: #generated! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeOldMethodsFrom: aRBClass	(self generatedMethodsIn: aRBClass)		do: [ :each | aRBClass removeMethod: each ]! !!SmaCCSmalltalkCodeGenerator methodsFor: 'compiling'!removeUnnecessaryMethodChanges	| allChanges |	allChanges := self changes changes copy.	(allChanges		allSatisfy: [ :each | (each isKindOf: RBCompositeRefactoryChange) not ])		ifFalse: [ ^ self ].	allChanges		keysAndValuesDo:			[ :key :each | 			(each isKindOf: RBRemoveMethodChange)				ifTrue:					[ key + 1 to: allChanges size do:						[ :i | 						| other |						other := allChanges at: i.						[ ((other isKindOf: RBAddMethodChange)							and:								[ each selector = other selector									and:										[ each changeClassName = other changeClassName											and:												[ (other changeClass sourceCodeAt: other selector) asString													= other parseTree source asString ] ] ])							ifTrue: [ self									removeChange: each;									removeChange: other ] ]							on: Error							do: [ :ex | ex return ] ] ] ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSmalltalkCodeGenerator class	instanceVariableNames: 'keywords'!!SmaCCSmalltalkCodeGenerator class methodsFor: 'class initialization'!initialize	MaxJumpSize := 900.	MaxLiterals := 30! !!SmaCCSmalltalkCodeGenerator class methodsFor: 'accessing'!codeTemplatesArray	^super codeTemplatesArray ,		#(			#(#addAllSendTo:with: 'self addAll: (<2s>) to: (<1s>)')			#(#addAllFirstSendTo:with: 'self addAllFirst: (<2s>) to: (<1s>)')			#(#addSendTo:with: 'self add: (<2s>) to: (<1s>)')			#(#addFirstSendTo:with: 'self addFirst: (<2s>) to: (<1s>)')			#(#arrayType '')			#(#assignArray:index:to: '(<1s>) at: (<2p>) put: (<3s>)')			#(#assignmentTo:from: '<1s> := <2s>')			#(#at:index: '(<1s>) at: <2p>')			#(#bitXor:with: '(<1s>) bitXor: (<2s>)')			#(#booleanType '')			#(#cast:to: '<1s>')			#(#collectionType '')			#(#collectionVariableItemsIn:forCollectionGetter:andVariableGetter: 'SmaCCParseNode collectionVariableIn: (<1s>) collectionGetter: <2p> variableGetter: <3p>')			#(#compareEqual:to: '(<1s>) = (<2s>)')			#(#copy:inContext:onlyNodes: '<1s> collect: [:each | <3?:(each isKindOf: SmaCCParseNode) ifTrue: [>each copyInContext: <2s>]<3?:]>')			#(#copyNode: '(<1s>) copy')			#(#copyNodeCollection: '(<1s>) collect: [:each | each copy]')			#(#dictionaryType '')			#(#endConditionalString ']')			#(#endDoWhileLoopWithClause: '<1s>] whileTrue')			#(#endLiteralArray ')')			#(#endMethodString '')			#(#hashFor: '(<1s>) hash')			#(#ifFalseReturn: '(<1s>) ifFalse: [^false]')			#(#integerType '')			#(#isKindOfTest:class: '(<1s> isKindOf: <2s>) ifTrue: [')			#(#iterateObjects:name: '(<1s>) do: [:<2s> |')			#(#literalArraySeparator ' ')			#(#newArrayOfSize: 'Array new: <1p>')			#(#newCollectionOfSize: 'OrderedCollection new: <1p>')			#(#newObject: '<1s> new')			#(#newUnsignedShortArrayArray '#(')			#(#nodeCollectionType 'OrderedCollection')			#(#notNilCheckFor: '(<1s>) notNil ifTrue: [')			#(#objectType 'Object')			#(#private '')			#(#protected '')			#(#public '')			#(#receiverName 'self')			#(#reduceActionArrayType '')			#(#reduceActionLiteralStart '#(')			#(#return: '^<1s>')			#(#startDoWhileLoop '[')			#(#startIfWithClause: '(<1s>) ifTrue: [')			#(#statementSeparator '.')			#(#static '')			#(#stringType '')			#(#undefinedObject 'nil')			#(#unsignedShort '')			#(#unsignedShortArrayArray '')			#(#uppercaseString: '(<1s>) asUppercase')			#(#variableDeclaration:ofType: '| <1s> |')			#(#variableItemIn:forVariableGetter: 'SmaCCParseNode variableIn: (<1s>) getter: <2p>')			#(#virtual '')			#(#voidType '')		)! !!SmaCCSmalltalkCodeGenerator class methodsFor: 'accessing'!typeName	^ #Smalltalk! !!SmaCCSmalltalkCodeGenerator class methodsFor: 'accessing'!parseSourceSelector	^ #canParseSmalltalk:! !!SmaCCSmalltalkCodeGenerator class methodsFor: 'private'!keywords	"While Smalltalk doesn't have many keywords, we don't want to overwrite any existing method."	^ keywords		ifNil:			[ keywords := (SmaCCParseNode allSelectors				inject: #('self' 'super' 'nil' 'true' 'false') asSet				into:					[ :sum :each | 			(each numArgs <= 1 and: [ each isInfix not ])				ifTrue:					[ sum						add:							(each last = $:								ifTrue: [ each first: each size - 1 ]								ifFalse: [ each ]) asString ].			sum ])				remove: 'name' ifAbsent: [  ];				remove: 'value' ifAbsent: [  ];				remove: 'annotations' ifAbsent: [  ];				yourself ]! !SmaCCSmalltalkCodeGenerator initialize!Object subclass: #SmaCCRegularExpressionNode	instanceVariableNames: 'action position states'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCRegularExpressionNode commentStamp: '' prior: 0!SmaCCRegularExpressionNode is an abstract class that is used during the construction of the scanner. When the scanner definition is parsed, it creates the SmaCCRegularExpressionNode objects. These objects are then converted to an NFA graph that is converted to a DFA that is compiled.Subclasses must implement the following messages:	accessing		possibleMatchesSize	private		asNFAStartingWith:		possibleMatchesDo:on:Instance Variables:	action	<Object>	this is a symbol that is performed on the scanner, an integer for the token id, or nil if we can't accept a token at this position	position	<Integer>	the position in the scanner definition for this RE -- this is only used for overlapping tokens. Tokens that are defined earlier in the definition are preferred over later ones (except for those used in the parser's definition)	states	<Collection of: Symbol>	the states where this RE is valid!!SmaCCRegularExpressionNode methodsFor: 'initialize-release'!initialize	super initialize.	states := Set new! !!SmaCCRegularExpressionNode methodsFor: 'initialize-release'!position: anInteger	position := anInteger! !!SmaCCRegularExpressionNode methodsFor: 'initialize-release'!action: aString	action := aString! !!SmaCCRegularExpressionNode methodsFor: 'testing'!isKeywordLiteral	^ self possibleMatchesSize < 50		and:			[ self				possibleMatchesDo: [ :each | 					each size > 1						ifTrue: [ ^ true ] ].			false ]! !!SmaCCRegularExpressionNode methodsFor: 'copying'!postCopy	super postCopy.	states := Set new! !!SmaCCRegularExpressionNode methodsFor: 'converting'!asNFA	| startNode |	startNode := SmaCCNode new.	self asNFAStartingWith: startNode.	^ startNode! !!SmaCCRegularExpressionNode methodsFor: 'converting'!asDFA	| startNode |	startNode := self asNFA.	^ startNode asDFA! !!SmaCCRegularExpressionNode methodsFor: 'accessing-states'!states	^ states! !!SmaCCRegularExpressionNode methodsFor: 'accessing-states'!addStates: aCollection	states addAll: aCollection! !!SmaCCRegularExpressionNode methodsFor: 'accessing-states'!addState: aSymbol	states add: aSymbol! !!SmaCCRegularExpressionNode methodsFor: 'private'!addStateTransitionsTo: aSmaCCNode	| endNode |	states isEmpty		ifTrue: [ ^ aSmaCCNode ].	endNode := SmaCCNode new.	aSmaCCNode		addEdgeTo: endNode		onStates: states asSortedCollection asArray.	^ endNode! !!SmaCCRegularExpressionNode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	^ self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'accessing'!possibleMatches	| matches |	matches := OrderedCollection new.	self possibleMatchesDo: [ :each | matches add: each ].	^ matches! !!SmaCCRegularExpressionNode methodsFor: 'accessing'!action	^ action! !!SmaCCRegularExpressionNode methodsFor: 'accessing'!position	^ position! !!SmaCCRegularExpressionNode methodsFor: 'accessing'!possibleMatchesSize	^ self subclassResponsibility! !!SmaCCRegularExpressionNode methodsFor: 'accessing'!possibleMatchesDo: aBlock	| stream |	stream := WriteStream with: String new.	self possibleMatchesDo: [ aBlock value: stream contents ] on: stream! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!repeatForAtLeast: minimum	^ SmaCCRepeatingRENode component: self minimum: minimum! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!, aSmaCCRegularExpressionNode	^ SmaCCSequenceRENode		nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!| aSmaCCRegularExpressionNode	^ SmaCCOrRENode		nodes: (OrderedCollection with: self with: aSmaCCRegularExpressionNode)! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!repeat	^ SmaCCRepeatingRENode component: self! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!makeCaseInsensitive	! !!SmaCCRegularExpressionNode methodsFor: 'constructing'!repeatFor: minimum to: maximum	^ SmaCCRepeatingRENode		component: self		minimum: minimum		maximum: maximum! !SmaCCRegularExpressionNode subclass: #SmaCCCharacterRENode	instanceVariableNames: 'characters ignoreCase'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCCharacterRENode commentStamp: '' prior: 0!SmaCCCharacterRENode is a SmaCCRegularExpressionNode that matches a character.Instance Variables:	characters	<String>	the characters we accept	ignoreCase	<Boolean>	should we ignore case when accepting the characters!!SmaCCCharacterRENode methodsFor: 'constructing'!| aSmaCCRegularExpressionNode	(self canMergeWith: aSmaCCRegularExpressionNode)		ifFalse: [ ^ super | aSmaCCRegularExpressionNode ].	characters := characters , aSmaCCRegularExpressionNode characters.	^ self! !!SmaCCCharacterRENode methodsFor: 'constructing'!makeCaseInsensitive	| newCharacters |	ignoreCase := true.	newCharacters := characters copy.	characters		do: [ :each | 			| upper lower |			upper := each asUppercase.			lower := each asLowercase.			upper asInteger > SmaCCGrammar maximumCharacterValue				ifFalse: [ newCharacters add: upper ].			lower asInteger > SmaCCGrammar maximumCharacterValue				ifFalse: [ newCharacters add: lower ] ].	characters := newCharacters! !!SmaCCCharacterRENode methodsFor: 'testing'!canMergeWith: aSmaCCRegularExpressionNode	^ self class = aSmaCCRegularExpressionNode class		and:			[ characters notNil				and:					[ aSmaCCRegularExpressionNode characters notNil						and: [ self action = aSmaCCRegularExpressionNode action ] ] ]! !!SmaCCCharacterRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	startNode addEdgeTo: endNode onCharacters: characters.	^ endNode! !!SmaCCCharacterRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	self matchingCharacters		do: [ :each | 			aStream nextPut: each.			aBlock value.			aStream position: aStream position - 1 ]! !!SmaCCCharacterRENode methodsFor: 'accessing'!characters	^ characters! !!SmaCCCharacterRENode methodsFor: 'accessing'!possibleMatchesSize	^ self matchingCharacters size! !!SmaCCCharacterRENode methodsFor: 'accessing'!matchingCharacters	^ ignoreCase		ifTrue: [ characters reject: [ :each | each isLowercase ] ]		ifFalse: [ characters ]! !!SmaCCCharacterRENode methodsFor: 'initialize-release'!characters: aSmaCCCharacterSet	characters := aSmaCCCharacterSet! !!SmaCCCharacterRENode methodsFor: 'initialize-release'!initialize	super initialize.	ignoreCase := false! !!SmaCCCharacterRENode methodsFor: 'printing'!printOn: aStream	| allCharacters |	characters size = 1		ifTrue: [ ^ self printCharacter: characters first on: aStream ].	aStream nextPut: $[.	allCharacters := characters.	characters size > 128		ifTrue: [ allCharacters := ((0 to: SmaCCGrammar maximumCharacterValue) collect: [ :each | Character value: each ])				reject: [ :each | characters includes: each ].			allCharacters size < characters size				ifTrue: [ aStream nextPut: $^ ] ].	allCharacters do: [ :each | self printCharacter: each on: aStream ].	aStream nextPut: $]! !!SmaCCCharacterRENode methodsFor: 'printing'!printCharacter: aCharacter on: aStream	(aCharacter asInteger between: 32 and: 126)		ifTrue: [ ^ aStream nextPut: aCharacter ].	aStream nextPutAll: '\x'.	aCharacter asInteger printOn: aStream base: 16 showRadix: false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCCharacterRENode class	instanceVariableNames: ''!!SmaCCCharacterRENode class methodsFor: 'instance creation'!characters: aSmaCCCharacterSet	^ self new		characters: aSmaCCCharacterSet;		yourself! !SmaCCRegularExpressionNode subclass: #SmaCCNotRENode	instanceVariableNames: 'node'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCNotRENode commentStamp: '' prior: 0!SmaCCNotRENode is a SmaCCRegularExpressionNode that inverts another SmaCCRegularExpressionNode matches.Instance Variables:	node	<SmaCCRegularExpressionNode>	the node whose match is being inverted!!SmaCCNotRENode methodsFor: 'initialize-release'!node: aSmaCCCharacterRENode	node := aSmaCCCharacterRENode! !!SmaCCNotRENode methodsFor: 'accessing'!possibleMatchesSize	^ self characterNode possibleMatchesSize! !!SmaCCNotRENode methodsFor: 'private'!characters	^ SmaCCGrammar allCharacters		reject: [ :each | node characters includes: each ]! !!SmaCCNotRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	^ self characterNode asNFAStartingWith: aSmaCCNode! !!SmaCCNotRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	self characterNode possibleMatchesDo: aBlock on: aStream! !!SmaCCNotRENode methodsFor: 'private'!characterNode	^ (SmaCCCharacterRENode characters: self characters)		addStates: states;		action: action;		yourself! !!SmaCCNotRENode methodsFor: 'constructing'!makeCaseInsensitive	node makeCaseInsensitive! !!SmaCCNotRENode methodsFor: 'printing'!printOn: aStream	self characterNode printOn: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCNotRENode class	instanceVariableNames: ''!!SmaCCNotRENode class methodsFor: 'instance creation'!on: aSmaCCCharacterRENode	^ self new		node: aSmaCCCharacterRENode;		yourself! !SmaCCRegularExpressionNode subclass: #SmaCCOrRENode	instanceVariableNames: 'nodes'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCOrRENode commentStamp: '' prior: 0!SmaCCOrRENode is a SmaCCRegularExpressionNode that represents several possible regular expression choices. For example, we may have an SmaCCOrRENode that contains a character RE that matches letters when the state is #foo, and another character RE that matches whitespace when the state is #bar.Instance Variables:	nodes	<Collection of: SmaCCRegularExpressionNode>	all RE nodes that are being ORed together!!SmaCCOrRENode methodsFor: 'accessing'!possibleMatchesSize	^ nodes		inject: 0		into: [ :sum :each | sum + each possibleMatchesSize ]! !!SmaCCOrRENode methodsFor: 'initialize-release'!nodes: aCollection	nodes := aCollection! !!SmaCCOrRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	nodes		do:			[ :each | 			| componentStart |			componentStart := SmaCCNode new.			startNode addEdgeTo: componentStart.			(each asNFAStartingWith: componentStart) addEdgeTo: endNode ].	^ endNode! !!SmaCCOrRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	nodes		do:			[ :each | 			| pos |			pos := aStream position.			each possibleMatchesDo: aBlock on: aStream.			aStream position: pos ]! !!SmaCCOrRENode methodsFor: 'copying'!postCopy	super postCopy.	nodes := nodes copy! !!SmaCCOrRENode methodsFor: 'constructing'!| aSmaCCRegularExpressionNode	self action = aSmaCCRegularExpressionNode action		ifFalse: [ ^ super | aSmaCCRegularExpressionNode ].	nodes add: aSmaCCRegularExpressionNode.	^ self! !!SmaCCOrRENode methodsFor: 'constructing'!makeCaseInsensitive	nodes do: [ :each | each makeCaseInsensitive ]! !!SmaCCOrRENode methodsFor: 'printing'!printOn: aStream	aStream nextPut: $(.	nodes		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPutAll: ' | ' ].	aStream nextPut: $)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCOrRENode class	instanceVariableNames: ''!!SmaCCOrRENode class methodsFor: 'instance creation'!nodes: aCollection	^ self new		nodes: aCollection;		yourself! !SmaCCRegularExpressionNode subclass: #SmaCCReferenceRENode	instanceVariableNames: 'regexNode creationBlock'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCReferenceRENode methodsFor: 'accessing'!possibleMatchesSize	^ self regexNode possibleMatchesSize! !!SmaCCReferenceRENode methodsFor: 'private'!regexNode	regexNode isNil		ifTrue: [ regexNode := creationBlock value copy.			regexNode action: self action.			regexNode position: self position.			regexNode addStates: self states ].	^ regexNode! !!SmaCCReferenceRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	^ self regexNode asNFAStartingWith: aSmaCCNode! !!SmaCCReferenceRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	^ self regexNode possibleMatchesDo: aBlock on: aStream! !!SmaCCReferenceRENode methodsFor: 'initialize-release'!creationBlock: aBlock	creationBlock := aBlock! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCReferenceRENode class	instanceVariableNames: ''!!SmaCCReferenceRENode class methodsFor: 'instance creation'!creationBlock: aBlock	^ self new		creationBlock: aBlock;		yourself! !SmaCCRegularExpressionNode subclass: #SmaCCRepeatingRENode	instanceVariableNames: 'node minimumMatches maximumMatches'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCRepeatingRENode commentStamp: '' prior: 0!SmaCCRepeatingRENode is a SmaCCRegularExpressionNode that matches a particular RE node multiple times.Instance Variables:	maximumMatches	<Integer>	the maximum amount of matches (or #finiteInfinity if we can repeat unlimited number of times)	minimumMatches	<Integer>	the minimum amount of matches we must accept	node	<SmaCCRegularExpressionNode>	the node we are matching!!SmaCCRepeatingRENode methodsFor: 'constructing'!makeCaseInsensitive	node makeCaseInsensitive! !!SmaCCRepeatingRENode methodsFor: 'accessing'!possibleMatchesSize	"This does not return the exact number for expressions with over 50 potential matches since we don't need that detail and computing the exact value may be expensive."	| baseSize |	baseSize := node possibleMatchesSize.	baseSize = 1		ifTrue: [ ^ node possibleMatchesSize				* (maximumMatches - minimumMatches + 1) ].	maximumMatches >= 6		ifTrue: [ ^ SmallInteger maxVal ].	^ (minimumMatches to: maximumMatches)		inject: 0		into: [ :sum :each | sum + (baseSize raisedTo: each) ]! !!SmaCCRepeatingRENode methodsFor: 'initialize-release'!component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger	node := aSmaCCRegularExpressionNode.	minimumMatches := minInteger.	maximumMatches := maxInteger! !!SmaCCRepeatingRENode methodsFor: 'printing'!printOn: aStream	aStream nextPut: $(.	node printOn: aStream.	aStream nextPut: $).	maximumMatches = (1 bitShift: 31)		ifTrue:			[ minimumMatches = 0				ifTrue: [ ^ aStream nextPut: $* ].			minimumMatches = 1				ifTrue: [ ^ aStream nextPut: $+ ].			^ aStream				nextPut: ${;				nextPutAll: minimumMatches printString;				nextPutAll: ',}' ].	aStream		nextPut: ${;		nextPutAll: minimumMatches printString;		nextPut: $,;		nextPutAll: maximumMatches printString;		nextPut: $}! !!SmaCCRepeatingRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	| endNode start |	start := SmaCCNode new.	(self addStateTransitionsTo: aSmaCCNode) addEdgeTo: start.	endNode := SmaCCNode new.	endNode action: action.	minimumMatches timesRepeat: [ start := node asNFAStartingWith: start ].	start addEdgeTo: endNode.	maximumMatches < self class finiteInfinity		ifTrue: [ maximumMatches - minimumMatches				timesRepeat: [ start := node asNFAStartingWith: start.					start addEdgeTo: endNode ] ]		ifFalse: [ (node asNFAStartingWith: start) addEdgeTo: start ].	^ endNode! !!SmaCCRepeatingRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	self possibleMatchesDo: aBlock on: aStream startingAt: 0! !!SmaCCRepeatingRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream startingAt: anInteger	(anInteger between: minimumMatches and: maximumMatches)		ifTrue: [ aBlock value ].	anInteger < maximumMatches		ifTrue:			[ node				possibleMatchesDo:					[ self possibleMatchesDo: aBlock on: aStream startingAt: anInteger + 1 ]				on: aStream ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCRepeatingRENode class	instanceVariableNames: ''!!SmaCCRepeatingRENode class methodsFor: 'constants'!finiteInfinity	"The number that we consider to be 'infinite'"	^ 2147483648! !!SmaCCRepeatingRENode class methodsFor: 'instance creation'!component: aSmaCCRegularExpressionNode minimum: minInteger maximum: maxInteger	^ self new		component: aSmaCCRegularExpressionNode			minimum: minInteger			maximum: maxInteger;		yourself! !!SmaCCRepeatingRENode class methodsFor: 'instance creation'!component: aSmaCCRegularExpressionNode	^ self component: aSmaCCRegularExpressionNode minimum: 0! !!SmaCCRepeatingRENode class methodsFor: 'instance creation'!component: aSmaCCRegularExpressionNode minimum: anInteger	^ self		component: aSmaCCRegularExpressionNode		minimum: anInteger		maximum: self finiteInfinity! !SmaCCRegularExpressionNode subclass: #SmaCCSequenceRENode	instanceVariableNames: 'nodes'	classVariableNames: ''	package: 'SmaCC_Development-Regular Expressions'!!SmaCCSequenceRENode commentStamp: '' prior: 0!SmaCCSequenceRENode is a SmaCCRegularExpressionNode that matches a sequence of other RE nodes.Instance Variables:	nodes	<SequenceableCollection of: SmaCCRegularExpressionNode>	an ordered list of nodes to match!!SmaCCSequenceRENode methodsFor: 'accessing'!possibleMatchesSize	^ nodes		inject: 1		into: [ :sum :each | sum * each possibleMatchesSize ]! !!SmaCCSequenceRENode methodsFor: 'copying'!postCopy	super postCopy.	nodes := nodes copy! !!SmaCCSequenceRENode methodsFor: 'constructing'!makeCaseInsensitive	nodes do: [ :each | each makeCaseInsensitive ]! !!SmaCCSequenceRENode methodsFor: 'constructing'!, aSmaCCRegularExpressionNode	self action = aSmaCCRegularExpressionNode action		ifFalse: [ ^ super , aSmaCCRegularExpressionNode ].	nodes add: aSmaCCRegularExpressionNode.	^ self! !!SmaCCSequenceRENode methodsFor: 'printing'!printOn: aStream	nodes		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream space ]! !!SmaCCSequenceRENode methodsFor: 'private'!asNFAStartingWith: aSmaCCNode	| endNode startNode |	startNode := self addStateTransitionsTo: aSmaCCNode.	endNode := SmaCCNode new.	endNode action: action.	(nodes		inject: startNode		into: [ :sum :each | each asNFAStartingWith: sum ])		addEdgeTo: endNode.	^ endNode! !!SmaCCSequenceRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream	self possibleMatchesDo: aBlock on: aStream startingAt: 1! !!SmaCCSequenceRENode methodsFor: 'private'!possibleMatchesDo: aBlock on: aStream startingAt: anInteger	| node |	node := nodes at: anInteger.	nodes size = anInteger		ifTrue: [ node possibleMatchesDo: aBlock on: aStream ]		ifFalse:			[ node				possibleMatchesDo:					[ self possibleMatchesDo: aBlock on: aStream startingAt: anInteger + 1 ]				on: aStream ]! !!SmaCCSequenceRENode methodsFor: 'initialize-release'!nodes: aCollection	nodes := aCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSequenceRENode class	instanceVariableNames: ''!!SmaCCSequenceRENode class methodsFor: 'instance creation'!nodes: aCollection	^ self new		nodes: aCollection;		yourself! !Collection subclass: #SmaCCIntegerSet	instanceVariableNames: 'start run data normalized'	classVariableNames: ''	package: 'SmaCC_Development-Collections'!!SmaCCIntegerSet methodsFor: 'initialize-release'!initialize	start := 0.	run := self byteSize.	data := 0.	normalized := true! !!SmaCCIntegerSet methodsFor: 'copying'!postCopy	super postCopy.	data := self copyData: data! !!SmaCCIntegerSet methodsFor: 'comparing'!hash	self normalize.	^ data hash hashMultiply bitXor: self size hash! !!SmaCCIntegerSet methodsFor: 'comparing'!> aSmaCCIntegerCollection	^ aSmaCCIntegerCollection < self! !!SmaCCIntegerSet methodsFor: 'comparing'!>= aSmaCCIntegerCollection	^ (self < aSmaCCIntegerCollection) not! !!SmaCCIntegerSet methodsFor: 'comparing'!= anObject	self class = anObject class		ifFalse: [ ^ false ].	self normalize.	anObject normalize.	^ self start = anObject start and: [ self run = anObject run and: [ self data = anObject data ] ]! !!SmaCCIntegerSet methodsFor: 'comparing'!< aSmaCCIntegerCollection	| otherData otherRun myData myRun compare |	self isEmpty		ifTrue: [ ^ aSmaCCIntegerCollection isEmpty not ].	aSmaCCIntegerCollection isEmpty		ifTrue: [ ^ false ].	self normalize.	aSmaCCIntegerCollection normalize.	otherData := aSmaCCIntegerCollection data.	otherRun := aSmaCCIntegerCollection run.	myData := data.	myRun := run.	[ myRun < otherRun ]		whileTrue: [ otherRun := self nextRunFrom: otherRun.			otherData := self reduceData: otherData ].	[ otherRun < myRun ]		whileTrue: [ myRun := self nextRunFrom: myRun.			myData := self reduceData: myData ].	compare := self		compareData: myData		to: otherData		hasMore: [ :isMine | 			isMine				ifTrue: [ run > aSmaCCIntegerCollection run ]				ifFalse: [ run < aSmaCCIntegerCollection run ] ].	compare = 0		ifTrue: [ ^ run < aSmaCCIntegerCollection run ].	compare < 0		ifTrue: [ ^ true ].	^ false! !!SmaCCIntegerSet methodsFor: 'comparing'!<= aSmaCCIntegerCollection	^ (aSmaCCIntegerCollection < self) not! !!SmaCCIntegerSet methodsFor: 'testing'!includes: anInteger	anInteger < start		ifTrue: [ ^ false ].	self defaultRunSize * run + start <= anInteger		ifTrue: [ ^ false ].	^ self		includes: anInteger		in: data		startingAt: start		withRun: run! !!SmaCCIntegerSet methodsFor: 'testing'!isEmpty	self normalize.	^ data == 0! !!SmaCCIntegerSet methodsFor: 'private'!nextRunFrom: currentRun	^ currentRun // self defaultRunSize! !!SmaCCIntegerSet methodsFor: 'private'!defaultRunSize	^ 32! !!SmaCCIntegerSet methodsFor: 'private'!includes: anInteger in: currentData startingAt: currentStart withRun: currentRun	| isBits offset |	currentData == 1		ifTrue: [ ^ true ].	currentData == 0		ifTrue: [ ^ false ].	isBits := currentRun = self byteSize.	offset := (anInteger - currentStart) // currentRun + 1.	^ isBits		ifTrue: [ ((currentData at: offset) bitAnd: (1 bitShift: (anInteger - currentStart) \\ currentRun)) ~~ 0 ]		ifFalse: [ self				includes: anInteger				in: (currentData at: offset)				startingAt: currentStart + ((offset - 1) * currentRun)				withRun: (self nextRunFrom: currentRun) ]! !!SmaCCIntegerSet methodsFor: 'private'!compareByte: myByte to: otherByte hasMore: aBlock	| mine other |	myByte == otherByte		ifTrue: [ ^ 0 ].	myByte == 0		ifTrue: [ ^ (aBlock value: true)				ifTrue: [ 1 ]				ifFalse: [ -1 ] ].	otherByte == 0		ifTrue: [ ^ (aBlock value: false)				ifTrue: [ -1 ]				ifFalse: [ 1 ] ].	mine := myByte.	other := otherByte.	[ mine odd = other odd ]		whileTrue: [ mine := mine bitShift: -1.			other := other bitShift: -1 ].	^ mine odd		ifTrue: [ (other ~~ 0 or: [ aBlock value: false ])				ifTrue: [ -1 ]				ifFalse: [ 1 ] ]		ifFalse: [ (mine ~~ 0 or: [ aBlock value: true ])				ifTrue: [ 1 ]				ifFalse: [ -1 ] ]! !!SmaCCIntegerSet methodsFor: 'private'!compareData: myData to: otherData hasMore: aBlock	| value |	myData == 0		ifTrue: [ otherData == 0				ifTrue: [ ^ 0 ].			^ (aBlock value: true)				ifTrue: [ 1 ]				ifFalse: [ -1 ] ].	myData == 1		ifTrue: [ otherData == 1				ifTrue: [ ^ 0 ].			otherData == 0				ifTrue: [ ^ (aBlock value: false)						ifTrue: [ -1 ]						ifFalse: [ 1 ] ].			^ ((self endsWithZeros: otherData) and: [ (aBlock value: false) not ])				ifTrue: [ 1 ]				ifFalse: [ -1 ] ].	otherData == 0		ifTrue: [ ^ (aBlock value: false)				ifTrue: [ -1 ]				ifFalse: [ 1 ] ].	otherData == 1		ifTrue: [ ^ ((self endsWithZeros: myData) and: [ (aBlock value: true) not ])				ifTrue: [ -1 ]				ifFalse: [ 1 ] ].	(myData isKindOf: ByteArray)		ifTrue: [ 1 to: myData size do: [ :i | 				value := self					compareByte: (myData at: i)					to: (otherData at: i)					hasMore: [ :isMine | 						(self							hasMore:								(isMine									ifTrue: [ myData ]									ifFalse: [ otherData ])							after: i) or: [ aBlock value: isMine ] ].				value ~~ 0					ifTrue: [ ^ value ] ] ]		ifFalse: [ 1 to: myData size do: [ :i | 				value := self					compareData: (myData at: i)					to: (otherData at: i)					hasMore: [ :isMine | 						(self							hasMore:								(isMine									ifTrue: [ myData ]									ifFalse: [ otherData ])							after: i) or: [ aBlock value: isMine ] ].				value ~~ 0					ifTrue: [ ^ value ] ] ].	^ 0! !!SmaCCIntegerSet methodsFor: 'private'!data	^ data! !!SmaCCIntegerSet methodsFor: 'private'!sizeOf: currentData withRun: currentRun	| nextRun |	currentData == 0		ifTrue: [ ^ 0 ].	currentData == 1		ifTrue: [ ^ currentRun * self defaultRunSize ].	currentRun == self byteSize		ifTrue: [ ^ currentData inject: 0 into: [ :sum :each | sum + (self countBits: each) ] ]		ifFalse: [ nextRun := self nextRunFrom: currentRun.			^ currentData inject: 0 into: [ :sum :each | sum + (self sizeOf: each withRun: nextRun) ] ]! !!SmaCCIntegerSet methodsFor: 'private'!copyData: anObject	| copy |	^ (anObject isKindOf: Collection)		ifTrue:			[ copy := anObject copy.			1 to: copy size do: [ :i | copy at: i put: (self copyData: (copy at: i)) ].			copy ]		ifFalse: [ anObject ]! !!SmaCCIntegerSet methodsFor: 'private'!add: anInteger to: currentData startingAt: currentStart withRun: currentRun	| newData isBits offset value |	currentData == 1		ifTrue: [ ^ 1 ].	isBits := currentRun = self byteSize.	newData := currentData == 0		ifTrue: [ (isBits				ifTrue: [ ByteArray ]				ifFalse: [ Array ]) new: self defaultRunSize withAll: 0 ]		ifFalse: [ currentData ].	offset := (anInteger - currentStart) // currentRun + 1.	^ isBits		ifTrue: [ newData at: offset put: (value := (newData at: offset) bitOr: (1 bitShift: (anInteger - currentStart) \\ currentRun)).			(value == 16rFF and: [ newData allSatisfy: [ :each | each == 16rFF ] ])				ifTrue: [ 1 ]				ifFalse: [ newData ] ]		ifFalse: [ newData				at: offset				put:					(value := self						add: anInteger						to: (newData at: offset)						startingAt: currentStart + ((offset - 1) * currentRun)						withRun: (self nextRunFrom: currentRun)).			(value == 1 and: [ newData allSatisfy: [ :each | each == 1 ] ])				ifTrue: [ 1 ]				ifFalse: [ newData ] ]! !!SmaCCIntegerSet methodsFor: 'private'!intersect: myData with: otherData	| value includeNone |	(myData == 0 or: [ otherData == 1 ])		ifTrue: [ ^ myData ].	(myData == 1 or: [ otherData == 0 ])		ifTrue: [ ^ self copyData: otherData ].	includeNone := true.	(myData isKindOf: ByteArray)		ifTrue: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := (myData at: i) bitAnd: (otherData at: i)).				includeNone := includeNone and: [ value == 0 ] ] ]		ifFalse: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := self intersect: (myData at: i) with: (otherData at: i)).				includeNone := includeNone and: [ value == 0 ] ] ].	includeNone		ifTrue: [ ^ 0 ].	^ myData! !!SmaCCIntegerSet methodsFor: 'private'!remove: anInteger from: currentData startingAt: currentStart withRun: currentRun	| newData isBits offset value |	currentData == 0		ifTrue: [ ^ 0 ].	isBits := currentRun = self byteSize.	newData := currentData == 1		ifTrue: [ isBits				ifTrue: [ ByteArray new: self defaultRunSize withAll: 16rFF ]				ifFalse: [ Array new: self defaultRunSize withAll: 1 ] ]		ifFalse: [ currentData ].	offset := (anInteger - currentStart) // currentRun + 1.	isBits		ifTrue: [ newData at: offset put: (value := (newData at: offset) bitAt: (anInteger - currentStart) \\ currentRun + 1 put: 0) ]		ifFalse: [ newData				at: offset				put:					(value := self						remove: anInteger						from: (newData at: offset)						startingAt: currentStart + ((offset - 1) * currentRun)						withRun: (self nextRunFrom: currentRun)) ].	^ (value = 0 and: [ newData allSatisfy: [ :each | each == 0 ] ])		ifTrue: [ 0 ]		ifFalse: [ newData ]! !!SmaCCIntegerSet methodsFor: 'private'!merge: myData with: otherData	| value includeAll |	(myData == 0 or: [ otherData == 1 ])		ifTrue: [ ^ self copyData: otherData ].	(myData == 1 or: [ otherData == 0 ])		ifTrue: [ ^ myData ].	includeAll := true.	(myData isKindOf: ByteArray)		ifTrue: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := (myData at: i) bitOr: (otherData at: i)).				includeAll := includeAll and: [ value == 255 ] ] ]		ifFalse: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := self merge: (myData at: i) with: (otherData at: i)).				includeAll := includeAll and: [ value == 1 ] ] ].	includeAll		ifTrue: [ ^ 1 ].	^ myData! !!SmaCCIntegerSet methodsFor: 'private'!reduceData: myData	^ myData isInteger		ifTrue: [ myData ]		ifFalse: [ myData first ]! !!SmaCCIntegerSet methodsFor: 'private'!hasMore: aCollection after: index	^ ((index + 1 to: aCollection size) allSatisfy: [ :i | (aCollection at: i) == 0 ]) not! !!SmaCCIntegerSet methodsFor: 'private'!invertData: otherData	otherData == 0		ifTrue: [ ^ 1 ].	otherData == 1		ifTrue: [ ^ 0 ].	^ (otherData isKindOf: ByteArray)		ifTrue: [ otherData collect: [ :each | each bitInvert bitAnd: 16rFF ] ]		ifFalse: [ otherData collect: [ :each | self invertData: each ] ]! !!SmaCCIntegerSet methodsFor: 'private'!privateIntersect: aCollection	| otherRun otherData |	otherRun := aCollection run.	otherData := aCollection data.	[ run > otherRun ]		whileTrue: [ run := self nextRunFrom: run.			data := self reduceData: data ].	[ otherRun > run ]		whileTrue: [ otherRun := self nextRunFrom: otherRun.			otherData := self reduceData: otherData ].	data := self intersect: data with: otherData.	normalized := false.	^ self! !!SmaCCIntegerSet methodsFor: 'private'!normalizeData: oldData	| value allAreIntegers |	(oldData isKindOf: ByteArray)		ifTrue: [ value := oldData first.			(value == 0 or: [ value == 255 ])				ifFalse: [ ^ oldData ].			2 to: oldData size do: [ :i | 				(oldData at: i) = value					ifFalse: [ ^ oldData ] ].			^ value == 255				ifTrue: [ 1 ]				ifFalse: [ 0 ] ].	(oldData isKindOf: Array)		ifTrue: [ allAreIntegers := true.			1 to: oldData size do: [ :i | 				oldData at: i put: (value := self normalizeData: (oldData at: i)).				allAreIntegers := allAreIntegers and: [ value isInteger ] ].			allAreIntegers				ifTrue: [ (oldData allSatisfy: [ :each | each = value ])						ifTrue: [ ^ value ] ] ].	^ oldData! !!SmaCCIntegerSet methodsFor: 'private'!removeData: otherData from: myData	| includeNone value |	(myData == 0 or: [ otherData == 1 ])		ifTrue: [ ^ 0 ].	otherData == 0		ifTrue: [ ^ myData ].	myData = 1		ifTrue: [ ^ self invertData: otherData ].	includeNone := true.	(myData isKindOf: ByteArray)		ifTrue: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := (myData at: i) bitAnd: (otherData at: i) bitInvert).				includeNone := includeNone and: [ value == 0 ] ] ]		ifFalse: [ 1 to: myData size do: [ :i | 				myData at: i put: (value := self removeData: (otherData at: i) from: (myData at: i)).				includeNone := includeNone and: [ value == 0 ] ] ].	includeNone		ifTrue: [ ^ 0 ].	^ myData! !!SmaCCIntegerSet methodsFor: 'private'!do: aBlock over: currentData startingAt: currentStart withRun: currentRun	| index offset nextRun |	currentData == 0		ifTrue: [ ^ self ].	currentData == 1		ifTrue:			[ ^ currentStart to: currentStart + (currentRun * self defaultRunSize) - 1			do: [ :i | aBlock value: i ] ].	index := currentStart.	currentRun = self byteSize		ifTrue:			[ currentData				do:					[ :each | 					| bits |					bits := each.					offset := 0.					[ bits = 0 ]						whileFalse:							[ bits odd								ifTrue: [ aBlock value: offset + index ].							offset := offset + 1.							bits := bits bitShift: -1 ].					index := index + currentRun ].			^ self ].	nextRun := self nextRunFrom: currentRun.	currentData		do:			[ :each | 			self				do: aBlock				over: each				startingAt: index				withRun: nextRun.			index := index + currentRun ]! !!SmaCCIntegerSet methodsFor: 'private'!byteSize	^ 8! !!SmaCCIntegerSet methodsFor: 'private'!start	^ start! !!SmaCCIntegerSet methodsFor: 'private'!countBits: anInteger	| count current |	count := 0.	current := anInteger.	[ current = 0 ]		whileFalse: [ (current bitAnd: 1) == 1				ifTrue: [ count := count + 1 ].			current := current bitShift: -1 ].	^ count! !!SmaCCIntegerSet methodsFor: 'private'!endsWithZeros: aCollection	| index isBytes all value |	isBytes := aCollection isKindOf: ByteArray.	index := 1.	all := isBytes		ifTrue: [ 255 ]		ifFalse: [ 1 ].	[ index <= aCollection size and: [ (aCollection at: index) = all ] ] whileTrue: [ index := index + 1 ].	index > aCollection size		ifTrue: [ ^ true ].	index + 1 to: aCollection size do: [ :i | 		(aCollection at: i) ~~ 0			ifTrue: [ ^ false ] ].	value := aCollection at: index.	value == 0		ifTrue: [ ^ true ].	^ isBytes		ifTrue: [ #[2r1 2r11 2r111 2r1111 2r11111 2r111111 2r1111111] includes: value ]		ifFalse: [ self endsWithZeros: value ]! !!SmaCCIntegerSet methodsFor: 'private'!run	^ run! !!SmaCCIntegerSet methodsFor: 'adding'!add: anInteger	| newData |	[ anInteger < start ]		whileTrue:			[ run := run * self defaultRunSize.			start := start - run.			data == 0				ifFalse:					[ newData := Array new: self defaultRunSize withAll: 0.					newData at: 2 put: data.					data := newData ] ].	[ self defaultRunSize * run + start <= anInteger ]		whileTrue:			[ run := run * self defaultRunSize.			data == 0				ifFalse:					[ newData := Array new: self defaultRunSize withAll: 0.					newData at: 1 put: data.					data := newData ] ].	data := self		add: anInteger		to: data		startingAt: start		withRun: run.	normalized := false.	^ anInteger! !!SmaCCIntegerSet methodsFor: 'adding'!addAll: aCollection	| otherData otherRun tempData |	(self class == aCollection class and: [ start = aCollection start ])		ifFalse: [ ^ super addAll: aCollection ].	data == 0		ifTrue: [ data := self copyData: aCollection data.			run := aCollection run ]		ifFalse: [ otherRun := aCollection run.			otherData := aCollection data.			[ run < otherRun ]				whileTrue: [ run := run * self defaultRunSize.					tempData := Array new: self defaultRunSize withAll: 0.					tempData at: 1 put: data.					data := tempData ].			[ run > otherRun ]				whileTrue: [ otherRun := otherRun * self defaultRunSize.					tempData := Array new: self defaultRunSize withAll: 0.					tempData at: 1 put: otherData.					otherData := tempData ].			data := self merge: data with: otherData ].	normalized := false.	^ aCollection! !!SmaCCIntegerSet methodsFor: 'removing'!remove: anInteger ifAbsent: aBlock	(self includes: anInteger)		ifFalse: [ ^ aBlock value ].	data := self		remove: anInteger		from: data		startingAt: start		withRun: run.	normalized := false.	^ anInteger! !!SmaCCIntegerSet methodsFor: 'removing'!smaccRemoveAll: aCollection	| otherRun otherData tempData |	self class == aCollection class		ifFalse: [ ^ super smaccRemoveAll: aCollection ].	data == 0		ifTrue: [ ^ self ].	otherRun := aCollection run.	otherData := aCollection data.	[ run < otherRun ]		whileTrue: [ otherRun := self nextRunFrom: otherRun.			otherData := self reduceData: otherData ].	[ run > otherRun ]		whileTrue: [ otherRun := otherRun * self defaultRunSize.			tempData := Array new: self defaultRunSize withAll: 0.			tempData at: 1 put: otherData.			otherData := tempData ].	data := self removeData: otherData from: data.	normalized := false.	^ aCollection! !!SmaCCIntegerSet methodsFor: 'converting'!normalize	normalized		ifTrue: [ ^ self ].	normalized := true.	data := self normalizeData: data.	[ data = 0		ifTrue: [ ^ run := self defaultRunSize ].	data = 1		ifTrue: [ ^ self ].	run > self defaultRunSize		ifFalse: [ ^ self ].	2 to: data size do: [ :i | 		(data at: i) = 0			ifFalse: [ ^ self ] ].	data := data first.	run := self nextRunFrom: run ] repeat! !!SmaCCIntegerSet methodsFor: 'accessing'!first	self do: [ :each | ^ each ].	self error: 'Collection is empty'! !!SmaCCIntegerSet methodsFor: 'accessing'!size	^ self sizeOf: data withRun: run! !!SmaCCIntegerSet methodsFor: 'enumerating'!smaccIntersect: aCollection	aCollection class == self class		ifFalse: [ ^ super smaccIntersect: aCollection ].	self normalize.	aCollection normalize.	(self == aCollection or: [ data == 0 or: [ aCollection data = 1 and: [ aCollection run >= run ] ] ])		ifTrue: [ ^ self copy ].	(aCollection data == 0 or: [ data = 1 and: [ run >= aCollection run ] ])		ifTrue: [ ^ aCollection copy ].	^ self copy privateIntersect: aCollection! !!SmaCCIntegerSet methodsFor: 'enumerating'!do: aBlock	self		do: aBlock		over: data		startingAt: start		withRun: run! !!SmaCCIntegerSet methodsFor: 'enumerating'!select: aBlock	| selected |	selected := self copy.	self		do: [ :each | 			(aBlock value: each)				ifFalse: [ selected remove: each ] ].	selected normalize.	^ selected! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCIntegerSet class	instanceVariableNames: ''!!SmaCCIntegerSet class methodsFor: 'instance creation'!new: aSize	^ self new! !!SmaCCIntegerSet class methodsFor: 'instance creation'!withAll: aCollection	self == aCollection class		ifTrue: [ ^ aCollection copy ].	^ super withAll: aCollection! !SmaCCIntegerSet subclass: #SmaCCCharacterSet	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Development-Collections'!!SmaCCCharacterSet methodsFor: 'enumerating'!do: aBlock	^ super do: [ :each | aBlock value: (Character value: each) ]! !!SmaCCCharacterSet methodsFor: 'removing'!remove: aCharacter ifAbsent: aBlock	(self includes: aCharacter)		ifFalse: [ ^ aBlock value ].	super remove: aCharacter asInteger ifAbsent: aBlock.	^ aCharacter! !!SmaCCCharacterSet methodsFor: 'initialize-release'!initializeWithAllCharactersTo: aCharacter	| current index value |	self add: aCharacter.	current := data.	[ current isKindOf: Collection ]		whileTrue: [ index := 1.			[ (value := current at: index) = 0 ]				whileTrue: [ current						at: index						put:							((current isKindOf: ByteArray)								ifTrue: [ 255 ]								ifFalse: [ 1 ]).					index := index + 1 ].			(value isKindOf: Collection)				ifFalse: [ current at: index put: (value bitOr: value - 1) ].			current := value ]! !!SmaCCCharacterSet methodsFor: 'adding'!add: aCharacter	super add: aCharacter asInteger.	^ aCharacter! !!SmaCCCharacterSet methodsFor: 'testing'!includes: aCharacter	^ super includes: aCharacter asInteger! !!SmaCCCharacterSet methodsFor: 'converting'!asString	| stream |	stream := WriteStream on: String new.	self do: [ :each | stream nextPut: each ].	^ stream contents! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCCharacterSet class	instanceVariableNames: ''!!SmaCCCharacterSet class methodsFor: 'instance creation'!withAllCharactersTo: aCharacter	^ self new		initializeWithAllCharactersTo: aCharacter;		yourself! !Collection subclass: #SmaCCSet	instanceVariableNames: 'characters objects'	classVariableNames: ''	package: 'SmaCC_Development-Collections'!!SmaCCSet methodsFor: 'removing'!remove: oldObject ifAbsent: aBlock	^ (oldObject isKindOf: Character)		ifTrue: [ characters remove: oldObject ifAbsent: aBlock ]		ifFalse: [ objects remove: oldObject ifAbsent: aBlock ]! !!SmaCCSet methodsFor: 'adding'!add: newObject	^ (newObject isKindOf: Character)		ifTrue: [ characters add: newObject ]		ifFalse: [ objects add: newObject ]! !!SmaCCSet methodsFor: 'adding'!addAll: aCollection	(aCollection isKindOf: SmaCCCharacterSet)		ifTrue: [ ^ characters addAll: aCollection ].	^ super addAll: aCollection! !!SmaCCSet methodsFor: 'enumerating'!commonElementWith: aCollection	| intersected |	characters class = aCollection class		ifTrue: [ intersected := characters smaccIntersect: aCollection.			^ intersected isEmpty				ifTrue: [ nil ]				ifFalse: [ intersected first ] ].	aCollection		do: [ :each | 			(self includes: each)				ifTrue: [ ^ each ] ].	^ nil! !!SmaCCSet methodsFor: 'enumerating'!do: aBlock	objects do: aBlock.	characters do: aBlock! !!SmaCCSet methodsFor: 'testing'!includes: anObject	^ (anObject isKindOf: Character)		ifTrue: [ characters includes: anObject ]		ifFalse: [ objects includes: anObject ]! !!SmaCCSet methodsFor: 'testing'!isEmpty	^ characters isEmpty and: [ objects isEmpty ]! !!SmaCCSet methodsFor: 'initialize-release'!initialize	super initialize.	characters := SmaCCCharacterSet new.	objects := Set new! !Model subclass: #SmaCCSymbolSet	instanceVariableNames: 'symbols components'	classVariableNames: ''	package: 'SmaCC_Development-Collections'!!SmaCCSymbolSet methodsFor: 'initialize-release'!initialize	super initialize.	symbols := Set new.	components := Set new! !!SmaCCSymbolSet methodsFor: 'updating'!update: anAspectSymbol with: aParameter from: aSender	(components includes: aSender)		ifTrue: [ self addAll: aSender symbols ]! !!SmaCCSymbolSet methodsFor: 'testing'!includes: aSmaCCSymbol	^ symbols includes: aSmaCCSymbol! !!SmaCCSymbolSet methodsFor: 'testing'!allSatisfy: aBlock	^ symbols allSatisfy: aBlock! !!SmaCCSymbolSet methodsFor: 'public'!getDependents	^ dependents! !!SmaCCSymbolSet methodsFor: 'public'!setDependents: aCollection	^ dependents := aCollection! !!SmaCCSymbolSet methodsFor: 'accessing'!components	^ components! !!SmaCCSymbolSet methodsFor: 'accessing'!addComponent: aSmaCCSymbolSet	(aSmaCCSymbolSet = self or: [ components includes: aSmaCCSymbolSet ])		ifTrue: [ ^ self ].	components add: aSmaCCSymbolSet.	aSmaCCSymbolSet addDependent: self.	self addAll: aSmaCCSymbolSet symbols! !!SmaCCSymbolSet methodsFor: 'accessing'!addComponentsFrom: aSmaCCSymbolSet	aSmaCCSymbolSet components do: [ :each | self addComponent: each ]! !!SmaCCSymbolSet methodsFor: 'accessing'!baseOn: aSmaCCSymbolSet	self addComponent: aSmaCCSymbolSet.	self addAll: aSmaCCSymbolSet symbols! !!SmaCCSymbolSet methodsFor: 'accessing'!size	^ symbols size! !!SmaCCSymbolSet methodsFor: 'accessing'!mergeWith: aSmaCCSymbolSet	self addAll: aSmaCCSymbolSet symbols.	self addComponentsFrom: aSmaCCSymbolSet! !!SmaCCSymbolSet methodsFor: 'accessing'!addAll: aCollection	| todo |	todo := OrderedCollection with: self.	[ todo notEmpty ]		whileTrue:			[ | oldSize current |			current := todo removeFirst.			oldSize := current symbols size.			current symbols addAll: aCollection.			oldSize ~= current symbols size				ifTrue: [ todo addAll: current dependents ] ]! !!SmaCCSymbolSet methodsFor: 'accessing'!symbols	^ symbols! !!SmaCCSymbolSet methodsFor: 'accessing'!add: aSmaCCSymbol	(symbols includes: aSmaCCSymbol)		ifTrue: [ ^ self ].	symbols add: aSmaCCSymbol.	self changed! !!SmaCCSymbolSet methodsFor: 'printing'!printOn: aStream	(symbols asSortedCollection: [ :a :b | a name < b name ])		do: [ :each | aStream nextPutAll: each printString ]		separatedBy: [ aStream space ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCSymbolSet class	instanceVariableNames: ''!!SmaCCSymbolSet class methodsFor: 'instance creation'!basedOn: aSmaCCSymbolSet	^ self new		baseOn: aSmaCCSymbolSet;		yourself! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.874656 pm'!!SmaCCToken methodsFor: '*SmaCC_Development'!position	^ self startPosition! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.875656 pm'!!SmaCCConcatenationRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ SmaCCSequenceRENode nodes: (self items collect: [ :each | each regularExpression ])! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.876656 pm'!!SmaCCAlternationRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ SmaCCOrRENode nodes: (self items collect: [ :each | each regularExpression ])! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.877656 pm'!!SmaCCCharacterRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| ch |	ch := self char value.	ch = '.'		ifTrue: [ ^ SmaCCCharacterRENode characters: self allCharacters ].	ch first = $\		ifTrue: [ ^ self nodeFor: (ReadStream on: (ch copyFrom: 2 to: ch size)) ].	^ SmaCCCharacterRENode characters: (SmaCCCharacterSet withAll: ch)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.877656 pm'!!SmaCCTokenRuleNode methodsFor: '*SmaCC_Development'!reportCircularDefinitionError	SmaCCParserError new		messageText: 'Circular token definition';		tag: name;		signal! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.878656 pm'!!SmaCCTokenRuleNode methodsFor: '*SmaCC_Development'!regularExpression	| re |	(self attributeNamed: #regularExpression ifAbsent: [ nil ])		ifNotNil: [ :each | ^ each ].	(self attributeNamed: #buildingRegularExpression ifAbsent: [ false ])		ifTrue: [ self reportCircularDefinitionError ].	self attributeNamed: #buildingRegularExpression put: true.	re := SmaCCSequenceRENode nodes: {regex regularExpression}.	self attributeNamed: #regularExpression put: re.	self removeAttributeNamed: #buildingRegularExpression.	re position: self name startPosition.	self states do: [ :each | re addState: each value asSymbol ].	^ re! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.879656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!tabString	^ SmaCCCharacterSet withAll: '	'! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.880656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!hexStringFrom: aStream	^ SmaCCCharacterSet with: (Character value: (self hexValueFrom: aStream))! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.880656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!hexValueFrom: aStream	| char value count |	count := value := 0.	[ aStream atEnd not		and: [ count < 4				and: [ char := aStream peek.					(char between: $0 and: $9) or: [ (char between: $A and: $F) or: [ char between: $a and: $f ] ] ] ] ]		whileTrue: [ count := count + 1.			value := value * 16 + aStream next digitValue ].	^ value! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.881656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ self subclassResponsibility! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.882656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!regularExpression	^ self attributeNamed: #regularExpression ifAbsentPut: [ self asRegularExpression ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.883656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!verticalTabString	^ SmaCCCharacterSet with: (Character value: 11)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.883656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!whitespaceValues	^ #[9 10 11 12 13 32]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.884656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isWhitespace: each	^ self whitespaceValues includes: each asInteger! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.885656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isLetterOrDigit: each	^ (each between: $a and: $z) or: [ (each between: $A and: $Z) or: [ (self isDigit: each) or: [ each == $_ ] ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.885656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!isDigit: each	^ each between: $0 and: $9! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.886656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!formFeedString	^ SmaCCCharacterSet with: (Character value: 12)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.887656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!allCharacters	^ SmaCCGrammar allCharacters! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.887656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!newlineString	^ SmaCCCharacterSet with: (Character value: 10)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.888656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!carriageReturnString	^ SmaCCCharacterSet with: (Character value: 13)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.889656 pm'!!SmaCCRegexNode methodsFor: '*SmaCC_Development'!nodeFor: aStream	| block char |	block := nil.	char := aStream next.	char == $f		ifTrue: [ ^ SmaCCCharacterRENode characters: self formFeedString ].	char == $n		ifTrue: [ ^ SmaCCCharacterRENode characters: self newlineString ].	char == $r		ifTrue: [ ^ SmaCCCharacterRENode characters: self carriageReturnString ].	char == $t		ifTrue: [ ^ SmaCCCharacterRENode characters: self tabString ].	char == $v		ifTrue: [ ^ SmaCCCharacterRENode characters: self verticalTabString ].	char == $c		ifTrue: [ ^ SmaCCCharacterRENode characters: (SmaCCCharacterSet with: (Character value: aStream next asInteger - $A asInteger)) ].	char == $x		ifTrue: [ ^ SmaCCCharacterRENode characters: (self hexStringFrom: aStream) ].	char == $d		ifTrue: [ block := [ :each | self isDigit: each ] ].	char == $D		ifTrue: [ block := [ :each | (self isDigit: each) not ] ].	char == $s		ifTrue: [ block := [ :each | self isWhitespace: each ] ].	char == $S		ifTrue: [ block := [ :each | (self isWhitespace: each) not ] ].	char == $w		ifTrue: [ block := [ :each | self isLetterOrDigit: each ] ].	char == $W		ifTrue: [ block := [ :each | (self isLetterOrDigit: each) not ] ].	block isNil		ifTrue: [ ^ SmaCCCharacterRENode characters: (SmaCCCharacterSet with: char) ].	^ SmaCCCharacterRENode characters: (self allCharacters select: block)! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.889656 pm'!!SmaCCRepeatRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| re |	re := self regex regularExpression.	count value = '*'		ifTrue: [ ^ re repeat ].	count value = '+'		ifTrue: [ ^ re repeatForAtLeast: 1 ].	count value = '?'		ifTrue: [ ^ re repeatFor: 0 to: 1 ].	count value first = ${		ifTrue: [ | readStream start stop |			readStream := ReadStream on: (count value copyFrom: 2 to: count value size - 1).			start := readStream upTo: $,.			stop := readStream upToEnd.			^ re				repeatFor:					(start isEmpty						ifTrue: [ 0 ]						ifFalse: [ start asNumber ])				to:					(stop isEmpty						ifTrue: [ 1 bitShift: 31 ]						ifFalse: [ stop asNumber ]) ].	self reportCountError! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.890656 pm'!!SmaCCRepeatRegexNode methodsFor: '*SmaCC_Development'!reportCountError	SmaCCParserError new		messageText: 'Unknown repeat count';		tag: count;		signal! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.891656 pm'!!SmaCCTokenRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	^ (self topParent tokenNamed: name value)		ifNotNil: [ :rule | rule regularExpression copy ]		ifNil: [ (SmaCCGrammar implicitToken: name value) ifNil: [ self reportMissingTokenDefinition ] ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.892656 pm'!!SmaCCTokenRegexNode methodsFor: '*SmaCC_Development'!reportMissingTokenDefinition	SmaCCParserError new		messageText: 'Missing token definition';		tag: name;		signal! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.893656 pm'!!Collection methodsFor: '*SmaCC_Development'!smaccRemoveAll: aCollection	aCollection do: [ :each | self remove: each ifAbsent: [  ] ].	^ aCollection! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.894656 pm'!!Collection methodsFor: '*SmaCC_Development'!smaccIntersect: aCollection	^ self select: [ :each | aCollection includes: each ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.894656 pm'!!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!asRegularExpression	| characters aStream invert node |	aStream := ReadStream on: (block value copyFrom: 2 to: block value size - 1).	characters := OrderedCollection new.	invert := aStream peekFor: $^.	[ aStream atEnd ] whileFalse: [ characters addAll: (self charactersFor: aStream) ].	node := SmaCCCharacterRENode characters: (SmaCCCharacterSet withAll: characters).	invert		ifTrue: [ node := SmaCCNotRENode on: node ].	^ node! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.895656 pm'!!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!charactersFor: aStream	| characters char endCharacters |	aStream atEnd		ifTrue: [ self reportCharacterBlockError ].	char := aStream next.	characters := char == $\		ifTrue: [ (self nodeFor: aStream) characters ]		ifFalse: [ OrderedCollection with: char ].	(characters size = 1 and: [ aStream peekFor: $- ])		ifFalse: [ ^ characters ].	endCharacters := self charactersFor: aStream.	endCharacters size > 1		ifTrue: [ self reportCharacterBlockError ].	^ (characters first asInteger to: endCharacters first asInteger) collect: [ :each | Character value: each ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.896656 pm'!!SmaCCCharacterBlockRegexNode methodsFor: '*SmaCC_Development'!reportCharacterBlockError	SmaCCParserError new		messageText: 'Invalid character block';		tag: block;		signal! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.897656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Development'!recompileAll	"self recompileAll"	self withAllSubclasses		do: [ :each | each compileGrammar: each definitionString ]		displayingProgress: [ :each | 'Compiling ' , each instanceSide name ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.897656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Development'!definitionAST	^ [ SmaCCDefinitionParser parse: self definitionString ]		on: SmaCCParserError		do: [ :ex | ex return: nil ]! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.898656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Development'!definitionString	| scannerClass source |	scannerClass := [ self scannerClass ]		on: Error		do: [ :ex | ex return: nil ].	(self class includesSelector: #definitionComment)		ifTrue: [ source := self removeCommentedPartOf: (self class sourceCodeAt: #definitionComment) ]		ifFalse: [ source := ''.			(self class includesSelector: #parserDefinitionComment)				ifTrue: [ source := self removeCommentedPartOf: (self class sourceCodeAt: #parserDefinitionComment) ].			(scannerClass notNil and: [ scannerClass class includesSelector: #scannerDefinitionComment ])				ifTrue:					[ source := (self removeCommentedPartOf: (scannerClass class sourceCodeAt: #scannerDefinitionComment)) , '\' withCRs , source ] ].	^ source! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.899656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Development'!removeCommentedPartOf: aString	| inStream outStream |	inStream := ReadStream on: aString.	outStream := WriteStream with: String new.	inStream upTo: $".	[ inStream atEnd ]		whileFalse: [ (inStream peekFor: $")				ifTrue: [ outStream nextPut: $" ].			outStream nextPutAll: (inStream upTo: $") ].	^ outStream contents! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:49.899656 pm'!!SmaCCParser class methodsFor: '*SmaCC_Development'!compileGrammar: aString	| oldCharacterSize |	(aString isNil or: [ aString isEmpty ])		ifTrue: [ ^ self ].	oldCharacterSize := SmaCCGrammar maximumCharacterValue.	[ SmaCCGrammarCompiler new		buildDefinition: aString;		compileInto: self scannerClass andParser: self ]		ensure: [ SmaCCGrammar maximumCharacterValue: oldCharacterSize ]! !