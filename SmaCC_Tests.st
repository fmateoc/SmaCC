TestCase subclass: #DuplicationNodeEliminationTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!DuplicationNodeEliminationTest methodsFor: 'tests'!testNoDuplicates	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 3.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 3.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects asString = 'a'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects asString = 'a'.	node3 := node2 transitions first to.	self deny: node1 = node3.	self deny: node2 = node3.	self assert: node3 transitions size = 1.	self assert: (node3 action includes: 3).	self assert: node3 transitions first transitionObjects asString = 'a'.	self assert: node3 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests'!testSimpleDuplicateWithEdges	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node2 addEdgeTo: node1 onCharacters: 'c'.	node3 addEdgeTo: node1 onCharacters: 'c'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self		assert: node1 transitions first transitionObjects asString = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions size = 1.	self assert: (node2 action includes: 2).	self assert: node2 transitions first transitionObjects asString = 'c'.	self assert: node2 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests'!testDuplicateLoop	| node1 node2 node3 |	node1 := SmaCCNode new.	node1 action: 1.	node2 := SmaCCNode new.	node2 action: 1.	node3 := SmaCCNode new.	node3 action: 1.	node1 addEdgeTo: node2 onCharacters: 'a'.	node2 addEdgeTo: node3 onCharacters: 'a'.	node3 addEdgeTo: node1 onCharacters: 'a'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 1.	self assert: node1 transitions size = 1.	self assert: (node1 action includes: 1).	self assert: node1 transitions first transitionObjects asString = 'a'.	self assert: node1 transitions first to = node1! !!DuplicationNodeEliminationTest methodsFor: 'tests'!testSimpleTerminalDuplicate	| node1 node2 node3 |	node1 := SmaCCNode new.	node2 := SmaCCNode new.	node2 action: 2.	node3 := SmaCCNode new.	node3 action: 2.	node1 addEdgeTo: node2 onCharacters: 'a'.	node1 addEdgeTo: node3 onCharacters: 'b'.	node1 := node1 removeDuplicateNodes.	self assert: node1 allStates size = 2.	self assert: node1 transitions size = 1.	self		assert: node1 transitions first transitionObjects asString = 'ab'.	node2 := node1 transitions first to.	self deny: node1 = node2.	self assert: node2 transitions isEmpty.	self assert: (node2 action includes: 2)! !TestCase subclass: #LineNumberStreamTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!LineNumberStreamTest methodsFor: 'tests'!testPositionCRLines	| stream |	stream := SmaCCLineNumberStream on: (ReadStream on: (self addCRsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream position: stream position - 1.	self assert: stream lineNumber = 4.	self assert: stream columnNumber = 1.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 2.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LineNumberStreamTest methodsFor: 'tests'!testLFLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addLFsTo: '1234\1234\1234\1234')).	1 to: 4 do:		[ :each | 		self assert: stream lineNumber = each.		4			timesRepeat:				[ self					assert: stream columnNumber = (stream next asInteger - $0 asInteger) ].		stream upTo: Character lf ]! !!LineNumberStreamTest methodsFor: 'tests'!testForwardPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LineNumberStreamTest methodsFor: 'tests'!testCRLFLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addCRLFsTo: '1234\1234\1234\1234')).	1 to: 4 do:		[ :each | 		self assert: stream lineNumber = each.		4			timesRepeat:				[ self					assert: stream columnNumber = (stream next asInteger - $0 asInteger) ].		stream upTo: Character lf ]! !!LineNumberStreamTest methodsFor: 'tests'!testEmptyLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addCRsTo: '\\\')).	1 to: 4 do:		[ :each | 		self assert: stream lineNumber = each.		stream upTo: Character cr ]! !!LineNumberStreamTest methodsFor: 'tests'!testCRLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addCRsTo: '1234\1234\1234\1234')).	1 to: 4 do:		[ :each | 		self assert: stream lineNumber = each.		4			timesRepeat:				[ self					assert: stream columnNumber = (stream next asInteger - $0 asInteger) ].		stream upTo: Character cr ]! !!LineNumberStreamTest methodsFor: 'tests'!testNoLines	| stream index |	stream := SmaCCLineNumberStream on: (ReadStream on: 'this is a test').	self assert: stream lineNumber = 1.	index := 1.	stream		do:			[ :each | 			self assert: stream lineNumber = 1.			index := index + 1.			self assert: stream columnNumber = index ]! !!LineNumberStreamTest methodsFor: 'tests'!testPositionCRLFLines	| stream |	stream := SmaCCLineNumberStream		on: (ReadStream on: (self addCRLFsTo: '1\2\3\4')).	self assert: stream lineNumber = 1.	stream upTo: $5.	self assert: stream lineNumber = 4.	stream position: 0.	self assert: stream lineNumber = 1.	self assert: stream columnNumber = 1.	stream position: 3.	self assert: stream lineNumber = 2.	self assert: stream columnNumber = 1! !!LineNumberStreamTest methodsFor: 'private'!addCRsTo: aString	^ aString copyReplaceAll: '\' with: (String with: Character cr)! !!LineNumberStreamTest methodsFor: 'private'!addLFsTo: aString	^ aString copyReplaceAll: '\' with: (String with: Character lf)! !!LineNumberStreamTest methodsFor: 'private'!addCRLFsTo: aString	^ aString		copyReplaceAll: '\'		with: (String with: Character cr with: Character lf)! !TestCase subclass: #SmaCCBitCollectionTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!SmaCCBitCollectionTest methodsFor: 'tests'!testGrowing	| collection count |	collection := self newCollection.	collection add: (self value: 256).	count := 0.	collection do: [ :each | count := count + 1 ].	self assert: count = 1.	self assert: collection size = 1.	self assert: collection notEmpty.	self assert: (collection includes: (self value: 256)).	self deny: (collection includes: (self value: 1)).	collection remove: (self value: 256).	self deny: (collection includes: (self value: 256)).	self assert: collection size = 0! !!SmaCCBitCollectionTest methodsFor: 'tests'!testAddAll	| collection large medium |	self supportsLargeValues		ifFalse: [ ^ self ].	large := self largeSet.	medium := self mediumSet.	collection := large copy.	collection addAll: medium.	self assert: collection size = large size.	collection := medium copy.	collection addAll: large.	self assert: collection size = large size.	collection := self newCollection.	collection addAll: medium.	self assert: collection size = medium size.	collection := self newCollection.	collection addAll: large.	self assert: collection size = large size! !!SmaCCBitCollectionTest methodsFor: 'tests'!testComparing	| a b |	a := self newCollection.	a addAll: self mediumCollection.	b := self newCollection.	b addAll: self mediumCollection reverse.	self assert: a hash = b hash.	self assert: a = b.	self supportsLargeValues		ifFalse: [ ^ self ].	b		add: (self value: self largeValue);		remove: (self value: self largeValue).	self assert: a hash = b hash.	self assert: a = b.	self assert: (self setClass with: (self value: 1)) < (self setClass with: (self value: 2)).	self assert: (self setClass with: (self value: 8)) < (self setClass with: (self value: 16))! !!SmaCCBitCollectionTest methodsFor: 'tests'!testPerformance	| myTime setTime |	myTime := Time		millisecondsToRun: [ self newCollection addAll: self largeCollection ].	setTime := Time		millisecondsToRun: [ Set new addAll: self largeCollection ].	setTime := setTime max: 1000.	"Some implementations of Set don't have performance problems"	self assert: myTime < (setTime // 2)! !!SmaCCBitCollectionTest methodsFor: 'tests'!testLessThan	| a b |	a := self mediumSet.	b := self mediumSet.	self deny: a < b.	self deny: a > b.	self assert: a <= b.	self assert: a >= b.	b remove: (self value: 1).	self assert: a < b.	self deny: a > b.	self assert: a <= b.	self deny: a >= b.	b add: (self value: 1).	b remove: (self value: 2).	self assert: a < b.	self deny: a > b.	self assert: a <= b.	self deny: a >= b.	self supportsLargeValues		ifFalse: [ ^ false ].	b		add: (self value: 2);		remove: (self value: 1000).	self deny: a < b.	self assert: a > b.	self deny: a <= b.	self assert: a >= b! !!SmaCCBitCollectionTest methodsFor: 'tests'!testCopying	| a b |	a := self mediumSet.	b := a copy.	b remove: (self value: 5).	self assert: (a includes: (self value: 5)).	self deny: (b includes: (self value: 5))! !!SmaCCBitCollectionTest methodsFor: 'tests'!testIntersect	| collection other |	collection := self byteSizeSet.	other := self newCollection		add: (self value: 128);		yourself.	collection := collection smaccIntersect: other.	self assert: collection size = 1.	self assert: (collection includes: (self value: 128)).	other := other smaccIntersect: self byteSizeSet.	self assert: other size = 1.	other := other smaccIntersect: (self setClass with: (self value: 1)).	self assert: other isEmpty.	self supportsLargeValues		ifFalse: [ ^ self ].	collection := self byteSizeSet.	other := self largeSet.	collection := collection smaccIntersect: other.	self assert: collection size = 255.	self deny: (collection includes: (self value: 0)).	self assert: (collection includes: (self value: 1)).	self deny: (collection includes: (self value: 256)).	collection := self largeSet.	other := self byteSizeSet.	collection := collection smaccIntersect: other.	self assert: collection size = 255! !!SmaCCBitCollectionTest methodsFor: 'tests'!testABunch	| collection count |	collection := self byteSizeSet.	count := 0.	collection do: [ :each | count := count + 1 ].	self assert: count = 256.	self assert: collection size = 256.	self assert: collection notEmpty.	self		assert:			(self byteSizeCollection				allSatisfy: [ :each | collection includes: each ]).	self assert: collection asArray = self byteSizeCollection asArray! !!SmaCCBitCollectionTest methodsFor: 'tests'!testNew	self assert: self newCollection size = 0.	self assert: self newCollection isEmpty! !!SmaCCBitCollectionTest methodsFor: 'tests'!testAddToNextByte	| collection count |	collection := self newCollection.	collection add: (self value: 8).	count := 0.	collection do: [ :each | count := count + 1 ].	self assert: count = 1.	self assert: collection size = 1.	self assert: collection notEmpty.	self assert: (collection includes: (self value: 8)).	self deny: (collection includes: (self value: 7)).	self deny: (collection includes: (self value: 9))! !!SmaCCBitCollectionTest methodsFor: 'tests'!testRemoving	| collection |	collection := self newCollection.	collection add: (self value: 1).	self assert: collection size = 1.	collection remove: (self value: 1).	self assert: collection size = 0.	self deny: (collection includes: (self value: 1))! !!SmaCCBitCollectionTest methodsFor: 'tests'!testRemoveAll	| collection toRemove |	collection := self byteSizeSet.	toRemove := self newCollection		add: (self value: 128);		yourself.	collection smaccRemoveAll: toRemove.	self assert: collection size = 255.	self deny: (collection includes: (self value: 128)).	toRemove smaccRemoveAll: collection.	self assert: toRemove size = 1.	toRemove smaccRemoveAll: self byteSizeSet.	self assert: toRemove isEmpty.	self supportsLargeValues		ifFalse: [ ^ self ].	collection := self byteSizeSet.	toRemove := self largeSet.	collection smaccRemoveAll: toRemove.	self assert: collection size = 1.	self assert: (collection includes: (self value: 0)).	collection := self largeSet.	toRemove := self byteSizeSet.	collection smaccRemoveAll: toRemove.	self assert: self largeCollection size - 255 = collection size! !!SmaCCBitCollectionTest methodsFor: 'tests'!testAdding	| collection count |	collection := self newCollection.	collection add: (self value: 1).	count := 0.	collection do: [ :each | count := count + 1 ].	self assert: count = 1.	self assert: collection size = 1.	self assert: collection notEmpty.	self assert: (collection includes: (self value: 1)).	self deny: (collection includes: (self value: 0)).	self deny: (collection includes: (self value: 2))! !!SmaCCBitCollectionTest methodsFor: 'private'!supportsLargeValues	^ true! !!SmaCCBitCollectionTest methodsFor: 'private'!setClass	^ SmaCCIntegerSet! !!SmaCCBitCollectionTest methodsFor: 'private'!largeSet	^ self setClass withAll: self largeCollection! !!SmaCCBitCollectionTest methodsFor: 'private'!largeValue	^ 1000000! !!SmaCCBitCollectionTest methodsFor: 'private'!newCollection	^ self setClass new! !!SmaCCBitCollectionTest methodsFor: 'private'!value: anInteger	^ anInteger! !!SmaCCBitCollectionTest methodsFor: 'private'!byteSizeCollection	^ (0 to: 255) collect: self! !!SmaCCBitCollectionTest methodsFor: 'private'!byteSizeSet	^ self newCollection		addAll: self byteSizeCollection;		yourself! !!SmaCCBitCollectionTest methodsFor: 'private'!mediumCollection	^ (1 to: 1000) collect: self! !!SmaCCBitCollectionTest methodsFor: 'private'!largeCollection	^ (1 to: 50000) collect: self! !!SmaCCBitCollectionTest methodsFor: 'private'!mediumSet	^ self setClass withAll: self mediumCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCBitCollectionTest class	instanceVariableNames: ''!!SmaCCBitCollectionTest class methodsFor: 'testing'!isAbstract	^ self == SmaCCBitCollectionTest! !SmaCCBitCollectionTest subclass: #SmaCCCharacterSetTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!SmaCCCharacterSetTest methodsFor: 'private'!supportsLargeValues	[ Character value: 1000 ]		on: Error		do: [ :ex | ^ false ].	^ true! !!SmaCCCharacterSetTest methodsFor: 'private'!value: anInteger	^ Character		value:			(self supportsLargeValues				ifTrue: [ anInteger ]				ifFalse: [ anInteger bitAnd: 16rFF ])! !!SmaCCCharacterSetTest methodsFor: 'private'!setClass	^ SmaCCCharacterSet! !!SmaCCCharacterSetTest methodsFor: 'tests'!testAllCharacterRange	| collection |	collection := SmaCCCharacterSet withAllCharactersTo: (Character value: 254).	self assert: collection size = 255.	self deny: (collection includes: (Character value: 255)).	self assert: (collection includes: (Character value: 254)).	self assert: (collection includes: (Character value: 0)).	self supportsLargeValues		ifFalse: [ ^ self ].	collection := SmaCCCharacterSet withAllCharactersTo: (Character value: (1 << 21) - 1).	self assert: collection size = (1 << 21).	self deny: (collection includes: (Character value: 1 << 21)).	self assert: (collection includes: (Character value: (1 << 21) - 1)).	self assert: (collection includes: (Character value: 0))! !TestCase subclass: #SmaCCEndToEndTest	instanceVariableNames: 'currentClasses currentPackage manager'	classVariableNames: ''	package: 'SmaCC_Tests'!!SmaCCEndToEndTest methodsFor: 'running'!setUp	super setUp.	SmaCCCodeGenerator reset.	self setUpClasses! !!SmaCCEndToEndTest methodsFor: 'running'!tearDown	self removeNewClasses.	super tearDown! !!SmaCCEndToEndTest methodsFor: 'tests-error'!testErrorRecovery	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<whitespace> : \s+ ;                        <integer> : \d+;                        Start : Items {''1''};                        Items : { 0 }                                | Items Integer { ''1'' + ''2'' }                                | Items error { ''1'' negated };                        Integer : <integer> { ''1'' value asInteger };                        '.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parseWithErrors: '1 2 3') = 6.	self assert: (self parserClass parseWithErrors: '1 2 a') = -3.	self assert: (self parserClass parseWithErrors: 'a 1 2') = 3! !!SmaCCEndToEndTest methodsFor: 'tests-error'!testGlrErrorRecovery	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'%glr;			<whitespace> : \s+ ;                        <integer> : \d+;                        Start : Items {''1''};                        Items : { 0 }                                | Items Integer { ''1'' + ''2'' }                                | Items error { ''1'' negated };                        Integer : <integer> { ''1'' value asInteger };                        '.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parseWithErrors: '1 2 3') = 6.	self assert: (self parserClass parseWithErrors: '1 2 a') = -3.	self assert: (self parserClass parseWithErrors: 'a 1 2') = 3! !!SmaCCEndToEndTest methodsFor: 'tests-error'!testLALRErrorHandler	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<whitespace> : \s+ ;			Start : Foo "]" Foo ")";			Foo : "a" Bar ;			Bar : "b" | error ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		should: [ self parserClass parse: 'a ] a b )' ]		raise: SmaCCParserError.	self		should: [ self parserClass parse: 'a ) a b )' ]		raise: SmaCCParserError.	self		should: [ self parserClass parse: 'a b ] a  ]' ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests-error'!testAutomaticErrorNodes	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			P : A ''a'' B ''b'' C ''c'' {{FooRootNode}} ;			A : "a" ''token'' {{FooTokenNode}} ;			B : "b" ''token'' {{FooTokenNode}} ;			C : "c" ''token'' {{FooTokenNode}} ; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'abc'.	self assert: node a token value = 'a'.	self assert: node b token value = 'b'.	self assert: node c token value = 'c'.	node := self parserClass parseWithErrors: 'ac'.	self assert: node a token value = 'a'.	self assert: node b class = SmaCCErrorNode.	self assert: node c token value = 'c'.	node := self parserClass parseWithErrors: 'ab'.	self assert: node a token value = 'a'.	self assert: node b token value = 'b'.	self assert: node c class = SmaCCErrorNode.	node := self parserClass parseWithErrors: 'bc'.	self assert: node a class = SmaCCErrorNode.	self assert: node b token value = 'b'.	self assert: node c token value = 'c'.	node := self parserClass parseWithErrors: 'axbc'.	self assert: node a class = SmaCCErrorNode.	self assert: node b token value = 'b'.	self assert: node c token value = 'c'! !!SmaCCEndToEndTest methodsFor: 'public'!testVariableCollectionType	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : Commas {{FooANode}} ;			Commas : "," ''comma'' | Commas "," ''comma'' ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert:			self parserClass basicNew symbolTypes asSet asSortedCollection asArray				= #(#FooANode #OrderedCollection #SmaCCErrorNode #SmaCCToken)! !!SmaCCEndToEndTest methodsFor: 'public'!testUnnamedNodeVariable	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%glr;			<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B D {{FooANode}};			B : <number> ''a'' <number> ''b'' {{FooBNode}} | ;			D : <number> ''c''; '.	self		assert:			([ compiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do:					[ :ex | 					('Node creation' = ex messageText and: [ '*>>>B<<<*' match: ex tag ])						ifTrue: [ ex return: true ]						ifFalse: [ ex resume: nil ] ])! !!SmaCCEndToEndTest methodsFor: 'public'!testRenamedVariableCollection	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : Commas ''separator'' "a" ''a'' Commas {{FooANode}} ;			Commas : | Commas "," ''comma'' ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ',,,a,,,'.	self assert: node separators size = 3.	self assert: node separators first value = ','.	self assert: node separators first startPosition = 1.	self		assert:			node compositeTokenVariables asSortedCollection asArray				= #(#commas #separators).	self deny: (self parserClass basicNew symbolTypes includes: #Object)! !!SmaCCEndToEndTest methodsFor: 'public'!testRenamedNullableVariable	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%glr;			%root FooNode;			A : B ''separator'' C {{FooANode}} ;			B : C | ;			C : Comma ''c'';			Comma : "," ''comma'' {{FooCommaNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ',,'.	self assert: node separator comma value = ','.	self assert: node separator comma startPosition = 1.	self assert: (node nodeVariables includes: #separator).	self assert: node c comma value = ','.	self assert: node c comma startPosition = 2.	self deny: (self parserClass basicNew symbolTypes includes: #Object).	node := self parserClass parse: ','.	self assert: node separator isNil! !!SmaCCEndToEndTest methodsFor: 'public'!testRenamedVariable	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : Comma ''separator'' Comma {{FooANode}} ;			Comma : "," ''comma'' ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ',,'.	self assert: node separator value = ','.	self assert: node separator startPosition = 1.	self assert: (node tokenVariables includes: #separator).	self assert: node comma value = ','.	self assert: node comma startPosition = 2.	self deny: (self parserClass basicNew symbolTypes includes: #Object)! !!SmaCCEndToEndTest methodsFor: 'public'!testOptionalVariableType	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : Comma {{FooANode}} ;			Comma : "," ''comma'' |  ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert: self parserClass basicNew symbolTypes asSet asSortedCollection asArray = #(#FooANode #SmaCCErrorNode #SmaCCToken)! !!SmaCCEndToEndTest methodsFor: 'public'!testSingleVariableCollection	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; <patternToken> : (\`  [^\`]* \`)+ ; <integer> : \d+;			%root P; %glr; %prefix Foo; %suffix Node;			A : B {{}};			B : B C ''item'' | ; 			C : "#(" D ")" {{}};			D :  | D <integer> ''item''; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '#(1)#(2 3 4)'.	self assert: node items size = 2.	self assert: node items first items size = 1.	self assert: node items last items size = 3! !!SmaCCEndToEndTest methodsFor: 'public'!testVariableCollection	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; <patternToken> : (\`  [^\`]* \`)+ ; 			%root P; %glr; %prefix Foo; %suffix Node;			A : B {{}};			B : C | "d" ''d'';			C : "," ''comma''; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ','.	self assert: node comma startPosition = 1.	self assert: node d isNil.	node := self parserClass parse: 'd'.	self assert: node comma isNil.	self assert: node d startPosition = 1! !!SmaCCEndToEndTest methodsFor: 'public'!testTokenCollection	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; <patternToken> : (\`  [^\`]* \`)+ ; 			%root P; %glr; %prefix Foo; %suffix Node;			A : C B ''b'' C {{}};			B : C {{}};			C : "," ''comma''; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ',,,'.	self assert: node b comma startPosition = 2.	self assert: node commas first startPosition = 1.	self assert: node commas last startPosition = 3.	self assert: node commas size = 2! !!SmaCCEndToEndTest methodsFor: 'private'!setUpClasses	currentClasses := self classesInPackage! !!SmaCCEndToEndTest methodsFor: 'private'!lookupType: className	^ self class environment at: className! !!SmaCCEndToEndTest methodsFor: 'private'!parserClass	^ self lookupType: #TestParser! !!SmaCCEndToEndTest methodsFor: 'private'!checkTokensAreInOrder: tokenCollection	tokenCollection		inject: 0		into:			[ :sum :each | 			self assert: sum < each startPosition.			each startPosition ]! !!SmaCCEndToEndTest methodsFor: 'private'!classesInPackage	^ self package classes! !!SmaCCEndToEndTest methodsFor: 'private'!supportsUnicodeStrings	^ [ String with: (Character value: 16rFF00).	true ]		on: Error		do: [ :ex | ex return: false ]! !!SmaCCEndToEndTest methodsFor: 'private'!removeClass: aBehavior	aBehavior removeFromSystem! !!SmaCCEndToEndTest methodsFor: 'private'!removeNewClasses	| classesToRemove |	classesToRemove := self classesInPackage		reject: [ :each | currentClasses includes: each ].	(classesToRemove		asSortedCollection: [ :a :b | a allSuperclasses size > b allSuperclasses size ])		do: [ :each | self removeClass: each ]! !!SmaCCEndToEndTest methodsFor: 'private'!package	^ RPackageOrganizer default packageNamed: self class category! !!SmaCCEndToEndTest methodsFor: 'private'!scannerClass	^ self lookupType: #TestScanner! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testMatchCollection	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 2 3 4'.	self assert: (node match: node inContext: Dictionary new)! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testEmptyAlternative	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%root FooNode;			A : B ''component'' {{FooANode}} ;			B :  | C ; 			C : "c" ''c'' {{FooCNode}} ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'c'.	self assert: node class name asString = 'FooANode'.	self assert: node component c value = 'c'.	self assert: node component parent == node.	node := self parserClass parse: ''.	self assert: node component isNil! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testUnnamedSymbol	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' {{FooBNode}} ;'.	self		assert:			([ compiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do:					[ :ex | 					('Node creation' = ex messageText and: [ '*>>>B<<<*' match: ex tag ])						ifTrue: [ ex return: true ]						ifFalse: [ ex resume: nil ] ])! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testCopyCollection	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 2 3 4'.	self assert: (node copyInContext: Dictionary new) = node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testChildrenWhenNodeTypeNotSpecified	| compiler node values |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%root Program;			%prefix Test;			%suffix Node;			<id> : [a-zA-Z]+;			<num> : [0-9]+;			<whitespace> : [\s]+;			Start : Expr ";" ;			Expr : Term ''left'' "+" ''op''  Expr ''right''   {{Binary}}			     | Term ''left'' "-" ''op'' Expr ''right''        {{Binary}}			     | Term ;			Term : Factor ''left'' "*" ''op'' Term ''right'' {{Binary}}			     | Factor ''left'' "/" ''op'' Term ''right''       {{Binary}}			     | Factor ;			Factor : <num> ''value''                  {{Constant}}			        | <id> ''name'' "(" Expr ''argument'' ")"        {{Function}}			        | "(" Expr ")" ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 + 2;'.	self assert: node children size = 2.	values := #('1' '2') asSet.	node children do: [ :each | values remove: each value value ]! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testSimpleTree	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '2 + 3 - 4'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node class superclass name asString = 'FooParseNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testNodeClassName	| compiler pattern |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <name> : [a-z]+; <whitespace> : \s+; <patternToken> : (\`  [^\`]* \`)+ ; %glr;			%root FooNode;			A : Name | Number ;			Name : <name>''name'' {{FooNameNode}};			Number : <number> ''number'' {{FooNumberNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	pattern := self parserClass		parse: '`a{nodeClassName: #FooNumberNode}`'.	self		assert:			(pattern				match: (self parserClass parse: '123')				inContext: Dictionary new).	self		deny:			(pattern				match: (self parserClass parse: 'abc')				inContext: Dictionary new)! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testOptionalCollection	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B_opt {{FooANode}} ;			B_opt : B | ;			B : Number ''numberNode'' | B Number ''numberNode'' ;			Number : <number> ''number'' {{FooNumberNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 2 3 4'.	node numberNodes		keysAndValuesDo:			[ :key :each | 			self assert: key printString = each number value.			self assert: each parent == node ].	self assert: node numberNodes size = 4! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPassThrough	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B ''b'' {{FooANode}} ;			B : C ;			C : Number;			Number : <number> ''number'' {{FooNumberNode}}; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '12'.	self assert: node class name asString = 'FooANode'.	self assert: node b parent == node.	self assert: node b number startPosition = 1.	self assert: node b number value = '12'! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPullUpCollectionVariables	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : AList {{FooNode}} ;			AList : B | AList B;			B : <number> ''number'' ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 2 3 4'.	node numbers		keysAndValuesDo: [ :key :each | self assert: key printString = each value ].	self assert: node numbers size = 4! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testBadNode	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : B "a" ''a'' {{FooNode}} ;			B : A | C ;			C : "c" ''c''; '.	self		assert:			([ compiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do:					[ :ex | 					('Node creation' = ex messageText and: [ '*>>>A<<<*' match: ex tag ])						ifTrue: [ ex return: true ]						ifFalse: [ ex resume: nil ] ])! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testParseAllPattern	| compiler trees node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; <patternToken> : (\`  [^\`]* \`)+ ; 			%root FooNode; %glr;			A : "f:" ''f'' Z ''z'' {{FooANode}} | A "f:" ''f'' Z ''z'' {{FooANode}};			Z : B | C;			B : "b" ''b'' {{FooBNode}};			C : "c" ''c'' {{FooCNode}}; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	trees := self parserClass		parseAll: 'f: `a` f: `b`'		startingAt: self parserClass defaultStartingState.	self assert: trees size = 1.	node := trees first.	self assert: node fs size = 2.	trees := self parserClass		parseAll: 'f: `a{beToken}` f: `b{beToken}`'		startingAt: self parserClass defaultStartingState.	self assert: trees size = 4.	node := trees first.	self assert: node fs size = 2! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPullUpVariablesForLaterSymbols	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : "a" ''a'' B_opt {{FooNode}} ;			B_opt : B | ;			B : <number> ''number'' | B <number> ''number'' ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a 1 2 3 4'.	node numbers		keysAndValuesDo: [ :key :each | self assert: key printString = each value ].	self assert: node numbers size = 4.	node := self parserClass parse: 'a'.	self assert: node numbers isEmpty! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testOptionalComponent	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' | ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: ''.	self assert: node b isNil.	node := self parserClass parse: 'b'.	self assert: node b startPosition = 1! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testRightRecursive	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| Number ''number''  "," ''comma'' Foo {{Collection}} ;			Number : <number> ''token'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 , 2 , 3 , 4'.	self assert: node numbers size = 4.	node numbers		keysAndValuesDo:			[ :key :each | 			self assert: key printString = each token value.			self assert: each parent == node.			self assert: (node children includes: each) ].	self assert: node commas size = 3.	node commas		inject: 0		into:			[ :sum :each | 			self assert: sum < each startPosition.			each startPosition ].	node commas do: [ :each | self assert: each value = ',' ].	copy := node copy.	self assert: copy ~~ node.	self assert: copy numbers ~~ node numbers.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testName	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<name> : \w+; <whitespace> : \s+; 			%root FooNode;			A : name ''nameNode'' {{FooANode}} ;			name : simple | composite ;			simple : <name> ''name'' {{FooNameNode}};			composite : name ''base'' "." ''period'' <name> ''name'' {{FooFullNameNode}}; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a.b.c'.	self assert: node nameNode name value = 'c'.	self assert: node nameNode parent == node.	self assert: node nameNode base name value = 'b'.	self assert: node nameNode base parent == node nameNode.	self assert: node nameNode base base name value = 'a'.	self assert: node nameNode base base parent == node nameNode base! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPrefixSuffixWithDefaultClassName	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%root Test ; %prefix Foo; %suffix Node; 			test : "a" ''letter'' {{}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestNode'.	self assert: node class superclass = SmaCCParseNode.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testChildrenWhenNodeTypeNotSpecifiedAndCouldBeToken	| compiler node values |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%root Program;			%prefix Test;			%suffix Node;			<id> : [a-zA-Z]+;			<num> : [0-9]+;			<whitespace> : [\s]+;			Start : Expr ";" ;			Expr : Term ''left'' "+" ''op''  Expr ''right''   {{Binary}}			     | Term ''left'' "-" ''op'' Expr ''right''        {{Binary}}			     | Term ;			Term : Factor ''left'' "*" ''op'' Term ''right'' {{Binary}}			     | Factor ''left'' "/" ''op'' Term ''right''       {{Binary}}			     | Factor ;			Factor : <num> ''value''                  {{Constant}}			        | <id> ''name'' "(" Expr ''argument'' ")"        {{Function}}				  | "(" Q ")" ;			Q : Expr | <id> ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 + 2;'.	self assert: node children size = 2.	values := #('1' '2') asSet.	node children do: [ :each | values remove: each value value ]! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testChildrenVariables	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%hierarchy If (IfElse);			%left "+" "-" ;			If : "if" number ''a'' "then" number ''b'' {{If}}				| "if" number ''a'' "then" number ''b'' "else" number ''c'' {{IfElse}};			number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'if 1 then 2 else 3'.	self assert: node class name asString = 'FooIfElseNode'.	self assert: node children size = 3! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testSimpleNode	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%root FooNode ;			test : "a" ''letter'' {{FooNode}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooNode'.	self assert: node letter value = 'a'.	self assert: node letter startPosition = 1.	self assert: node letter stopPosition = 1.	self assert: node class superclass = SmaCCParseNode.	self assert: node copy ~~ node.	self assert: node copy letter ~~ node letter.	self assert: node = node copy.	self assert: node hash = node copy hash.	(self lookupType: #FooNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testLeftAndRightRecursive	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| "(" ''leftParen'' Foo ")" ''rightParen'' {{Collection}} ;			Number : <number> ''token'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '(((4)))'.	self assert: node leftParens size = 3.	self assert: node rightParens size = 3.	self assert: node number token value = '4'.	self checkTokensAreInOrder: node leftParens.	self checkTokensAreInOrder: node rightParens.	self assert: node children size = 1.	self assert: node children first == node number.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testAutoAnnotateTokens	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<name> : \w+; <whitespace> : \s+; 			%annotate_tokens;			%root FooNode;			A : "(" <name> "<<" "test" ")" {{FooANode}} ; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '( foo << test )'.	self assert: node nameToken value = 'foo'.	self assert: node leftParenToken value = '('.	self assert: node lessThanLessThanToken value = '<<'.	self assert: node testToken value = 'test'.	self assert: node rightParenToken value = ')'! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testNodeWithoutRoot	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler buildDefinition: 'test : "a" ''letter'' {{FooNode}};'.	self		should:			[ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser' ]		raise: SmaCCCompilationNotification! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testCollectionSuperclassWithImplicitPullUp	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| Number				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;			Number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self		assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testSimpleHierarchy	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			%hierarchy Binary (Plus Minus);			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Plus}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Minus}}				| <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '2 + 3 - 4'.	self assert: node class name asString = 'FooMinusNode'.	self assert: node operator value = '-'.	self assert: node class superclass name asString = 'FooBinaryNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node left class name asString = 'FooPlusNode'.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testUseWithoutClassDefinition	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : <number> ''left'' B ''operator'' <number> ''right'' {{FooNode}} ;			B : C ;			C : "+" | "-" | "*" | "/" ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 + 3'.	self assert: node operator value = '+'! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testMultipleComponents	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%root FooNode;			A : B C {{FooANode}} ;			B : "b" ''b'' ;			C : "c" ''c'';'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'bc'.	self assert: node class name asString = 'FooANode'.	self assert: node b startPosition = 1.	self assert: node c startPosition = 2! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testCollectionSuperclass	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| <number> ''number'' {{Number}}				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self		assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testDefaultClassNameWithUnderscore	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%root Test ; %prefix Foo; %suffix Node; 			test_class : "a" ''letter'' {{}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestClassNode'.	self assert: node class superclass name asString = 'FooTestNode'.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testNodeAndExpression	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'%root FooNode;			A : B "a" ''a'' {{FooNode}} ;			B : {Object new} ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a'.	self assert: node a value = 'a'! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPerformanceMatchCollection	| parserCompiler node match fastTime slowTime |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d; <whitespace> : \s+; 			<patternToken>: (\`  [^\`]* \`)+ ;			%glr;			%root Parse ; %prefix Foo; %suffix Node;			%left "+" "-" ;			ExpressionList : ExpressionList Expression ''expression'' {{ExpressionList}}  | Expression ''expression'' {{ExpressionList}};			Expression : Number ;			Number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: (String new: 1000 withAll: $1) , '22' , (String new: 1000 withAll: $1).	fastTime := Time millisecondsToRun: [ self assert: (node match: node inContext: Dictionary new) ].	match := [ self parserClass parse: '`a{beList}` 22 `b{beList}`' ]		on: SmaCCAmbiguousResultNotification		do: [ :ex | (ex tag collect: [ :each | each performOnSmaCCParser: ex parser ]) detect: [ :each | (each isKindOf: SmaCCPatternNode) not ] ifNone: [ ex tag first ] ].	slowTime := Time millisecondsToRun: [ self assert: (match match: node inContext: Dictionary new) ].	self assert: (fastTime max: 1) * 10 > slowTime! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testAttributesTokens	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	compiler		buildDefinition:			'<name> : \w+; <whitespace> : \s+; 			%annotate_tokens;			%root FooNode;			%attributes FooANode (a b);			A : "(" <name> "<<" "test" ")" {{FooANode}} ; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '( foo << test )'.	self assert: node a isNil.	node a: 1.	node b: 2.	self assert: node a = 1.	self assert: node b = 2! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testUnnamedCollectionSymbol	| compiler |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B {{FooANode}} ;			B : "b" ''b'' {{FooBNode}} | B "b" ''b'' {{FooBNode}} ;'.	self		assert:			([ compiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do:					[ :ex | 					('Node creation' = ex messageText and: [ '*>>>B<<<*' match: ex tag ])						ifTrue: [ ex return: true ]						ifFalse: [ ex resume: nil ] ])! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testMultipleTypes	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : B | C ;			B : "b" ''b'' D {{FooBNode}} ;			C : "c" ''c'' D {{FooCNode}};			D : Number ''number'' | D "," ''comma'' Number ''number'' ;			Number : <number> ''number'' {{FooNumberNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'b 1, 2, 3, 4'.	self assert: node class name asString = 'FooBNode'.	node numbers		keysAndValuesDo:			[ :key :each | 			self assert: key printString = each number value.			self assert: each parent == node ].	self assert: node numbers size = 4.	self assert: node commas size = 3! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testLeftRecursive	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Foo : Number ''number'' {{Collection}}				| Foo "," ''comma'' Number ''number'' {{Collection}} ;			Number : <number> ''token'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1 , 2 , 3 , 4'.	self assert: node numbers size = 4.	node numbers		keysAndValuesDo:			[ :key :each | 			self assert: key printString = each token value.			self assert: each parent == node.			self assert: (node children includes: each) ].	self assert: node commas size = 3.	node commas do: [ :each | self assert: each value = ',' ].	copy := node copy.	self assert: copy ~~ node.	self assert: copy numbers ~~ node numbers.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testCodeReturnType	| compiler parser |	(compiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	compiler		buildDefinition:			'<a> : a;			<b> : b;			<whitespace> : \s+;			%root FooNode;			File : A ''aNode'' B ''bNode'' C ''cNode'' {{FooNode}};			A : <a> {''1''};			B : <b> {^''1''};			C : "C" ''c'' {^c};			D : "D" {^''2''};			E : "E" {^[]};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	parser := self parserClass basicNew.	self assert: (parser symbolTypes at: (parser symbolNames indexOf: 'A')) = #SmaCCToken.	self assert: (parser symbolTypes at: (parser symbolNames indexOf: 'B')) = #SmaCCToken.	self assert: (parser symbolTypes at: (parser symbolNames indexOf: 'C')) = #SmaCCToken.	self assert: (parser symbolTypes at: (parser symbolNames indexOf: 'D')) = '' class name.	self assert: ([  ] class includesBehavior: (Smalltalk at: (parser symbolTypes at: (parser symbolNames indexOf: 'E'))))! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPrefixSuffix	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%root Test ; %prefix Foo; %suffix Node; 			test : "a" ''letter'' {{Test}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'a'.	self assert: node class name asString = 'FooTestNode'.	self assert: node class superclass = SmaCCParseNode.	(self lookupType: #FooTestNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testCollectionSuperclassWithCodeNode	| parserCompiler node copy |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; %hierarchy Expression (Number Binary); 			%left "+" "-" ;			Expression : Expression ''left'' "+" ''operator'' Expression ''right'' {{Binary}}				| Expression ''left'' "-" ''operator'' Expression ''right'' {{Binary}}				| Number {''1''}				| "(" ''leftParen'' Expression ")" ''rightParen'' {{Expression}} ;			Number : <number> ''number'' {{Number}} ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '(2 + 3 - (4))'.	self assert: node class name asString = 'FooBinaryNode'.	self assert: node operator value = '-'.	self assert: node leftParens size = 1.	self		assert: node class superclass name asString = 'FooExpressionNode'.	self assert: node right class name asString = 'FooNumberNode'.	self assert: node right leftParens size = 1.	self assert: node right parent == node.	self assert: node left parent == node.	self assert: node parent isNil.	self assert: node children size = 2.	self assert: (node children includes: node left).	self assert: (node children includes: node right).	self assert: node right number value = '4'.	self assert: node left operator value = '+'.	self assert: node left left number value = '2'.	self assert: node left right number value = '3'.	copy := node copy.	self assert: copy ~~ node.	self assert: copy left ~~ node left.	self assert: copy right ~~ node right.	self assert: copy operator ~~ node operator.	self assert: copy = node.	self assert: copy hash = node hash.	(self lookupType: #FooParseNodeVisitor) new acceptNode: node! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testNamedSubComponent	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : {{FooANode}} | "a" ''a'' A ''sub'' {{FooANode}} ;'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'aaa'.	self assert: node class name asString = 'FooANode'.	self assert: node a startPosition = 1.	self assert: node sub a startPosition = 2.	self assert: node sub parent == node.	self assert: node sub sub a startPosition = 3.	self assert: node sub sub parent == node sub.	self assert: node sub sub sub a isNil.	self assert: node sub sub sub parent == node sub sub.	self assert: node sub sub sub sub isNil! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testNonRecursiveVariableInsideRecursiveProduction	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<whitespace> : \s+; 			%root FooNode;			A : B "a" ''letter'' {{FooNode}} ;			B : A | C ;			C : "c" ''c'' {{FooNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: 'c a a a'.	self assert: node c value = 'c'.	self assert: node letters size = 3! !!SmaCCEndToEndTest methodsFor: 'tests-parse tree creation'!testPullUpMultipleTypes	| compiler node |	(compiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	compiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root FooNode;			A : D B {{FooBNode}} | D C {{FooCNode}};			B : "b" ''b'' D ;			C : "c" ''c'' D ;			D : Number ''number'' | D Number ''number'' ;			Number : <number> ''number'' {{FooNumberNode}};'.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '0 b 1 2 3 4'.	self assert: node class name asString = 'FooBNode'.	node numbers		keysAndValuesDo:			[ :key :each | 			self assert: (key - 1) printString = each number value.			self assert: each parent == node ].	self assert: node numbers size = 5! !!SmaCCEndToEndTest methodsFor: 'tests'!testRepeat	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<letters> : [a-zA-Z];			<test> : (\`[^\`]*\`)+;			All : | All Test ;			Test : <letters> | <test> ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: '`a`b`c`') size = 3! !!SmaCCEndToEndTest methodsFor: 'tests'!testComments	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : /* q */ /***/ /****/ a # b 				;			/* */ /***/ /****/			#this is a comment			begin : <a> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'a')! !!SmaCCEndToEndTest methodsFor: 'tests'!testScannerScopes	| parserCompiler parser |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%scopes a ;			<foo> : b;			a <bar> : a;			Start : <foo> {true} | <bar> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'b').	self should: [ self parserClass parse: 'a' ] raise: SmaCCParserError.	parser := self parserClass on: (ReadStream on: 'a').	parser scope: #a.	self deny: parser parse.	parser := self parserClass on: (ReadStream on: 'b').	parser scope: #a.	self assert: parser parse! !!SmaCCEndToEndTest methodsFor: 'tests'!testReduceRules	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<char> : [a-zA-Z] ; 			<ws> : \s ;			Start ::= Chars {#liftFirstValue:};			Chars : WS A WS {#liftSecondValue:};			A : WS WS C {#liftLastValue:} | C WS {#liftLastValue:};			WS : <ws> {#nil};			C : <char> {#stringValue:};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: ' a  ') isNil.	self assert: (self parserClass parse: '   a ') = 'a'! !!SmaCCEndToEndTest methodsFor: 'tests'!expressionScannerString	^ '<number>	:	[0-9]+ (\. [0-9]+) ? ;<whitespace>	:	\s+;'! !!SmaCCEndToEndTest methodsFor: 'tests'!testNonAssociativeTokens	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<IDENTIFIER> : \w+ ; <whitespace> : \s+ ;			%left "and" ;			%nonassoc "=" "<=";			%left "+" ;			expr : expr "=" expr {true} | expr "<=" expr {true} | expr "and" expr {true} | expr "+" expr {true} | <IDENTIFIER> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		should: [ self parserClass parse: 'a=b=c' ]		raise: SmaCCParserError.	self		should: [ self parserClass parse: 'a=b<=c' ]		raise: SmaCCParserError.	self		should: [ self parserClass parse: 'a=b+c=d' ]		raise: SmaCCParserError.	self assert: (self parserClass parse: 'a=b and c=d')! !!SmaCCEndToEndTest methodsFor: 'tests'!testBadCharacterBlock	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	self		should:			[ parserCompiler				buildDefinition:					'<foo> : [a-] ;					Start : <foo>;'.			parserCompiler compileInto: 'TestScanner' andParser: 'TestParser' ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testSimple	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : a ;			begin : <a> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self should: [ self parserClass parse: '2' ] raise: SmaCCParserError.	self assert: (self parserClass parse: 'a')! !!SmaCCEndToEndTest methodsFor: 'tests'!testOutOfOrderTokens	| parserCompiler result |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : a <c>;			<b> : b;			<c> : <b> c;			Start ::= <a> {''1''};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	result := self parserClass parse: 'abc'.	self assert: result source = 'abc'! !!SmaCCEndToEndTest methodsFor: 'tests'!testErrorToken	| parserCompiler countingBlock |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<name> : [a-zA-Z]+; <whitespace>: \s+;			%left "+"; Expression : <name> | Expression "+" Expression {[Notification signal] on: Error do: [:ex | ex return: (Notification raise)]} | error "+" Expression ;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	countingBlock := [ :string | 	| count |	count := 0.	[ [ self parserClass parseWithErrors: string ]		on: Notification		do:			[ :ex | 			count := count + 1.			[ ex resume ]				on: Error				do: [ :ex1 | 					ex isResumable: true.					ex1 retry ] ] ]		on: SmaCCParserError		do: [ :ex | ex return ].	count ].	#(#('a + b + c' 2) #('+ a + b + c' 2) #('a + b +' 1) #('a + 1 / 2 + b + c + 3' 2) #('1 + 1 / 2 + b + c + 3' 1))		do: [ :each | self assert: (countingBlock value: each first) = each last ]! !!SmaCCEndToEndTest methodsFor: 'tests'!expressionParserString	^ '%left "+" "-" ;%left "*" "/" ;%right "^" ;Expression: Expression ''first'' "+" Expression ''last'' {first + last}	| Expression "-" Expression {''1'' - ''3''}	| Expression "*" Expression {''1'' * ''3''}	| Expression "/" Expression {''1'' / ''3''}	| Expression "^" Expression {''1'' raisedTo: ''3''} 	| "(" Expression ")" {''2''}	| <number> {''1'' value asNumber};'! !!SmaCCEndToEndTest methodsFor: 'tests'!testBadSmalltalkBlock	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	self		should:			[ parserCompiler				buildDefinition:					'<foo> : foo ;					Start : <foo> {self printOn: };'.			parserCompiler compileInto: 'TestScanner' andParser: 'TestParser' ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testImmediateExecution	| parserCompiler notification |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<int> : \d+; <whitespace>: \s+;			%glr;			Test : A <int> <int> { ''1'' } | B <int> {self error: ''Should not occur''};			A : { true };			B : [ Notification signal: ''B'' ];			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	[ self assert: (self parserClass parse: '1 2') ]		on: Notification		do: [ :ex | 			notification := ex messageText.			ex resume ].	self assert: notification = 'B'! !!SmaCCEndToEndTest methodsFor: 'tests'!testImplicitTokenPrecedence	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : . ;			A : <a> {true} | <isLetter> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	0 to: 255 do:		[ :each | 		self			assert: (self parserClass parse: (String with: (Character value: each))) ]! !!SmaCCEndToEndTest methodsFor: 'tests'!testIgnoreCaseKeywords	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<identifier> : [a-z_]+ ; <whitespace> : \s+ ;			Start ::= "Foo" {true} | <identifier> <identifier> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'FOo').	self deny: (self parserClass parse: 'FoObAr ASDS')! !!SmaCCEndToEndTest methodsFor: 'tests'!testInvertedCharactersBlock	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<A> : a{1,3} ;			<ID> : [^a]+ ;			<comment> : \s+ ;			begin : {0} | begin <A> {''1'' + 1} | begin <ID> {''1'' - 1};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'aa') = 1.	self assert: (self parserClass parse: 'aaaa') = 2.	self assert: (self parserClass parse: 'a bab') = 0! !!SmaCCEndToEndTest methodsFor: 'tests'!testAmbiguousResults	| parserCompiler results result |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<int> : \d+; <whitespace>: \s+;			%glr;			Expression : Expression "+" Expression {''1'' + ''3''}				| Expression "*" Expression {''1'' * ''3''}				| <int> {''1'' value asNumber};			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass compile: 'alwaysPerformReduceAction ^true'.	self assert: (self parserClass parse: '3 + 4') = 7.	self assert: (self parserClass parse: '3 * 4') = 12.	[ result := self parserClass parse: '2 + 3 * 4' ]		on: SmaCCAmbiguousResultNotification		do:			[ :ex | 			results := ex tag				collect: [ :each | each performOnSmaCCParser: ex parser ].			ex resume: 0 ].	self assert: result = 0.	self assert: results size = 2.	self assert: (results includes: 20).	self assert: (results includes: 14).	"There are a bunch of ways to parse the following expression. If we don't merge the possibilities, then this will never complete."	self		assert:			(self parserClass				parse:					'1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1+1')				= 60! !!SmaCCEndToEndTest methodsFor: 'tests'!testKeywords	| parserCompiler size definition |	definition := '%ignorecase;			Start ::= "Foo" "bar";'.	size := SmaCCGrammar maximumCharacterValue.	self supportsUnicodeStrings		ifTrue: [ definition := '%unicode; ' , definition ].	[ (parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler buildDefinition: definition.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass parse: 'FoObAr' ]		ensure: [ SmaCCGrammar maximumCharacterValue: size ]! !!SmaCCEndToEndTest methodsFor: 'tests'!testSpecialCharacters	| parserCompiler maxValue |	[ String with: (Character value: 16rFF00) ]		on: Error		do: [ :ex | ^ self ].	"Unicode characters not supported"	maxValue := SmaCCGrammar maximumCharacterValue.	[ (parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%unicode;			%ignorecase;			<name> : \x3g \x20 \xFF \xFF1 \xFF00 \cC;			begin ::= <name> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert:			(self parserClass				parse:					(String						withAll:							(#(3 103 16r20 16rFF 16rFF1 16rFF00 2)								collect: [ :each | Character value: each ]))) ]		ensure: [ SmaCCGrammar maximumCharacterValue: maxValue ]! !!SmaCCEndToEndTest methodsFor: 'tests'!testPreferredReduction	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%glr;			Test : {1} | Test A {''1'' * ''2''} | Test B {''1'' * ''2''};			A : "a" {1};			B : "a" {2};			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert: (self parserClass parse: (String new: 100 withAll: $a))		equals: 1! !!SmaCCEndToEndTest methodsFor: 'tests'!testExcludeScannerState	| parserCompiler parser |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%excludes a;			<foo> : b;			a <bar> : a;			Start : <foo> {true} | <bar> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'b').	self should: [ self parserClass parse: 'a' ] raise: SmaCCParserError.	parser := self parserClass on: (ReadStream on: 'a').	parser scope: #a.	self deny: parser parse.	parser := self parserClass on: (ReadStream on: 'b').	parser scope: #a.	self should: [ parser parse ] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testReduceActionReuse	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : a ;			begin : <a> {#()};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert:			(self parserClass selectors				anySatisfy: [ :each | each beginsWith: 'reduceActionFor' ])! !!SmaCCEndToEndTest methodsFor: 'tests'!testHierarchy	| parserCompiler |	SmaCCScanner		subclass: #FooScanner		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(Smalltalk at: #FooScanner)		subclass: #TestScanner		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	SmaCCParser		subclass: #FooParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(Smalltalk at: #FooParser)		subclass: #TestParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert: self scannerClass superclass name asString = 'FooScanner'.	self assert: self parserClass superclass name asString = 'FooParser'! !!SmaCCEndToEndTest methodsFor: 'tests'!testNFAtoDFAConversion	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<Characterliteral>				: <Cchar>+				;			<Cchar>				: [^\''\\\r\n]				| <Hexadecimalescapesequence>				;			<Hexadecimalescapesequence>				: \\x [0-9a-fA-F]+				;			<Userdefinedcharacterliteral>				: <Characterliteral> 				;			Start : <Characterliteral> { true } | <Userdefinedcharacterliteral> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'abcde\xffee3sdas').	self should: [ self parserClass parse: '''' ] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testCrLf	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : \r? \n | \r ;			A : <a> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert:			(self parserClass				parse: (String with: Character cr with: Character lf)).	self		should:			[ self parserClass				parse: (String with: Character cr with: Character cr) ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testOverlappingTokens	| parserCompiler result |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<id1> : \w+; <id2> : \w+;			%glr;			Test : "keyword" {''1''} | <id1> {''1''} | <id2> {''1''} ;			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	result := self parserClass parse: 'keyword'.	self assert: result ids size = 3! !!SmaCCEndToEndTest methodsFor: 'tests'!testNextToken	| compiler tokens |	(compiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	compiler		buildDefinition:			'<next> : next; <whitespace> : \s+; 			Next : <next>; '.	compiler compileInto: 'TestScanner' andParser: 'TestParser'.	tokens := self parserClass parse: ' next '.	self assert: tokens first value = 'next'! !!SmaCCEndToEndTest methodsFor: 'tests'!testRepeatingCharactersBlock	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<A> : a{1,3} ;			<ID> : \w+ ;			<whitespace> : \s+ ;			begin : {true} | begin <A> {''1''} | begin <ID> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'aa').	self deny: (self parserClass parse: 'aaaa')! !!SmaCCEndToEndTest methodsFor: 'tests'!testReuseSimpleToken	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<LETTER> : [a-zA-Z_\\] ;			<DIGIT> : [0-9] ;			<IDENTIFIER>: <LETTER> (<LETTER>|<DIGIT>)*	;			<whitespace>: \s+	;			begin : <IDENTIFIER> begin {false} | <IDENTIFIER> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self should: [ self parserClass parse: '2' ] raise: SmaCCParserError.	self assert: (self parserClass parse: '\')! !!SmaCCEndToEndTest methodsFor: 'tests'!testAmbiguousResultWithDifferentScannerTokens	| parserCompiler results result |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%id <a> <aa>;			<a> : a ; <aa> : aa;			%glr;			List : Item {''1''} | List Item {''1'' + ''2''} ;			Item : <a> {1} | <aa> {1.5};			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass compile: 'alwaysPerformReduceAction ^true'.	self parserClass		compile:			'actionsForCurrentToken 		| oldToken oldPosition |		(currentToken ids includes: scanner aaId) ifTrue: [			oldToken := currentToken.			oldPosition := scanner position.			self position: currentToken stopPosition - 1.			currentToken := currentToken class value: ''a'' start: currentToken startPosition ids: (Array with: scanner aId).			super actionsForCurrentToken do: [:each | self splitWithAction: each].			currentToken := oldToken.			self position: oldPosition.		].		^super actionsForCurrentToken'.	self assert: (self parserClass parse: 'a') = 1.	[ result := self parserClass parse: 'aa' ]		on: SmaCCAmbiguousResultNotification		do:			[ :ex | 			results := ex tag				collect: [ :each | each performOnSmaCCParser: ex parser ].			ex resume: 0 ].	self assert: result = 0.	self assert: results size = 2.	self assert: (results includes: 2).	self assert: (results includes: 1.5)! !!SmaCCEndToEndTest methodsFor: 'tests'!testTimesRepeatRewriteBug	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler buildDefinition: '<a> : <<[^>]+>>; t : <a> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: '<<aa>>')! !!SmaCCEndToEndTest methodsFor: 'tests'!testGLRHierarchy	| parserCompiler |	SmaCCGLRParser		subclass: #FooParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(Smalltalk at: #FooParser)		subclass: #TestParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase; %glr;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: self parserClass superclass name asString = 'FooParser'! !!SmaCCEndToEndTest methodsFor: 'tests'!testImplicitScannerTokens	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<a> : <isLetter> + ;			A : <a> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'asdfssdafADSFS').	self		should: [ self parserClass parse: ' asdf asdf' ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testKeywordsWithStates	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%states default keyword;			keyword <word> : word;			keyword default <chars> : [a-z]+;			Start : <chars>;			other : <word>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass parse: 'word'! !!SmaCCEndToEndTest methodsFor: 'tests'!testReuseCompositeToken	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<LETTERDIGIT> : [a-zA-Z_] \d ;			<AAorBB> :  aa | bb;			<IDENTIFIER>: <LETTERDIGIT> | <AAorBB>	;			<whitespace>: \s+	;			begin : <IDENTIFIER> begin {false} | <IDENTIFIER> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self should: [ self parserClass parse: '2' ] raise: SmaCCParserError.	self assert: (self parserClass parse: 'aa').	self assert: (self parserClass parse: 'bb').	self assert: (self parserClass parse: 'a4').	self should: [ self parserClass parse: 'ab' ] raise: SmaCCParserError.	self should: [ self parserClass parse: '4b' ] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testIgnoreCaseWithMultipleKeywordCases	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<whitespace> : \s+ ;			Start ::= "if" "If" "iF" "IF" {true}; '.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'IF IF IF IF').	self assert: (self parserClass parse: 'iF If IF If')! !!SmaCCEndToEndTest methodsFor: 'tests'!testUnusedSymbols	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<letters> : \w+ ;			<whitespace>: \s+	;			%start Bar;			begin : Foo;			Foo :  <letters>;			Bar : Baz ;			Baz : "test" ;'.	self		assert:			([ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			true ]				on: SmaCCCompilationNotification				do: [ :ex | ex return: false ]).	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<letters> : \w+ ;			<whitespace>: \s+	;			begin : Foo;			Foo :  <letters>;			Bar : Baz ;			Baz : "test" ;'.	self		assert:			([ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do: [ :ex | ex return: true ])! !!SmaCCEndToEndTest methodsFor: 'tests'!testMoveToGLRHierarchy	| parserCompiler |	SmaCCParser		subclass: #FooParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(Smalltalk at: #FooParser)		subclass: #TestParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase; %glr;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert: self parserClass superclass name asString = 'SmaCCGLRParser'! !!SmaCCEndToEndTest methodsFor: 'tests'!testExistingVariables	| parserCompiler |	SmaCCScanner		subclass: #TestScanner		instanceVariableNames: 'scanner1 scanner2'		classVariableNames: ''		category: 'SmaCC_Tests'.	SmaCCParser		subclass: #TestParser		instanceVariableNames: 'parser1 parser2'		classVariableNames: ''		category: 'SmaCC_Tests'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self scannerClass instVarNames includes: 'scanner1').	self assert: (self scannerClass instVarNames includes: 'scanner2').	self assert: (self parserClass instVarNames includes: 'parser1').	self assert: (self parserClass instVarNames includes: 'parser2')! !!SmaCCEndToEndTest methodsFor: 'tests'!testIgnoreCaseTokens	| parserCompiler result |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<whitespace> : \s+ ;			Start ::= "a" "a" {Array with: ''1'' with: ''2''};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	result := self parserClass parse: 'a A'.	self assert: result first = result last.	self assert: result first hash = result last hash! !!SmaCCEndToEndTest methodsFor: 'tests'!testPriority	| parserCompiler |	SmaCCScanner		subclass: #TestScanner		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(self lookupType: #TestScanner)		compile: 'all ^self recordAndReportMatch: (Array with: self _allId)'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: '{').	self assert: (self parserClass parse: '<%').	self deny: (self parserClass parse: '}')! !!SmaCCEndToEndTest methodsFor: 'tests'!testRecursiveRule	#(#LR1 #LALR1)		do:			[ :each | 			| parserCompiler |			(parserCompiler := SmaCCGrammarCompiler new) codeGenerator				defaultCategory: self class category.			parserCompiler grammar type: each.			parserCompiler				buildDefinition:					self expressionScannerString						,							'Test: Test1 Recursive;							Test1: <number> {''1'' value};							Recursive: | Recursive "|" <number> {''1'' add: ''3'' value; yourself};'.			parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			self				assert:					((parserCompiler grammar nonTerminalSymbolNamed: 'Recursive')						firstTerminals						includes: (parserCompiler grammar keywordTerminalNamed: '"|"')).			self				assert:					(self parserClass parse: '2|3|4') asOrderedCollection						= (OrderedCollection with: '2' with: '3' with: '4') ]! !!SmaCCEndToEndTest methodsFor: 'tests'!testReduceReduceConflict	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<letter> : \w ;			<whitespace>: \s+	;			begin : Foo <letter> {true} | Bar <letter> {false};			Foo :  ;			Bar : ;'.	self		assert:			([ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do:					[ :ex | 					('*Reduce/Reduce*' match: ex messageText)						ifTrue: [ ex return: true ]						ifFalse: [ ex resume: nil ] ])! !!SmaCCEndToEndTest methodsFor: 'tests'!testExpressions	#(#LR1 #LALR1)		do:			[ :each | 			| parserCompiler |			(parserCompiler := SmaCCGrammarCompiler new) codeGenerator				defaultCategory: self class category.			parserCompiler grammar type: each.			parserCompiler				buildDefinition: self expressionScannerString , self expressionParserString.			parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			self				assert:					(self parserClass parse: '2 + 3 * 4 / 5 ^ 3 ^ 2')						= (2 + (3 * 4 / (5 raisedTo: (3 raisedTo: 2)))).			self				assert:					(self parserClass parse: '1.0*2/3+4.0^2^3+3')						= (1.0 * 2 / 3 + (4.0 raisedTo: (2 raisedTo: 3)) + 3).			self				assert:					(self parserClass parse: '(((1 + 2) * 3) ^ 2) ^ 3')						= (((1 + 2) * 3 raisedTo: 2) raisedTo: 3) ]! !!SmaCCEndToEndTest methodsFor: 'tests'!testMultipleStartingPositions	| parserCompiler position |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<name> : \w+;			%start plus ;			multiply: plus "*" plus {true};			plus: <name> {false} | <name> "+" <name> {false};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'a*a').	self assert: (self parserClass parse: 'a+a*a').	self		should: [ self parserClass parse: 'a+a' ]		raise: SmaCCParserError.	self		deny:			(self parserClass				parse: 'a+a'				startingAt: self parserClass startingStateForplus).	self parserClass		parse: 'a*a'		startingAt: self parserClass startingStateForplus		onError: [ :str :pos | position := pos ].	self assert: position = 2! !!SmaCCEndToEndTest methodsFor: 'tests'!testAmbiguousReduceReduceConflict	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'<int> : \d+; <whitespace>: \s+;			%glr;			Expression : Left "!!" "<" {''1''} | Right "!!" ">" {''1''} ;			Left : <int> "+" <int> "*" <int> {''1'' value asNumber + ''3'' value asNumber * ''5'' value asNumber};			Right : <int> "+" <int> "*" <int> {''1'' value asNumber + (''3'' value asNumber * ''5'' value asNumber)};			'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: '2 + 3 * 4!!<') = 20.	self assert: (self parserClass parse: '2 + 3 * 4!!>') = 14.	self		should: [ self parserClass parse: '2 + 3 * 4!!!!' ]		raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests'!testErrors	| parserCompiler position |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition: self expressionScannerString , self expressionParserString.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass		parse: '+3*4'		onError: [ :str :pos | position := pos ].	self assert: position = 1.	self parserClass		parseStream: (ReadStream on: '1+a+4')		onError: [ :str :pos | position := pos ].	self assert: position = 3! !!SmaCCEndToEndTest methodsFor: 'tests'!testMoveFromGLRHierarchy	| parserCompiler |	SmaCCGLRParser		subclass: #FooParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(Smalltalk at: #FooParser)		subclass: #TestParser		instanceVariableNames: ''		classVariableNames: ''		category: 'SmaCC_Tests'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler		buildDefinition:			'%ignorecase;			<a> : \{ | \< \% ;			<all> : .;			%id <_all> <a> <all>;  			begin : A {true}					| All {false};			A : <a> ;			All: <_all>;'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self		assert: self parserClass superclass name asString = 'SmaCCParser'! !!SmaCCEndToEndTest methodsFor: 'tests'!testLR1	| parserCompiler definitionString |	definitionString := 'S : a E c { 1 }    | a F d { 2 }    | b F c { 3 }    | b E d { 4 };E : e ;F : e ;a : "a";b : "b";c : "c";d : "d";e : "e";'.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler buildDefinition: '%lr1; ' , definitionString.	self		assert:			([ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			true ]				on: SmaCCCompilationNotification				do: [ :ex | ex return: false ]).	self assert: (self parserClass parse: 'aec') = 1.	self assert: (self parserClass parse: 'aed') = 2.	self assert: (self parserClass parse: 'bec') = 3.	self assert: (self parserClass parse: 'bed') = 4.	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler buildDefinition: definitionString.	self		assert:			([ parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.			false ]				on: SmaCCCompilationNotification				do: [ :ex | ex return: true ])! !!SmaCCEndToEndTest methodsFor: 'tests'!testImplicitParserTokens	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator		defaultCategory: self class category.	parserCompiler buildDefinition: 'A : <isLetter> {true};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self assert: (self parserClass parse: 'a').	self should: [ self parserClass parse: ' ' ] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testQuestion	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Numbers : <number> ''number'' ( "," ''comma'' <number> ''number'' )? {{Parse}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1,2'.	self assert: node class name asString = 'FooParseNode'.	self assert: node numbers size = 2.	self assert: node comma notNil.	node := self parserClass parse: '1'.	self assert: node numbers size = 1.	self assert: node comma isNil.	self should: [ self parserClass parse: '1,2,3' ] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testAlternatives	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Numbers : <number> ''left'' ( "+" ''op'' | "*" ''op'') <number> ''right'' {{Parse}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1+2'.	self assert: node class name asString = 'FooParseNode'.	self assert: node op value = '+'.	node := self parserClass parse: '1*2'.	self assert: node op value = '*'! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testAlternativePrecendence	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%left "+";			%left "*";			%root Parse ; %prefix Foo; %suffix Node; 			Expression : <number> ''value'' {{Number}} 				| Expression ''left'' ( "+" ''op'' | "*" ''op'') Expression ''right'' {{Binary}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1+2*3'.	self assert: node op value = '+'.	self assert: node right op value = '*'.	node := self parserClass parse: '1*2+3'.	self assert: node op value = '+'.	self assert: node left op value = '*'! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testQuestionPrecedence	| parserCompiler |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'%root Parse ; %prefix Foo; %suffix Node; %annotate_tokens;			A : "a"? ("." "a"?)? "." "."{{}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	self parserClass parse: '..'.	self parserClass parse: '...'.	self parserClass parse: 'a..'.	self parserClass parse: '.a..'.	self parserClass parse: 'a...'.	self parserClass parse: 'a.a..'! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testPlus	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Numbers : <number> ''number'' ( "," ''comma'' <number> ''number'' )+ {{Parse}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1,2,3,4,5,6'.	self assert: node class name asString = 'FooParseNode'.	self assert: node numbers size = 6.	self assert: node commas size = 5.	self should: [self parserClass parse: '1'] raise: SmaCCParserError! !!SmaCCEndToEndTest methodsFor: 'tests-extended syntax'!testStar	| parserCompiler node |	(parserCompiler := SmaCCGrammarCompiler new) codeGenerator defaultCategory: self class category.	parserCompiler		buildDefinition:			'<number> : \d+; <whitespace> : \s+; 			%root Parse ; %prefix Foo; %suffix Node; 			Numbers : <number> ''number'' ( "," ''comma'' <number> ''number'' )* {{Parse}};'.	parserCompiler compileInto: 'TestScanner' andParser: 'TestParser'.	node := self parserClass parse: '1,2,3,4,5,6'.	self assert: node class name asString = 'FooParseNode'.	self assert: node numbers size = 6.	self assert: node commas size = 5.	node := self parserClass parse: '1'.	self assert: node numbers size = 1.	self assert: node commas isEmpty! !SmaCCBitCollectionTest subclass: #SmaCCIntegerSetTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!SmaCCIntegerSetTest methodsFor: 'tests'!testNegative	| collection |	collection := self newCollection.	collection add: 1.	collection add: -1.	collection add: -100000.	self assert: collection size = 3.	self assert: (collection includes: 1).	self assert: (collection includes: -1).	self assert: (collection includes: -100000).	self deny: (collection includes: 0)! !!SmaCCIntegerSetTest methodsFor: 'tests'!testMergeBug	| a b |	a := SmaCCIntegerSet with: 1.	b := SmaCCIntegerSet with: 12000.	a addAll: b.	b		add: 12001;		add: 11999.	self assert: a size = 2! !TestCase subclass: #SmaCCStringTest	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Tests'!!SmaCCStringTest methodsFor: 'tests'!testDeleteAll	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 1 to: 4.	self assert: string asString = ''! !!SmaCCStringTest methodsFor: 'tests'!testDeleteAcrossInsert	| string |	string := SmaCCString on: '1233345'.	string insert: '234' at: 5.	string deleteFrom: 4 to: 5.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testInsertInMiddle	| string |	string := SmaCCString on: '1245'.	string insert: '3' at: 3.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testInsertOnEmptyString	| string |	string := SmaCCString on: ''.	string insert: '123456' at: 1.	self assert: string asString = '123456'! !!SmaCCStringTest methodsFor: 'tests'!testMultipleDeleteWhitespaceBefore	| string |	string := SmaCCString on: '0 asdf 9'.	3 to: 6 do:		[ :i | 		string			deleteWhitespaceBeforeIndex: i;			deleteCharacter: i ].	self assert: '0 9' = string asString! !!SmaCCStringTest methodsFor: 'tests'!testDeleteFirst	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 1 to: 1.	self assert: string asString = 'sdf'! !!SmaCCStringTest methodsFor: 'tests'!testDeleteWhitespaceBeforeAfter	| string |	string := SmaCCString on: '0 asdf 9'.	string deleteWhitespaceBeforeIndex: 4.	self assert: string asString = '0 asdf 9'.	string deleteWhitespaceAfterIndex: 4.	self assert: string asString = '0 asdf 9'.	string deleteWhitespaceBeforeIndex: 3.	self assert: string asString = '0asdf 9'.	string deleteWhitespaceAfterIndex: 6.	self assert: string asString = '0asdf9'! !!SmaCCStringTest methodsFor: 'tests'!testMoveBefore	| string |	string := SmaCCString on: '123456'.	string moveFrom: 4 to: 6 before: 3.	self assert: string asString = '124563'.	string deleteFrom: 5 to: 5.	self assert: string asString = '12463'.	string := SmaCCString on: '123456'.	string moveFrom: 4 to: 6 before: 1.	self assert: string asString = '456123'! !!SmaCCStringTest methodsFor: 'tests'!testMoveAfter	| string |	string := SmaCCString on: '123456'.	string moveFrom: 1 to: 2 after: 3.	self assert: string asString = '312456'.	string deleteFrom: 1 to: 4.	self assert: string asString = '356'.	string := SmaCCString on: '123456'.	string moveFrom: 1 to: 3 after: 6.	self assert: string asString = '456123'! !!SmaCCStringTest methodsFor: 'tests'!testMultipleInserts	| string |	string := SmaCCString on: '125'.	string insert: '3' at: 3.	string insert: '4' at: 3.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testInsertWhitespace	| string |	string := SmaCCString		on:			'1' , (String with: Character cr with: Character lf) , '2'				, (String with: Character cr) , '3' , (String with: Character lf)				, '4' , (String with: Character lf) , (String with: Character cr)				, '5' , (String with: Character lf).	string addNewLineWhitespace: ' ' from: 1 to: string size.	self		assert:			string asString				=					('1' , (String with: Character cr with: Character lf) , ' 2'						, (String with: Character cr) , ' 3'						, (String with: Character lf) , ' 4'						, (String with: Character lf) , ' '						, (String with: Character cr) , ' 5'						, (String with: Character lf) , ' ')! !!SmaCCStringTest methodsFor: 'tests'!testCombiningDeletedIntervals	| string intervalCount current |	string := SmaCCString on: '12345'.	#(3 2 4) do: [ :each | string deleteCharacter: each ].	self assert: string asString = '15'.	intervalCount := 0.	current := (string instVarNamed: 'firstSentinel') next.	[ current isSentinel ]		whileFalse: [ intervalCount := intervalCount + 1.			current := current next ].	self assert: intervalCount = 3! !!SmaCCStringTest methodsFor: 'tests'!testMultipleDeleteWhitespaceAfter	| string |	string := SmaCCString on: '0 asdf 9'.	6 to: 3 by: -1 do:		[ :i | 		string			deleteWhitespaceAfterIndex: i;			deleteCharacter: i ].	self assert: '0 9' = string asString! !!SmaCCStringTest methodsFor: 'tests'!testMultipleDeleteAll	| string |	string := SmaCCString on: 'asdf'.	#(1 3 4 2) do: [ :each | string deleteCharacter: each ].	self assert: string asString = ''! !!SmaCCStringTest methodsFor: 'tests'!testNoEdits	| string |	string := SmaCCString on: 'asdf'.	self assert: string asString = 'asdf'! !!SmaCCStringTest methodsFor: 'tests'!testDoubleInsertInMiddle	| string index |	string := SmaCCString on: '15'.	index := string insert: '24' at: 2.	string insert: '3' at: index + 1.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testMultipleInsertsAndDeletes	| string indices last |	string := SmaCCString on: ''.	last := 0.	indices := (1 to: 5)		collect: [ :each | last := string insert: each printString , 'X' at: last + 1 ].	string deleteFrom: last + 1 to: indices first + 1.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testDeleteUpTo	| string |	string := SmaCCString on: '123456'.	#(1 3) do: [ :each | string deleteCharacter: each ].	string deleteUpTo: 5.	self assert: string asString = '56'! !!SmaCCStringTest methodsFor: 'tests'!testDeleteAcrossInserts	| string startIndex stopIndex |	string := SmaCCString on: '16'.	startIndex := string insert: '233' at: 2.	stopIndex := string insert: '445' at: 2.	string insert: 'asdf' at: stopIndex.	string deleteFrom: startIndex + 2 to: stopIndex.	self assert: string asString = '123456'! !!SmaCCStringTest methodsFor: 'tests'!testDeleteLast	| string |	string := SmaCCString on: 'asdf'.	string deleteFrom: 4 to: 4.	self assert: string asString = 'asd'! !!SmaCCStringTest methodsFor: 'tests'!testCopyFromTo	| string |	string := SmaCCString on: '1245'.	string insert: '3' at: 3.	self assert: (string copyFrom: 2 to: 3) asString = '234'! !!SmaCCStringTest methodsFor: 'tests'!testInsertAtEnd	| string |	string := SmaCCString on: '12345'.	string insert: '6' at: 6.	self assert: string asString = '123456'! !!SmaCCStringTest methodsFor: 'tests'!testInsertAtBeginning	| string |	string := SmaCCString on: '12345'.	string insert: '0' at: 1.	self assert: string asString = '012345'! !!SmaCCStringTest methodsFor: 'tests'!testReplaceInserted	| string index |	string := SmaCCString on: '1245'.	index := string insert: 'x' at: 3.	string replaceFrom: index to: index with: '3'.	self assert: string asString = '12345'! !!SmaCCStringTest methodsFor: 'tests'!testDeleteUpToEnd	| string |	string := SmaCCString on: '123456'.	#(1 5) do: [ :each | string deleteCharacter: each ].	string deleteUpToEnd: 3.	self assert: string asString = '2'! !