Notification subclass: #SmaCCAmbiguousResultNotification	instanceVariableNames: 'parser'	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!!SmaCCAmbiguousResultNotification commentStamp: '' prior: 0!SmaCCAmbiguousResultNotification is a notification that is signaled when the GLR parser accepts multiple parses. The user can catch this signal and resume it with the correct parse. The parameters of the notification are the potential parses.Instance Variables:	parser	<SmaCCGLRParser>	the parser that parsed the ambiguous results!!SmaCCAmbiguousResultNotification methodsFor: 'private - actions'!defaultAction	^ self tag first! !!SmaCCAmbiguousResultNotification methodsFor: 'accessing'!parser: anObject	parser := anObject! !!SmaCCAmbiguousResultNotification methodsFor: 'accessing'!parser	^ parser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCAmbiguousResultNotification class	instanceVariableNames: ''!!SmaCCAmbiguousResultNotification class methodsFor: 'instance creation'!forParser: aSmaCCParser	^ self new		parser: aSmaCCParser;		yourself! !Object subclass: #SmaCCDeferredChoice	instanceVariableNames: 'possibleItems choiceBlock'	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!!SmaCCDeferredChoice commentStamp: '' prior: 0!SmaCCDeferredChoice represents a choice between multiple parses.Instance Variables	choiceBlock	<BlockClosure>	a two argument block that decides what choice should be chosen	possibleItems	<SequenceableCollection of: Object>	the choices!!SmaCCDeferredChoice methodsFor: 'accessing'!possibleItems: aSequenceableCollection	possibleItems := aSequenceableCollection! !!SmaCCDeferredChoice methodsFor: 'accessing'!performOnSmaCCParser: aSmaCCParser	^ (choiceBlock value: possibleItems value: aSmaCCParser)		performOnSmaCCParser: aSmaCCParser! !!SmaCCDeferredChoice methodsFor: 'accessing'!choiceBlock: aBlock	choiceBlock := aBlock! !!SmaCCDeferredChoice methodsFor: 'accessing'!possibleItems	^ possibleItems! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDeferredChoice class	instanceVariableNames: ''!!SmaCCDeferredChoice class methodsFor: 'private'!sortItems: aCollection	^ aCollection asSortedCollection: [ :a :b | a priority < b priority ]! !!SmaCCDeferredChoice class methodsFor: 'private'!isStack: firstStack preferredOver: secondStack	^ (self		compare: (self deferredItemsIn: firstStack)		to: (self deferredItemsIn: secondStack)) <= 0! !!SmaCCDeferredChoice class methodsFor: 'private'!subItemsIn: aCollection	^ aCollection		inject: OrderedCollection new		into: [ :sum :each | 			sum				addAll: (self deferredItemsIn: each arguments);				yourself ]! !!SmaCCDeferredChoice class methodsFor: 'private'!deferredItemsIn: aCollection	^ aCollection		select: [ :each | each isKindOf: SmaCCDeferredReduceAction ]! !!SmaCCDeferredChoice class methodsFor: 'private'!compare: firstCollection to: secondCollection	| index first second |	first := firstCollection.	second := secondCollection.	[ first := self sortItems: first.	second := self sortItems: second.	index := 1.	[ index <= first size and: [ index <= second size ] ]		whileTrue: [ (first at: index) priority = (second at: index) priority				ifTrue: [ index := index + 1 ]				ifFalse: [ ^ (first at: index) priority - (second at: index) priority ] ].	first := self subItemsIn: first.	second := self subItemsIn: second.	first notEmpty and: [ second notEmpty ] ] whileTrue.	^ 0! !!SmaCCDeferredChoice class methodsFor: 'accessing'!mergeStacks: stacksCollection	| result choiceBlock choices stacks |	stacks := stacksCollection		asSortedCollection: [ :a :b | self isStack: a preferredOver: b ].	choices := 1 to: stacks size.	choiceBlock := [ :possibleChoices :parser | 	| returnValue newChoices |	choices size == 1		ifTrue: [ possibleChoices at: choices first ]		ifFalse: [ returnValue := (SmaCCAmbiguousResultNotification forParser: parser)				messageText: 'Ambiguous results';				tag: (choices collect: [ :each | possibleChoices at: each ]);				signal.			newChoices := choices				select: [ :each | (possibleChoices at: each) == returnValue ].			newChoices notEmpty				ifTrue: [ choices := newChoices ].			returnValue ] ].	result := OrderedCollection new.	1 to: stacks first size do: [ :i | 		| object |		object := stacks first at: i.		(stacks allSatisfy: [ :each | object == (each at: i) ])			ifTrue: [ result add: object ]			ifFalse: [ result					add:						(self new							possibleItems: (stacks collect: [ :each | each at: i ]);							choiceBlock: choiceBlock;							yourself) ] ].	^ result! !Object subclass: #SmaCCDeferredReduceAction	instanceVariableNames: 'arguments reduceEntry'	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!!SmaCCDeferredReduceAction commentStamp: '' prior: 0!SmaCCDeferredReduceAction represents a deferred message that will be sent once we figure out what we are parsing.Instance Variables	arguments	<Array of: Object>	the arguments of the message	selector	<Symbol>	the selector to send!!SmaCCDeferredReduceAction methodsFor: 'accessing'!selector	^ reduceEntry at: 3! !!SmaCCDeferredReduceAction methodsFor: 'accessing'!performOnSmaCCParser: aSmaCCParser	| selector |	selector := self selector.	^ selector numArgs = 0		ifTrue: [ aSmaCCParser perform: selector ]		ifFalse: [ aSmaCCParser				perform: selector				with: (self argumentsFor: aSmaCCParser) ]! !!SmaCCDeferredReduceAction methodsFor: 'accessing'!arguments	^ arguments! !!SmaCCDeferredReduceAction methodsFor: 'initialize-release'!argumentsFor: aSmaCCParser	1 to: arguments size do:		[ :i | 		arguments			at: i			put: ((arguments at: i) performOnSmaCCParser: aSmaCCParser) ].	^ arguments! !!SmaCCDeferredReduceAction methodsFor: 'initialize-release'!entry: anArray arguments: aCollection	reduceEntry := anArray.	arguments := aCollection! !!SmaCCDeferredReduceAction methodsFor: 'comparing'!= anObject	^ self class = anObject class		and:			[ self selector = anObject selector				and: [ self arguments = anObject arguments ] ]! !!SmaCCDeferredReduceAction methodsFor: 'comparing'!hash	^ self class hash bitXor: (reduceEntry hash bitXor: arguments hash)! !!SmaCCDeferredReduceAction methodsFor: 'comparing'!priority	^ reduceEntry at: 4 ifAbsent: [ 0 ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCDeferredReduceAction class	instanceVariableNames: ''!!SmaCCDeferredReduceAction class methodsFor: 'instance creation'!entry: anArray arguments: aCollection	^ self new		entry: anArray arguments: aCollection;		yourself! !SmaCCParser subclass: #SmaCCGLRParser	instanceVariableNames: 'states parseAll currentState tryAllStates lastToken lastState nextScannerState'	classVariableNames: 'maxParallelParses'	package: 'SmaCC_GLR_Runtime'!!SmaCCGLRParser commentStamp: '' prior: 0!SmaCCGLRParser is an abstract superclass for all GLR generated parsers in SmaCC.Instance Variables:	currentState	<SmaCCParserState>	the current parse that we are trying	lastPosition	<Integer>	the starting location of the scanner before calling getNextToken	lastState	<Symbol>	the state of the scanner before calling getNextToken	lastToken	<SmaCCToken>	the token returned from getNextToken (if the lastState and lastToken are the same as the current token, then this value is returned without scanning anything)	nextScannerPosition	<Integer>	the ending location of the scanner after calling getNextToken	nextScannerState	<Symbol>	the ending state of the scanner after calling getNextToken	parseAll	<Boolean>	should we return a collection of all potential parses or just one	states	<SequenceableCollection of: SmaCCParserState>	the current list of valid parses	tryAllStates	<Boolean>	should we try to parse starting from any state instead of the starting state!!SmaCCGLRParser methodsFor: 'error handling'!actionsForState: stateIndex and: aSymbolIndex	| actions |	actions := OrderedCollection new.	self addActionsForState: stateIndex symbol: aSymbolIndex to: actions.	^ actions! !!SmaCCGLRParser methodsFor: 'private'!performParsingStep	currentState isAccepted		ifTrue: [ ^ self ].	self restoreState: currentState.	(tryAllStates and: [ self isEOFToken ])		ifTrue: [ ^ self processEOFToken ].	currentToken isPattern		ifTrue: [ ^ self splitForPatternToken ].	self parseCurrentToken! !!SmaCCGLRParser methodsFor: 'private'!processEOFToken	| originalState performed eofToken |	currentState isAccepted		ifTrue: [ ^ self ].	eofToken := currentToken.	originalState := currentState.	performed := Set new.	self		reduceActionsDo: [ :each | 			(performed includes: each)				ifFalse: [ performed add: each.					self restoreState: self duplicateState.					currentToken := eofToken.					self performAction: each.					(nodeStack size = 1 and: [ nodeStack first isKindOf: SmaCCParseNode ])						ifTrue: [ currentState markAccepted ]						ifFalse: [ (originalState stateStack size <= stateStack size and: [ originalState stateStack last == stateStack last ])								ifTrue: [ self killState ]								ifFalse: [ self processEOFToken ] ].					self restoreState: originalState ] ].	currentToken := eofToken.	(nodeStack size = 1 and: [ nodeStack first isKindOf: SmaCCParseNode ])		ifTrue: [ currentState markAccepted ]		ifFalse: [ self killState ]! !!SmaCCGLRParser methodsFor: 'private'!statesThatShift	^ (1 to: self transitionTable size)		select:			[ :each | 			(1 to: self symbolTypes size)				anySatisfy:					[ :i | 					| actions |					actions := OrderedCollection new.					self addActionsForState: each symbol: i to: actions.					actions						anySatisfy: [ :action | (action bitAnd: self actionMask) = self shiftAction ] ] ]! !!SmaCCGLRParser methodsFor: 'private'!actionsForCurrentToken	| actions |	actions := OrderedCollection new: 1.	self tryAllTokens		ifTrue: [ currentToken ids				do: [ :each | 					self addActionsFor: each to: actions.					(actions notEmpty and: [ self useAllTokenIds not ])						ifTrue: [ ^ actions ] ] ]		ifFalse: [ self addActionsFor: currentToken ids first to: actions ].	^ actions! !!SmaCCGLRParser methodsFor: 'private'!getNextToken	currentToken isNil		ifFalse: [ ^ self ].	lastState = currentState scannerState		ifTrue: [ currentToken := lastToken.			scanner restoreState: nextScannerState.			currentState scannerState: nextScannerState ]		ifFalse: [ lastState := currentState scannerState.			scanner restoreState: currentState scannerState.			lastToken := currentToken := scanner next.			nextScannerState := scanner currentState ].	currentState scannerState: nextScannerState! !!SmaCCGLRParser methodsFor: 'private'!initialParserState	| state |	state := SmaCCParserState		stateStack: stateStack		nodeStack: nodeStack		scannerState: scanner currentState.	^ state! !!SmaCCGLRParser methodsFor: 'private'!addActionsFor: anInteger to: anOrderedCollection	| state |	state := self currentState.	self		addActionsForState: state		symbol: anInteger		to: anOrderedCollection! !!SmaCCGLRParser methodsFor: 'private'!mergeStates	| i j state otherStates otherState |	i := 1.	[ i < states size ]		whileTrue:			[ state := states at: i.			otherStates := OrderedCollection new.			j := i := i + 1.			[ j <= states size ]				whileTrue:					[ otherState := states at: j.					(parseAll						ifTrue: [ state = otherState ]						ifFalse: [ state canBeMergedWith: otherState ])						ifTrue: [ otherStates add: otherState.							states removeAt: j ]						ifFalse: [ j := j + 1 ] ].			(parseAll not and: [ otherStates notEmpty ])				ifTrue: [ state mergeWith: otherStates ] ]! !!SmaCCGLRParser methodsFor: 'private'!reduceActionsDo: aBlock	self		actionsDo: [ :each | 			(each bitAnd: self actionMask) = self reduceAction				ifTrue: [ aBlock value: each ] ]! !!SmaCCGLRParser methodsFor: 'private'!restoreState: aSmaCCParserState	currentState := aSmaCCParserState.	nodeStack := aSmaCCParserState nodeStack.	stateStack := aSmaCCParserState stateStack.	scanner restoreState: currentState scannerState! !!SmaCCGLRParser methodsFor: 'private'!parseCurrentToken	| actions action isAccept |	[ actions := self actionsForCurrentToken.	actions isEmpty		ifTrue: [ isAccept := false.			self killState				ifFalse: [ ^ currentToken := nil ] ]		ifFalse:			[ 2 to: actions size do: [ :i | self splitWithAction: (actions at: i) ].			action := actions first.			isAccept := action = self acceptAction.			isAccept				ifFalse: [ self performAction: action ] ].	isAccept or: [ currentToken isNil ] ] whileFalse.	action = self acceptAction		ifTrue: [ currentState markAccepted ]! !!SmaCCGLRParser methodsFor: 'private'!duplicateState	| state |	states size >= self class maxParallelParses ifTrue: [ SmaCCTooAmbiguousNotification signal ].	parseAll ifTrue: [nodeStack := nodeStack collect: [:each | self copyStackObject: each]] ifFalse: [nodeStack := nodeStack copy].	stateStack := stateStack copy.	state := currentState copy.	state stateStack: stateStack nodeStack: nodeStack.	state scannerState: scanner currentState.	states add: state.	^state! !!SmaCCGLRParser methodsFor: 'private'!setStartingStatesIfNone	states isEmpty		ifTrue:			[ states add: self initialParserState ]! !!SmaCCGLRParser methodsFor: 'private'!splitForPatternToken	| token patternNode performedActions nodeClass |	performedActions := Set new.	token := currentToken copy.	token ids: OrderedCollection new.	patternNode := SmaCCPatternNode onToken: token copy.	nodeClass := token nodeClassName		ifNil: [ SmaCCParseNode ]		ifNotNil: [ :name | self class environment at: name ifAbsent: [ SmaCCParseNode ] ].	self symbolTypes		keysAndValuesDo:			[ :i :each | 			| actions |			(i ~= scanner emptySymbolTokenId and: [ i ~= scanner errorTokenId ])				ifTrue:					[ actions := OrderedCollection new.					(each = #SmaCCToken						or:							[ each notNil								and:									[ ((self class environment at: each ifAbsent: [ Object ])includesBehavior: nodeClass) or: [ nodeClass includesBehavior: (selfclass environment at: each ifAbsent: [ self class ]) ] ] ])						ifTrue:							[ self addActionsFor: i to: actions.							actions								do:									[ :action | 									(performedActions includes: action)										ifFalse:											[ performedActions add: action.											each = #SmaCCToken												ifTrue:													[ token ids add: i.													((action bitAnd: self actionMask) = self reduceAction														or: [ token isToken ])														ifTrue: [ currentToken := token.															self splitWithAction: action ] ]												ifFalse:													[ token isNode														ifTrue:															[ currentToken := nil.															self duplicateState.															stateStack addLast: (action bitShift: -2).															nodeStack addLast: patternNode.															self restoreState: currentState ] ] ] ] ] ] ].	self killState.	currentToken := nil! !!SmaCCGLRParser methodsFor: 'private'!fixObject: anObject	| result |	result := anObject performOnSmaCCParser: self.	(result isKindOf: SmaCCParseNode)		ifTrue: [ result fixParentPointers ].	^ result! !!SmaCCGLRParser methodsFor: 'private'!scope: aSymbol	super scope: aSymbol.	currentState scannerState: scanner currentState! !!SmaCCGLRParser methodsFor: 'private'!addAction: action to: anOrderedCollection	(anOrderedCollection includes: action)		ifTrue: [ ^ self ].	anOrderedCollection add: action! !!SmaCCGLRParser methodsFor: 'private'!position: anInteger	super position: anInteger.	currentState scannerState: scanner currentState! !!SmaCCGLRParser methodsFor: 'private'!reduce: anInteger	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := Array new: (size := reduceEntry at: 2).	nodeStack size < size		ifTrue: [ self killState.			^ currentToken := nil ].	size to: 1 by: -1 do: [ :i | 		items at: i put: self popNodeStack.		stateStack removeLast ].	nodeStack addLast: (self performReduceEntry: reduceEntry with: items).	stateStack		addLast: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)! !!SmaCCGLRParser methodsFor: 'private'!trimParallelParses	"Since we don't implement the whole GLR algorithm, for highly ambiguous grammars we can have exponential parses. When we grow too large, we indiscriminately delete some."	| newCount |	newCount := (self class maxParallelParses bitShift: -2) max: 1.	states := states copyFrom: 1 to: newCount! !!SmaCCGLRParser methodsFor: 'private'!actionsDo: aBlock	| row actionBlock |	actionBlock := [ :action | 	(self isAmbiguous: action)		ifTrue: [ | ambiguous |			ambiguous := OrderedCollection new.			self ambiguousTransitionsAt: (action bitShift: -2) into: ambiguous.			ambiguous do: aBlock ]		ifFalse: [ aBlock value: action ] ].	row := self transitionTable at: self currentState.	(row at: 1) == 0		ifTrue: [ actionBlock value: ((row at: 2) bitShift: 8) + (row at: 3) ]		ifFalse: [ 2 to: row size by: 4 do: [ :i | actionBlock value: ((row at: i) bitShift: 8) + (row at: i + 1) ] ]! !!SmaCCGLRParser methodsFor: 'private'!splitWithAction: anInteger	| previousToken previousState |	previousState := currentState.	previousToken := currentToken.	[ currentState := self duplicateState.	self performAction: anInteger.	currentToken notNil		ifTrue: [ self performParsingStep ] ]		ensure: [ self restoreState: previousState.			currentToken := previousToken ]! !!SmaCCGLRParser methodsFor: 'private'!ambiguousTransitionsAt: anIndex into: anOrderedCollection	| ambiguousTransitions |	ambiguousTransitions := self ambiguousTransitions at: anIndex.	1 to: ambiguousTransitions size by: 2 do:		[ :i | 		self			addAction:				((ambiguousTransitions at: i) bitShift: 8)					+ (ambiguousTransitions at: i + 1)			to: anOrderedCollection ]! !!SmaCCGLRParser methodsFor: 'private'!copyStackObject: anObject	(anObject isKindOf: String) ifTrue: [^anObject].	(anObject isKindOf: Collection) ifTrue: [^anObject collect: [:each | self copyStackObject: each]].	(anObject isKindOf: SmaCCParseNode) ifTrue: [^anObject copy].	^anObject! !!SmaCCGLRParser methodsFor: 'private'!performReduceEntry: entryArray with: items	^ (states size = 1		or: [ parseAll or: [ entryArray at: 5 ifAbsent: [ false ] ] ])		ifTrue:			[ 1 to: items size do: [ :i | items at: i put: ((items at: i) performOnSmaCCParser: self) ].			super performReduceEntry: entryArray with: items ]		ifFalse: [ SmaCCDeferredReduceAction entry: entryArray arguments: items ]! !!SmaCCGLRParser methodsFor: 'private'!popNodeStack	| result |	result := nodeStack removeLast.	(self alwaysPerformReduceAction and: [ states size > 1 ])		ifTrue: [ result := self copyStackObject: result ].	^ result! !!SmaCCGLRParser methodsFor: 'private'!states	^states! !!SmaCCGLRParser methodsFor: 'private'!currentGLRState	^ currentState! !!SmaCCGLRParser methodsFor: 'private'!killState	| index |	index := states identityIndexOf: currentState ifAbsent: [ ^ false ].	states size = 1		ifTrue: [ ^ self handleError: 0 ].	states removeAt: index.	(states size = 1 and: [ parseAll not ])		ifTrue: [ states first runDeferredActionsFor: self ].	^ false! !!SmaCCGLRParser methodsFor: 'private'!isAmbiguous: action	^ (action bitAnd: self actionMask) = 2r11! !!SmaCCGLRParser methodsFor: 'private'!alwaysPerformReduceAction	^ false! !!SmaCCGLRParser methodsFor: 'private'!addActionsForState: state symbol: anInteger to: anOrderedCollection	| action |	action := self actionForState: state and: anInteger.	action = self errorAction		ifTrue: [ ^ self ].	(self isAmbiguous: action)		ifTrue: [ self				ambiguousTransitionsAt: (action bitShift: -2)				into: anOrderedCollection ]		ifFalse: [ self addAction: action to: anOrderedCollection ]! !!SmaCCGLRParser methodsFor: 'private'!performParsingLoop	| result |	self setStartingStatesIfNone.	[ [ states size to: 1 by: -1 do: [ :i | 		currentToken := nil.		self restoreState: (states at: i).		self getNextToken.		self performParsingStep ] ]		on: SmaCCTooAmbiguousNotification		do: [ :ex | self trimParallelParses ].	self mergeStates.	states anySatisfy: [ :each | each isAccepted not ] ] whileTrue.	self checkForErrors.	result := parseAll		ifTrue:			[ states collect: [ :each | self fixObject: each nodeStack first ] ]		ifFalse: [ self fixObject: states first nodeStack first ].	nodeStack := OrderedCollection with: result! !!SmaCCGLRParser methodsFor: 'accessing'!setAllStartingStates	tryAllStates := true.	self statesThatShift		do:			[ :each | 			states				add:					(SmaCCParserState						stateStack: (OrderedCollection with: each)						nodeStack: OrderedCollection new						scannerState: scanner currentState) ]! !!SmaCCGLRParser methodsFor: 'accessing'!parseAll: aBoolean	parseAll := aBoolean! !!SmaCCGLRParser methodsFor: 'initialize-release'!initialize	super initialize.	states := OrderedCollection new.	parseAll := false.	tryAllStates := false! !!SmaCCGLRParser methodsFor: 'testing'!useAllTokenIds	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCGLRParser class	instanceVariableNames: 'cachedTrees'!!SmaCCGLRParser class methodsFor: 'parsing'!parseAll: aString startingAt: anInteger	| parser results |	parser := self on: (ReadStream on: aString).	parser setStartingState: anInteger.	parser parseAll: true.	results := parser parse.	results		do: [ :each | 			(each isKindOf: SmaCCParseNode)				ifTrue: [ each completeSource: aString ] ].	^ results! !!SmaCCGLRParser class methodsFor: 'parsing'!parseAndCacheAllPossibleStates: aString	^ (self cachedTrees at: (Array with: aString with: nil) ifAbsentPut: [ self parseAllPossibleStates: aString ]) copy! !!SmaCCGLRParser class methodsFor: 'parsing'!parseAllPossibleStates: aString	"Returns all possible parse nodes that can be created from aString starting from any place in the parser."	| parser results |	parser := self on: (ReadStream on: aString).	parser		parseAll: true;		setAllStartingStates.	results := parser parse asSet asOrderedCollection.	results		do: [ :each | 			(each isKindOf: SmaCCParseNode)				ifTrue: [ each completeSource: aString ] ].	^ results! !!SmaCCGLRParser class methodsFor: 'parsing'!parseAndCacheAll: aString startingAt: anInteger	^ (self cachedTrees at: (Array with: aString with: anInteger) ifAbsentPut: [ self parseAll: aString startingAt: anInteger ]) copy! !!SmaCCGLRParser class methodsFor: 'accessing'!maxParallelParses	^ maxParallelParses		ifNil: [ maxParallelParses := SmallInteger maxVal ]! !!SmaCCGLRParser class methodsFor: 'accessing'!cachedTrees	^ cachedTrees ifNil: [ cachedTrees := Dictionary new ]! !!SmaCCGLRParser class methodsFor: 'accessing'!maxParallelParses: anInteger	maxParallelParses := anInteger! !!SmaCCGLRParser class methodsFor: 'accessing'!resetCaches	super resetCaches.	cachedTrees := nil! !Object subclass: #SmaCCParserState	instanceVariableNames: 'stateStack nodeStack isAccepted scannerState attributes'	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!!SmaCCParserState commentStamp: '' prior: 0!SmaCCParserState represents a particular parse in a GLR parser.Instance Variables:	isAccepted	<Boolean>	has this parse been accepted	nodeStack	<SequenceableCollection of: Object>	the stack of objects for this parse	position	<Integer>	the current position of the scanner	scannerState	<Symbol> the current state of the scanner	stateStack	<SequenceableCollection of: Integer>	the stack of states for this parse!!SmaCCParserState methodsFor: 'testing'!isAccepted	^ isAccepted! !!SmaCCParserState methodsFor: 'testing'!canBeMergedWith: aSmaCCParserState	^ self stateStack = aSmaCCParserState stateStack and: [ self scannerState = aSmaCCParserState scannerState ]! !!SmaCCParserState methodsFor: 'copying'!postCopy	super postCopy.	attributes notNil		ifTrue: [ attributes := attributes copy ]! !!SmaCCParserState methodsFor: 'initialize-release'!stateStack: stateCollection nodeStack: nodeCollection	stateStack := stateCollection.	nodeStack := nodeCollection.	isAccepted := false! !!SmaCCParserState methodsFor: 'comparing'!= anObject	^ self == anObject		or:			[ self class = anObject class				and:					[ self stateStack = anObject stateStack						and: [ self nodeStack = anObject nodeStack ] ] ]! !!SmaCCParserState methodsFor: 'comparing'!hash	^ self stateStack hash! !!SmaCCParserState methodsFor: 'accessing'!scannerState: anObject	scannerState := anObject! !!SmaCCParserState methodsFor: 'accessing'!scannerState	^ scannerState! !!SmaCCParserState methodsFor: 'accessing'!attributeNamed: aSymbol	^attributes ifNil: [ nil ] ifNotNil: [ attributes at: aSymbol ]! !!SmaCCParserState methodsFor: 'accessing'!nodeStack	^ nodeStack! !!SmaCCParserState methodsFor: 'accessing'!mergeWith: aSmaCCParserStateCollection	| stacks |	stacks := OrderedCollection new: aSmaCCParserStateCollection size + 1.	stacks add: nodeStack.	aSmaCCParserStateCollection		do:			[ :each | 			(stacks includes: each nodeStack)				ifFalse: [ stacks add: each nodeStack ] ].	nodeStack := SmaCCDeferredChoice mergeStacks: stacks! !!SmaCCParserState methodsFor: 'accessing'!runDeferredActionsFor: aSmaCCParser	1 to: nodeStack size do:		[ :i | 		| each |		each := nodeStack at: i.		nodeStack at: i put: (each performOnSmaCCParser: aSmaCCParser) ]! !!SmaCCParserState methodsFor: 'accessing'!attributeNamed: aSymbol put: aValue	(attributes ifNil: [ attributes := Dictionary new ]) at: aSymbol put: aValue! !!SmaCCParserState methodsFor: 'accessing'!stateStack	^ stateStack! !!SmaCCParserState methodsFor: 'accessing'!markAccepted	isAccepted := true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParserState class	instanceVariableNames: ''!!SmaCCParserState class methodsFor: 'instance creation'!stateStack: stateStack nodeStack: nodeStack	^ self new		stateStack: stateStack nodeStack: nodeStack;		yourself! !!SmaCCParserState class methodsFor: 'instance creation'!stateStack: stateStack nodeStack: nodeStack scannerState: aSmaCCScannerState	^ self new		stateStack: stateStack nodeStack: nodeStack;		scannerState: aSmaCCScannerState;		yourself! !Object subclass: #SmaCCScannerState	instanceVariableNames: 'position scope attributes'	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!!SmaCCScannerState commentStamp: '' prior: 0!This object holds the state for the scanner so that multiple GLR parses can use the same scanner by simply restoring the state.    Instance Variables	position		<Integer>	current location in the input stream	scope		<Symbol>	the type of item to be scanned (most of the time #default)!!SmaCCScannerState methodsFor: 'copying'!postCopy	super postCopy.	attributes notNil		ifTrue: [ attributes := attributes copy ]! !!SmaCCScannerState methodsFor: 'comparing'!= anObject	^ self class = anObject class and: [ self position = anObject position and: [ self scope = anObject scope ] ]! !!SmaCCScannerState methodsFor: 'comparing'!hash	^ position hash hashMultiply bitXor: scope hash! !!SmaCCScannerState methodsFor: 'accessing'!position: anInteger	position := anInteger! !!SmaCCScannerState methodsFor: 'accessing'!scope	^ scope! !!SmaCCScannerState methodsFor: 'accessing'!attributeNamed: aSymbol	^attributes ifNil: [ nil ] ifNotNil: [ attributes at: aSymbol ]! !!SmaCCScannerState methodsFor: 'accessing'!position	^ position! !!SmaCCScannerState methodsFor: 'accessing'!attributeNamed: aSymbol put: aValue	(attributes ifNil: [ attributes := Dictionary new ]) at: aSymbol put: aValue! !!SmaCCScannerState methodsFor: 'accessing'!scope: aSymbol	scope := aSymbol! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCScannerState class	instanceVariableNames: ''!!SmaCCScannerState class methodsFor: 'instance creation'!position: anInteger scope: aSymbol	^ self new		position: anInteger;		scope: aSymbol;		yourself! !Notification subclass: #SmaCCTooAmbiguousNotification	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_GLR_Runtime'!'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:50.037656 pm'!!Object methodsFor: '*SmaCC_GLR_Runtime'!performOnSmaCCParser: aSmaCCParser	^ self! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:50.038656 pm'!!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!restoreState: aSmaCCScannerState	"Restore the state using the object returned from #currentState."	self setPosition: aSmaCCScannerState position.	self scope: aSmaCCScannerState scope! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:50.039656 pm'!!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!currentState	"Return an object that can be used to restoreState: when switching between parses in a GLR parser. 	This object should implement #= in such a way that if the state is restored, then calling #next will 	always return the same token. If you add state to your scanner you may want to override this method	and #restoreState: to include that state."	^ self stateClass position: self position scope: self scope! !'From Pharo8.0.0 of 22 January 2020 [Build information: Pharo-8.0.0+build.1124.sha.0932da82f08175e906b0e2a8052120c823374e9f (64 Bit)] on 20 April 2020 at 11:19:50.039656 pm'!!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!stateClass	^ SmaCCScannerState! !