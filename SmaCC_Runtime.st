Object subclass: #SmaCCErrorHandler	instanceVariableNames: 'parser'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCErrorHandler methodsFor: 'error handling'!handleError: anInteger	self subclassResponsibility! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!errorToken: aSmaCCToken	parser errorToken: aSmaCCToken! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!willAccept: potentialStateStack	^ parser willAccept: potentialStateStack! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!isEOFToken	^ parser isEOFToken! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!actionsForState: stateIndex and: aSymbolIndex	^ parser actionsForState: stateIndex and: aSymbolIndex! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!symbolTypes	^ parser symbolTypes! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!dismissErrorToken	^ parser dismissErrorToken! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!currentToken	^ parser currentToken! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!reduceAction	^ parser reduceAction! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!nodeStack	^ parser nodeStack! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!reportError: anInteger	^ parser reportError: anInteger! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!reduce: anInteger	^ parser reduce: anInteger! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!errorTokenId	^ parser errorTokenId! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!stateStack	^ parser stateStack! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!willShift: potentialStateStack	^ parser willShift: potentialStateStack! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!shiftAction	^ parser shiftAction! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!actionsAndSymbolsForState: stateIndex do: aBlock	parser actionsAndSymbolsForState: stateIndex do: aBlock! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!allActionsAndSymbolsForState: stateIndex do: aBlock	parser allActionsAndSymbolsForState: stateIndex do: aBlock! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!isNodeType: aSymbol	^ parser isNodeType: aSymbol! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!dismissStackTopForErrorRecovery: anInteger	^ parser dismissStackTopForErrorRecovery: anInteger! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!actionMask	^ parser actionMask! !!SmaCCErrorHandler methodsFor: 'private-parser accessing'!markErrorToken	self errorToken: self currentToken! !!SmaCCErrorHandler methodsFor: 'accessing'!parser: aSmaCCParser	parser := aSmaCCParser! !!SmaCCErrorHandler methodsFor: 'accessing'!parser	^ parser! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCErrorHandler class	instanceVariableNames: ''!!SmaCCErrorHandler class methodsFor: 'instance creation'!on: aSmaCCParser	^ self new		parser: aSmaCCParser;		yourself! !SmaCCErrorHandler subclass: #SmaCCErrorNodeHandler	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!nodeErrorHandlerStates	^ self stateStack collect: [ :each | self nodeShiftActionsFor: each ]! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!errorShiftActionsForState: stateIndex	^ self nodeShiftActionsFor: stateIndex! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!findErrorHandlerIfNoneUseErrorNumber: anInteger	| handlerStates index startingErrorToken stackContents dismissedTokens newState |	dismissedTokens := OrderedCollection new.	handlerStates := self errorHandlerStates reverse.	startingErrorToken := self currentToken.	[ self isEOFToken		ifTrue: [ self finishErrorParse: startingErrorToken dismissed: dismissedTokens.			^ true ].	handlerStates size to: 1 by: -1 do: [ :i | 		| states newStack |		states := handlerStates at: i.		states			do: [ :each | 				newStack := parser stateStack copyFrom: 1 to: handlerStates size - i + 1.				newStack addLast: each.				(self willShift: newStack)					ifTrue: [ index := i.						newState := each ] ] ].	index isNil ] whileTrue: [ dismissedTokens add: self dismissErrorToken ].	stackContents := self dismissStackTopForErrorRecovery: index - 1.	self stateStack addLast: newState.	self nodeStack		addLast:			(SmaCCErrorNode new				stackContents: stackContents;				dismissedTokens: dismissedTokens;				errorToken: startingErrorToken;				yourself).	^ true! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!performErrorReductions	self subclassResponsibility! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!errorSortValueFor: stateIndex	| count hasCurrentTokenAction |	count := 0.	hasCurrentTokenAction := false.	self		allActionsAndSymbolsForState: stateIndex		do: [ :action :symbol | 			count := count + 1.			hasCurrentTokenAction := hasCurrentTokenAction or: [ self currentToken ids includes: symbol ] ].	^ hasCurrentTokenAction		ifTrue: [ count bitShift: 16 ]		ifFalse: [ count ]! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!errorHandlerStates	^ self stateStack collect: [ :each | self errorShiftActionsForState: each ]! !!SmaCCErrorNodeHandler methodsFor: 'private-error handling'!nodeShiftActionsFor: stateIndex	| potentialNewStates |	potentialNewStates := Set new.	self		allActionsAndSymbolsForState: stateIndex		do: [ :action :symbol | 			((action bitAnd: self actionMask) = self shiftAction and: [ self isNodeType: (self symbolTypes at: symbol ifAbsent: [ #Object ]) ])				ifTrue: [ potentialNewStates add: (action bitShift: -2) ] ].	^ potentialNewStates asSortedCollection: [ :a :b | (self errorSortValueFor: a) < (self errorSortValueFor: b) ]! !!SmaCCErrorNodeHandler methodsFor: 'error handling'!handleError: anInteger	self markErrorToken.	self performErrorReductions.	self isEOFToken		ifTrue: [ self finishErrorParse: self currentToken dismissed: OrderedCollection new.			^ true ].	^ self findErrorHandlerIfNoneUseErrorNumber: anInteger! !!SmaCCErrorNodeHandler methodsFor: 'error handling'!finishErrorParse: errorToken dismissed: dismissedTokens handlerStates: handlerStates	| newStack stackContents |	1 to: handlerStates size do: [ :i | 		(handlerStates at: i)			reverseDo: [ :each | 				newStack := parser stateStack copyFrom: 1 to: handlerStates size - i + 1.				newStack addLast: each.				(self willAccept: newStack)					ifTrue: [ stackContents := self dismissStackTopForErrorRecovery: i - 1.						self stateStack addLast: each.						self nodeStack							addLast:								(SmaCCErrorNode new									stackContents: stackContents;									dismissedTokens: dismissedTokens;									errorToken: errorToken;									yourself).						^ true ] ] ].	^ false! !!SmaCCErrorNodeHandler methodsFor: 'error handling'!finishErrorParse: errorToken dismissed: dismissedTokens	| handlerStates |	handlerStates := self nodeErrorHandlerStates reverse.	(self finishErrorParse: errorToken dismissed: dismissedTokens handlerStates: handlerStates)		ifFalse: [ self reportError: 0 ]! !SmaCCErrorNodeHandler subclass: #SmaCCDefaultErrorNodeHandler	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCDefaultErrorNodeHandler methodsFor: 'private-error handling'!errorShiftActionsForState: stateIndex	^ self nodeShiftActionsFor: stateIndex! !!SmaCCDefaultErrorNodeHandler methodsFor: 'private-error handling'!performErrorReductions	| onlyAction actions |	[ actions := Set new.	self actionsAndSymbolsForState: self stateStack last do: [ :action :symbol | actions add: action ].	actions size = 1 and: [ ((onlyAction := actions anyOne) bitAnd: self actionMask) == self reduceAction ] ]		whileTrue: [ self reduce: (onlyAction bitShift: -2) ]! !Stream subclass: #SmaCCLineNumberStream	instanceVariableNames: 'sourceStream previousWasCR eolPositions lastPosition'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCLineNumberStream commentStamp: '' prior: 0!SmaCCLineNumberStream is a wrapper for streams that calculates line numbers.Instance Variables:	eolPositions	<OrderedCollection of: Integer>	the positions of each end of line	lastPosition	<Integer>	the position of the last character that we have calculated the end of line information for (we know the line number for all characters before this position and don't know anything about the characters after this position)	previousWasCR	<Boolean>	was the previous character a CR. This is used for CR LF streams. A CR LF combination should only increment the line counter by 1	sourceStream	<Stream>	the stream that we are wrapping!!SmaCCLineNumberStream methodsFor: 'testing'!isReadable	^ sourceStream isReadable! !!SmaCCLineNumberStream methodsFor: 'testing'!atEnd	^ sourceStream atEnd! !!SmaCCLineNumberStream methodsFor: 'testing'!isWritable	^ sourceStream isWritable! !!SmaCCLineNumberStream methodsFor: 'initialize-release'!on: aReadStream	sourceStream := aReadStream.	eolPositions := OrderedCollection with: aReadStream position.	lastPosition := aReadStream position.	previousWasCR := false! !!SmaCCLineNumberStream methodsFor: 'accessing'!columnNumberFor: anInteger	^ anInteger - (eolPositions at: (self lineNumberFor: anInteger)) + 1! !!SmaCCLineNumberStream methodsFor: 'accessing'!peek	^ sourceStream peek! !!SmaCCLineNumberStream methodsFor: 'accessing'!lineNumber	^ self lineNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing'!columnNumber	^ self columnNumberFor: self position! !!SmaCCLineNumberStream methodsFor: 'accessing'!lineNumberFor: anInteger	| index start stop pos |	pos := anInteger.	pos >= eolPositions last		ifTrue: [ ^ eolPositions size ].	start := 1.	stop := eolPositions size.	[ start + 1 < stop ]		whileTrue:			[ index := (start + stop) // 2.			(eolPositions at: index) <= pos				ifTrue: [ start := index ]				ifFalse: [ stop := index ] ].	^ start! !!SmaCCLineNumberStream methodsFor: 'accessing'!position	^ sourceStream position! !!SmaCCLineNumberStream methodsFor: 'accessing'!position: anInteger	anInteger > lastPosition		ifTrue:			[ sourceStream position: lastPosition.			[ sourceStream position < anInteger and: [ sourceStream atEnd not ] ]				whileTrue: [ self next ] ]		ifFalse: [ sourceStream position: anInteger ]! !!SmaCCLineNumberStream methodsFor: 'accessing'!next	| character streamPosition |	character := sourceStream next.	streamPosition := sourceStream position.	streamPosition - 1 >= lastPosition		ifTrue:			[ lastPosition := streamPosition.			character == Character cr				ifTrue: [ eolPositions add: lastPosition.					previousWasCR := true ]				ifFalse:					[ character == Character lf						ifTrue:							[ previousWasCR								ifTrue: [ eolPositions at: eolPositions size put: lastPosition ]								ifFalse: [ eolPositions add: lastPosition ] ].					previousWasCR := false ] ].	^ character! !!SmaCCLineNumberStream methodsFor: 'accessing'!contents	^ sourceStream contents! !!SmaCCLineNumberStream methodsFor: 'accessing'!skip: anInteger	^ self position: self position + anInteger! !!SmaCCLineNumberStream methodsFor: 'accessing'!nextPut: anObject	^ sourceStream nextPut: anObject! !!SmaCCLineNumberStream methodsFor: 'accessing'!flush	^ sourceStream flush! !!SmaCCLineNumberStream methodsFor: 'error handling'!doesNotUnderstand: aMessage	^ [ sourceStream		perform: aMessage selector		withArguments: aMessage arguments ]		ensure: [ self position: sourceStream position ]! !!SmaCCLineNumberStream methodsFor: 'private'!contentsSpecies	^ sourceStream contentsSpecies! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCLineNumberStream class	instanceVariableNames: ''!!SmaCCLineNumberStream class methodsFor: 'instance creation'!on: aReadStream	^ self basicNew		on: aReadStream;		yourself! !SmaCCErrorHandler subclass: #SmaCCNoErrorHandler	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCNoErrorHandler methodsFor: 'error handling'!handleError: anInteger	self markErrorToken.	self reportError: anInteger! !Object subclass: #SmaCCParseNode	instanceVariableNames: 'parent attributes'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCParseNode commentStamp: '' prior: 0!SmaCCParseNode is an abstract class that represents parse nodes generated by SmaCC.Subclasses must implement the following messages:	visitor-double dispatching		acceptVisitor:Instance Variables:	attributes	<Dictionary>	a dictionary that holds special properties for each node	parent	<SmaCCParseNode>	the parent node in the parse tree!!SmaCCParseNode methodsFor: 'initialize-release'!fixParentPointers	self		nodesDo: [ :each | 			each parent: self.			each fixParentPointers ]! !!SmaCCParseNode methodsFor: 'copying'!postCopy	super postCopy.	self		allGettersDo:			[ :each | 			self				perform: (self convertToSetter: each)				with:					((self compositeVariableSelectors includes: each)						ifTrue: [ (self perform: each) collect: [ :item | item copy ] ]						ifFalse: [ (self perform: each) copy ]) ]! !!SmaCCParseNode methodsFor: 'iterating'!allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean	self		nodesDo: [ :each | 			nodeBlock value: each.			each allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean ]		andTokensDo: tokenBlock		includeErrors: aBoolean! !!SmaCCParseNode methodsFor: 'iterating'!withAllNodesDo: nodeBlock andTokensDo: tokenBlock includesErrors: aBoolean	nodeBlock value: self.	self allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean! !!SmaCCParseNode methodsFor: 'iterating'!allGettersDo: aBlock	self allVariableSelectors		do: [ :sel | (self perform: sel) do: aBlock ]! !!SmaCCParseNode methodsFor: 'iterating'!nodesDo: nodeBlock	self nodesDo: nodeBlock andTokensDo: nil! !!SmaCCParseNode methodsFor: 'iterating'!nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean	| block |	nodeBlock notNil		ifTrue: [ block := [ :each | (self perform: each) ifNotNil: nodeBlock ].			self nodeVariables do: block.			self ignoredNodeVariables do: block.			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: nodeBlock ] ].			self compositeNodeVariables do: block.			self ignoredCompositeNodeVariables do: block ].	tokenBlock notNil		ifTrue: [ block := [ :each | (self perform: each) ifNotNil: tokenBlock ].			self tokenVariables do: block.			self ignoredTokenVariables do: block.			block := [ :each | (self perform: each) ifNotNil: [ :nodes | nodes do: tokenBlock ] ].			self compositeTokenVariables do: block.			self ignoredCompositeTokenVariables do: block ].	block := [ :each | 	nodeBlock notNil		ifTrue: [ (each isKindOf: SmaCCParseNode)				ifTrue: [ nodeBlock value: each ] ].	tokenBlock notNil		ifTrue: [ (each isKindOf: SmaCCToken)				ifTrue: [ tokenBlock value: each ] ].	(each isKindOf: Collection)		ifTrue: [ each do: block ] ].	self otherVariables do: [ :sel | block value: (self perform: sel) ].	self ignoredOtherVariables do: [ :sel | block value: (self perform: sel) ]! !!SmaCCParseNode methodsFor: 'iterating'!allNodesDo: nodeBlock andTokensDo: tokenBlock	self allNodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: false! !!SmaCCParseNode methodsFor: 'iterating'!withAllNodesOfType: aClass do: nodeBlock	(self isKindOf: aClass)		ifTrue: [ nodeBlock value: self ].	self allNodesOfType: aClass do: nodeBlock! !!SmaCCParseNode methodsFor: 'iterating'!withAllNodesDo: nodeBlock	nodeBlock value: self.	self allNodesDo: nodeBlock! !!SmaCCParseNode methodsFor: 'iterating'!nodesDo: nodeBlock andTokensDo: tokenBlock	self nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: false! !!SmaCCParseNode methodsFor: 'iterating'!withAllNodesDo: nodeBlock andTokensDo: tokenBlock	self withAllNodesDo: nodeBlock andTokensDo: tokenBlock includesErrors: false! !!SmaCCParseNode methodsFor: 'iterating'!allNodesOfType: aClass do: nodeBlock	self		allNodesDo: [ :each | 			(each isKindOf: aClass)				ifTrue: [ nodeBlock value: each ] ]! !!SmaCCParseNode methodsFor: 'iterating'!allNodesDo: nodeBlock	self allNodesDo: nodeBlock andTokensDo: nil! !!SmaCCParseNode methodsFor: 'accessing'!allParents	| parents |	parent isNil		ifTrue: [ ^ #() ].	parents := OrderedCollection with: parent.	[ parents last parent notNil ] whileTrue: [ parents addLast: parents last parent ].	^ parents! !!SmaCCParseNode methodsFor: 'accessing'!startPosition	^ self attributeNamed: #startPosition ifAbsentPut: [ self calculateStartPosition ]! !!SmaCCParseNode methodsFor: 'accessing'!sourceInterval	^ self startPosition to: self stopPosition! !!SmaCCParseNode methodsFor: 'accessing'!parent	^ parent! !!SmaCCParseNode methodsFor: 'accessing'!topParent	| current |	current := self.	[ current parent notNil ] whileTrue: [ current := current parent ].	^ current! !!SmaCCParseNode methodsFor: 'accessing'!parent: aSmaCCParseNode	parent := aSmaCCParseNode! !!SmaCCParseNode methodsFor: 'accessing'!nodeOfType: aSmaCCParseNodeClassOrCollection	| isCollection |	isCollection := aSmaCCParseNodeClassOrCollection isKindOf: Collection.	^ self		lookupNode:			[ :each | 			isCollection				ifTrue:					[ aSmaCCParseNodeClassOrCollection						anySatisfy: [ :class | each isKindOf: class ] ]				ifFalse: [ each isKindOf: aSmaCCParseNodeClassOrCollection ] ]! !!SmaCCParseNode methodsFor: 'accessing'!comments: anObject	self attributeNamed: #comments put: anObject! !!SmaCCParseNode methodsFor: 'accessing'!lookupNode: aBlock	| current |	current := self.	[ current isNil or: [ aBlock value: current ] ]		whileFalse: [ current := current parent ].	^ current! !!SmaCCParseNode methodsFor: 'accessing'!allTokens	| tokens |	tokens := OrderedCollection new.	self allTokensInto: tokens.	^ tokens		asSortedCollection: [ :a :b | a startPosition < b startPosition ]! !!SmaCCParseNode methodsFor: 'accessing'!children	| result |	result := OrderedCollection new.	self		nodesDo: [ :each | 			each notNil				ifTrue: [ result add: each ] ].	^ result! !!SmaCCParseNode methodsFor: 'accessing'!allTokensInto: aCollection	self tokenVariables		do:			[ :each | (self perform: each) ifNotNil: [ :token | aCollection add: token ] ].	self compositeTokenVariables		do:			[ :each | 			(self perform: each)				ifNotNil: [ :tokens | aCollection addAll: tokens ] ].	self nodesDo: [ :each | each allTokensInto: aCollection ]! !!SmaCCParseNode methodsFor: 'accessing'!parentOfType: aSmaCCParseNodeClassOrCollection	^ parent notNil		ifTrue: [ parent nodeOfType: aSmaCCParseNodeClassOrCollection ]		ifFalse: [ nil ]! !!SmaCCParseNode methodsFor: 'accessing'!filename	^ self attributeNamed: #filename! !!SmaCCParseNode methodsFor: 'accessing'!stopPosition	^ self attributeNamed: #stopPosition ifAbsentPut: [ self calculateStopPosition ]! !!SmaCCParseNode methodsFor: 'accessing'!parserClass	^ self class parserClass! !!SmaCCParseNode methodsFor: 'accessing'!removePositions	self removeAttributeNamed: #startPosition.	self removeAttributeNamed: #stopPosition! !!SmaCCParseNode methodsFor: 'accessing'!filename: aString	self attributeNamed: #filename put: aString! !!SmaCCParseNode methodsFor: 'accessing'!comments	^ self attributeNamed: #comments! !!SmaCCParseNode methodsFor: 'accessing'!sortedChildren	^ self children		asSortedCollection:			[ :a :b | 			| startA startB |			startA := a startPosition.			startB := b startPosition.			startA isNil				or:					[ b notNil						and:							[ startA class = startB class								ifTrue: [ startA < startB ]								ifFalse: [ startA class name < startB class name ] ] ] ]! !!SmaCCParseNode methodsFor: 'variables'!singularVariables	^ self singularVariableSelectors		inject: Set new		into:			[ :sum :each | 			sum				addAll: (self perform: each);				yourself ]! !!SmaCCParseNode methodsFor: 'variables'!compositeTokenVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!tokenVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!ignoredCompositeNodeVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!allVariableSelectors	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables #ignoredTokenVariables #ignoredCompositeTokenVariables #ignoredNodeVariables #ignoredCompositeNodeVariables #ignoredOtherVariables)! !!SmaCCParseNode methodsFor: 'variables'!ignoredCompositeTokenVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!compositeNodeVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!ignoredNodeVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!nodeVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!ignoredOtherVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!compositeVariables	^ self compositeVariableSelectors		inject: Set new		into:			[ :sum :each | 			sum				addAll: (self perform: each);				yourself ]! !!SmaCCParseNode methodsFor: 'variables'!compositeVariableSelectors	^ #(#compositeTokenVariables #compositeNodeVariables #ignoredCompositeTokenVariables #ignoredCompositeNodeVariables)! !!SmaCCParseNode methodsFor: 'variables'!otherVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!singularVariableSelectors	^ #(#tokenVariables #nodeVariables #ignoredTokenVariables #ignoredNodeVariables #otherVariables #ignoredOtherVariables)! !!SmaCCParseNode methodsFor: 'variables'!ignoredTokenVariables	^ #()! !!SmaCCParseNode methodsFor: 'variables'!variableSelectors	^ #(#tokenVariables #compositeTokenVariables #nodeVariables #compositeNodeVariables #otherVariables)! !!SmaCCParseNode methodsFor: 'matching'!matchCollectionVariables: aCollection to: aSmaCCParseNode inContext: aDictionary	^ aCollection		allSatisfy:			[ :each | 			self				matchCollection: (self perform: each)				to: (aSmaCCParseNode perform: each)				inContext: aDictionary ]! !!SmaCCParseNode methodsFor: 'matching'!matchVariables: aCollection to: aSmaCCParseNode inContext: aDictionary	^ aCollection		allSatisfy:			[ :each | 			| myValue otherValue |			myValue := self perform: each.			otherValue := aSmaCCParseNode perform: each.			myValue isNil				ifTrue: [ otherValue isNil ]				ifFalse: [ myValue match: otherValue inContext: aDictionary ] ]! !!SmaCCParseNode methodsFor: 'matching'!matchCollection: matchNodes index: matchIndex to: programNodes index: programIndex inContext: aDictionary	| node currentIndex currentDictionary nodes |	matchNodes size < matchIndex		ifTrue: [ ^ programNodes size < programIndex ].	node := matchNodes at: matchIndex.	node isListMatch		ifTrue:			[ currentIndex := programIndex - 1.			[ currentDictionary := aDictionary copy.			programNodes size < currentIndex				or:					[ (self						matchCollection: matchNodes						index: matchIndex + 1						to: programNodes						index: currentIndex + 1						inContext: currentDictionary)						and:							[ nodes := programNodes copyFrom: programIndex to: currentIndex.							(node match: nodes inContext: currentDictionary)								ifTrue:									[ currentDictionary										keysAndValuesDo: [ :key :value | aDictionary at: key put: value ].									^ true ].							false ] ] ] whileFalse: [ currentIndex := currentIndex + 1 ].			^ false ].	programNodes size < programIndex		ifTrue: [ ^ false ].	(node match: (programNodes at: programIndex) inContext: aDictionary)		ifFalse: [ ^ false ].	^ self		matchCollection: matchNodes		index: matchIndex + 1		to: programNodes		index: programIndex + 1		inContext: aDictionary! !!SmaCCParseNode methodsFor: 'matching'!copyInContext: aDictionary	| copy |	copy := self copy.	self tokenVariables		do:			[ :selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) copyInContext: aDictionary) ].	self nodeVariables		do:			[ :selector | 			copy				perform: (self convertToSetter: selector)				with: ((self perform: selector) copyInContext: aDictionary) ].	self compositeTokenVariables		do:			[ :selector | 			copy				perform: (self convertToSetter: selector)				with:					((self perform: selector)						collect: [ :each | each copyInContext: aDictionary ]) ].	self compositeNodeVariables		do:			[ :selector | 			copy				perform: (self convertToSetter: selector)				with:					((self perform: selector)						collect: [ :each | each copyInContext: aDictionary ]) ].	^ copy! !!SmaCCParseNode methodsFor: 'matching'!match: aSmaCCParseNode inContext: aDictionary	self class = aSmaCCParseNode class		ifFalse: [ ^ false ].	(self		matchVariables: self tokenVariables		to: aSmaCCParseNode		inContext: aDictionary)		ifFalse: [ ^ false ].	(self		matchVariables: self nodeVariables		to: aSmaCCParseNode		inContext: aDictionary)		ifFalse: [ ^ false ].	(self		matchCollectionVariables: self compositeTokenVariables		to: aSmaCCParseNode		inContext: aDictionary)		ifFalse: [ ^ false ].	^ self		matchCollectionVariables: self compositeNodeVariables		to: aSmaCCParseNode		inContext: aDictionary! !!SmaCCParseNode methodsFor: 'matching'!matchCollection: receiverCollection to: argumentCollection inContext: aDictionary	^ self		matchCollection: receiverCollection		index: 1		to: argumentCollection		index: 1		inContext: aDictionary! !!SmaCCParseNode methodsFor: 'matching'!convertToSetter: selector	^ (selector , ':') asSymbol! !!SmaCCParseNode methodsFor: 'tokens'!allTokensMatching: aSmaCCToken	| tokens |	tokens := OrderedCollection new.	self		allNodesDo: [ :each |  ]		andTokensDo: [ :each | 			each = aSmaCCToken				ifTrue: [ tokens add: each ] ]		includeErrors: true.	^ tokens! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstToken: aSmaCCToken to: aCollection	aSmaCCToken isNil		ifTrue: [ ^ self ].	aCollection addFirst: aSmaCCToken! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstObjects: addCollection to: aCollection	addCollection isNil		ifTrue: [ ^ self ].	addCollection		reverseDo: [ :each | self addFirstObject: each to: aCollection ]! !!SmaCCParseNode methodsFor: 'collection handling'!setParents: aCollection to: anObject	aCollection isNil		ifTrue: [ ^ self ].	aCollection do: [ :each | each parent: anObject ]! !!SmaCCParseNode methodsFor: 'collection handling'!addObjects: addCollection to: aCollection	addCollection isNil		ifTrue: [ ^ self ].	addCollection do: [ :each | self addObject: each to: aCollection ]! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstObject: anObject to: aCollection	anObject isNil		ifTrue: [ ^ self ].	aCollection addFirst: anObject.	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ anObject parent: self ]! !!SmaCCParseNode methodsFor: 'collection handling'!addToken: aSmaCCToken to: aCollection	aSmaCCToken isNil		ifTrue: [ ^ self ].	aCollection add: aSmaCCToken! !!SmaCCParseNode methodsFor: 'collection handling'!addNodes: aSmaCCParseNodeCollection to: aCollection	aSmaCCParseNodeCollection isNil		ifTrue: [ ^ self ].	aSmaCCParseNodeCollection		do: [ :each | self addNode: each to: aCollection ]! !!SmaCCParseNode methodsFor: 'collection handling'!addTokens: aSmaCCTokenCollection to: aCollection	aSmaCCTokenCollection isNil		ifTrue: [ ^ self ].	aCollection addAll: aSmaCCTokenCollection! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstTokens: aSmaCCTokenCollection to: aCollection	aSmaCCTokenCollection isNil		ifTrue: [ ^ self ].	aCollection addAllFirst: aSmaCCTokenCollection! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstNode: aSmaCCParseNode to: aCollection	aSmaCCParseNode isNil		ifTrue: [ ^ self ].	aCollection addFirst: aSmaCCParseNode.	aSmaCCParseNode parent: self! !!SmaCCParseNode methodsFor: 'collection handling'!addNode: aSmaCCParseNode to: aCollection	aSmaCCParseNode isNil		ifTrue: [ ^ self ].	aCollection add: aSmaCCParseNode.	aSmaCCParseNode parent: self! !!SmaCCParseNode methodsFor: 'collection handling'!addFirstNodes: aSmaCCParseNodeCollection to: aCollection	aSmaCCParseNodeCollection isNil		ifTrue: [ ^ self ].	aSmaCCParseNodeCollection		reverseDo: [ :each | self addFirstNode: each to: aCollection ]! !!SmaCCParseNode methodsFor: 'collection handling'!addObject: anObject to: aCollection	anObject isNil		ifTrue: [ ^ self ].	aCollection add: anObject.	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ anObject parent: self ]! !!SmaCCParseNode methodsFor: 'accessing-attributes'!attributes	^ attributes ifNil: [ attributes := IdentityDictionary new ]! !!SmaCCParseNode methodsFor: 'accessing-attributes'!attributeNamed: aSymbol ifAbsentPut: aBlock	^ self attributes at: aSymbol ifAbsentPut: aBlock! !!SmaCCParseNode methodsFor: 'accessing-attributes'!attributeNamed: aSymbol	attributes isNil		ifTrue: [ ^ nil ].	^ attributes at: aSymbol ifAbsent: [ nil ]! !!SmaCCParseNode methodsFor: 'accessing-attributes'!removeAttributeNamed: aSymbol	attributes isNil		ifTrue: [ ^ self ].	attributes removeKey: aSymbol ifAbsent: [  ]! !!SmaCCParseNode methodsFor: 'accessing-attributes'!attributeNamed: aSymbol put: aValue	^ self attributes at: aSymbol put: aValue! !!SmaCCParseNode methodsFor: 'accessing-attributes'!attributeNamed: aSymbol ifAbsent: aBlock	^ self attributes at: aSymbol ifAbsent: aBlock! !!SmaCCParseNode methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	self topParent completeSource notNil ifTrue: [ 		aStream 			nextPut: $(;			nextPutAll: (self topParent completeSource copyFrom: self startPosition to: self stopPosition) asString;			nextPut: $) ]! !!SmaCCParseNode methodsFor: 'replacing'!replaceWith: aSmaCCParseNode	parent replace: self with: aSmaCCParseNode! !!SmaCCParseNode methodsFor: 'replacing'!replace: originalSmaCCParseNode with: newSmaCCParseNode	SmaCCParseNode instSize + 1 to: self class instSize do:		[ :i | 		| each |		each := self instVarAt: i.		each == originalSmaCCParseNode			ifTrue: [ self instVarAt: i put: newSmaCCParseNode ]			ifFalse:				[ (each isKindOf: SequenceableCollection)					ifTrue:						[ each							keysAndValuesDo:								[ :index :value | 								value == originalSmaCCParseNode									ifTrue: [ each at: index put: newSmaCCParseNode ] ] ] ] ].	self completeSource		ifNotNil:			[ :source | 			source				replaceFrom: originalSmaCCParseNode startPosition				to: originalSmaCCParseNode stopPosition				with: newSmaCCParseNode source ].	newSmaCCParseNode parent: self! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtParentsFor: aView	<gtView>	^ aView tree		priority: 30;		title: 'Parents';		items: [ {self} ];		children: [ :each | 			each parent isNil				ifTrue: [ #() ]				ifFalse: [ {each parent} ] ];		expandAll;		itemFormat: [ :each | each class name asRopedText glamorousRegularFontAndSize ];		send: [ :each | each value ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtSelectItemIn: aTree at: position	| treeNode nextNode |	aTree collapseAll.	nextNode := aTree viewModel itemAt: 1.	[ nextNode expand.	treeNode := nextNode.	nextNode := treeNode childrenNodes		detect: [ :each | 			(#(#nodes #tokens) includes: each value second)				ifTrue: [ each value last						anySatisfy:							[ :item | position between: item startPosition and: item stopPosition ] ]				ifFalse: [ (#(node token) includes: each value second)						and: [ position								between: each value last startPosition								and: each value last stopPosition ] ] ]		ifNone: [ nil ].	nextNode notNil ] whileTrue.	aTree selectOne: treeNode globalIndexInTree.	aTree children first scrollToPosition: treeNode globalIndexInTree! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtHookEditor: anEditor toTree: aTree	| highlighter highlightAttribute |	highlighter := GtTextNodeHighlighter		on: anEditor		source: self topParent completeSource asString.	highlightAttribute := BlTextUnderlineAttribute new		beNotOverwritableByStyler;		paint: BrGlamorousColors primaryBorderColor.	aTree		when: BrSelectionChanged		do: [ :anEvent | 			aTree				selectedNodeDo: [ :aNode | 					| item |					item := aNode value last.					((item isKindOf: SmaCCParseNode)						or: [ item isKindOf: SmaCCToken ])						ifTrue: [ anEditor editor text								clearAttributes: [ :attr | attr == highlightAttribute ].							highlighter highlight: item with: highlightAttribute.							self gtScrollToPosition: item startPosition inEditor: anEditor ] ] ].	anEditor editor		when: BrTextEditorCursorMovedEvent		do: [ :event | 			| position |			anEditor cursors do: [ :each | position := each position ].			position notNil				ifTrue: [ self						gtSelectItemIn: aTree						at: (highlighter stringPositionFor: position) ] ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtAttributesFor: aView	<gtView>	(attributes notNil and: [ attributes notEmpty ])		ifFalse: [ ^ aView empty ].	^ aView columnedList		priority: 40;		title: 'Attributes';		items: [ attributes keys asSortedCollection ];		column: 'Name' format: [:each | each ];		column: 'Value' format: [ :each | (self attributeNamed: each) printString ];		send: [:each | self attributeNamed: each ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtExploreFor: aView	<gtView>	| topParent |	topParent := self topParent.	topParent completeSource isNil		ifTrue: [ ^ aView empty ].	^ aView explicit		priority: 5;		title: 'Explore';		stencil: [ | element editor tree |			element := BlElement new.			element layout: BlLinearLayout horizontal.			element				constraintsDo: [ :c | 					c vertical matchParent.					c horizontal matchParent ].			editor := self				gtSourceEditorWithHighlight: BrGlamorousColors lightBorderColor.			editor				look: BrShadowLook;				background: Color white;				margin: (BlInsets all: 10).			element addChild: editor.			(topParent gtTreeFor: GtPhlowView empty)				asElementDo: [ :e | tree := e ].			tree				look: BrShadowLook;				background: Color white;				margin: (BlInsets all: 10).			element addChild: tree.			topParent gtHookEditor: editor toTree: tree children last.			element ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtSourceFor: aView	<gtView>	self topParent completeSource isNil		ifTrue: [ ^ aView empty ].	^ aView explicit		priority: 10;		title: 'Source';		stencil: [ self				gtSourceEditorWithHighlight: BrGlamorousColors primaryBorderColor ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtTreeFor: aView	<gtView>	^ aView columnedTree		priority: 20;		title: 'Tree';		items: [ {{'self'.			#node.			self}} ];		children: [ :each | self gtChildrenOf: each ];		column: 'Variable' format: [ :each | each value first ];		column: 'Type'			format: [ :each | 			(each value at: 2) = #node				ifTrue: [ each value last class name ]				ifFalse: [ '' ] ];		send: [ :each | 			each notNil				ifTrue: [ each last ] ]! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtSourceEditorWithHighlight: aColor	| source editor |	source := BlRopedRawText		string: self topParent completeSource asString.	self parserClass		ifNotNil: [ :class | 			class gtStyler				ifNotNil: [ :styler | styler style: source using: self topParent ] ].	(source from: self startPosition to: self stopPosition)		attributes:			{(BlTextUnderlineAttribute new				beNotOverwritableByStyler;				paint: BrGlamorousColors lightBorderColor)}.	editor := BrEditor new		text: source;		look: BrGlamorousCodeEditorLook new.	self gtScrollToPosition: self startPosition inEditor: editor.	^ editor! !!SmaCCParseNode methodsFor: '*GT4SmaCC-Inspector'!gtScrollToPosition: index inEditor: editor	editor		scrollToPosition:			(self topParent completeSource asString				lineNumberCorrespondingToIndex: index)! !!SmaCCParseNode methodsFor: 'visitor-double dispatching'!acceptVisitor: aSmaCCParseNodeVisitor	^ aSmaCCParseNodeVisitor visitSmaCCParseNode: self! !!SmaCCParseNode methodsFor: 'testing'!isListMatch	^ false! !!SmaCCParseNode methodsFor: 'testing'!isErrorNode	^ false! !!SmaCCParseNode methodsFor: 'testing'!hasParentOfType: aSmaCCParseNodeClass	(parent isKindOf: aSmaCCParseNodeClass)		ifTrue: [ ^ true ].	^ parent notNil and: [ parent hasParentOfType: aSmaCCParseNodeClass ]! !!SmaCCParseNode methodsFor: 'testing'!hasDescendant: aSmaCCNode	^ aSmaCCNode isDescendantFrom: self! !!SmaCCParseNode methodsFor: 'testing'!isDescendantFrom: aSmaCCNode	| current |	current := self.	[ current isNil or: [ current == aSmaCCNode ] ]		whileFalse: [ current := current parent ].	^ current notNil! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtCollectionItems: aCollection type: aSymbol	^ (1 to: aCollection size) collect: [ :i | Array with: i printString with: aSymbol with: (aCollection at: i) ]! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtChildrenOf: each	^ (each at: 2) = #node		ifTrue: [ each last gtInspectorItems ]		ifFalse: [ (each at: 2) = #nodes				ifTrue: [ self gtCollectionItems: each last type: #node ]				ifFalse: [ (each at: 2) = #tokens						ifTrue: [ self gtCollectionItems: each last type: #token ]						ifFalse: [ #() ] ] ]! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorItems	| items |	items := OrderedCollection new.	self class allInstVarNames		do:			[ :each | 			| selector tag value |			selector := each asSymbol.			(value := self perform: selector) notNil				ifTrue:					[ tag := nil.					((self otherVariables includes: selector) or: [ self ignoredOtherVariables includes: selector ])						ifTrue: [ tag := #other ].					((self nodeVariables includes: selector) or: [ self ignoredNodeVariables includes: selector ])						ifTrue: [ tag := #node ].					(((self compositeNodeVariables includes: selector) or: [ self ignoredCompositeNodeVariables includes: selector ])						and: [ value notEmpty ])						ifTrue: [ tag := #nodes ].					((self tokenVariables includes: selector) or: [ self ignoredTokenVariables includes: selector ])						ifTrue: [ tag := #token ].					(((self compositeTokenVariables includes: selector) or: [ self ignoredCompositeTokenVariables includes: selector ])						and: [ value notEmpty ])						ifTrue: [ tag := #tokens ].					tag notNil						ifTrue: [ items add: (Array with: each with: tag with: value) ] ] ].	^ items! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!debugLabelForChild: anObject	self singularVariableSelectors		do: [ :each | 			(self perform: each)				do: [ :sel | 					(self perform: sel) == anObject						ifTrue: [ ^ sel ] ] ].	self compositeVariableSelectors		do: [ :each | 			(self perform: each)				do: [ :sel | 					| index |					index := (self perform: sel) identityIndexOf: anObject.					index > 0						ifTrue: [ ^ index printString , ': ' , sel ] ] ].	^ anObject class name! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorTreeIn: aComposite	<gtInspectorPresentationOrder: 30>	aComposite tabulator		with: [ :browser | 			browser title: 'Tree'.			browser row: #variables.			browser transmit				from: #variables;				toOutsidePort: #selection;				transformed: [ :each | each ifNotNil: [ each last ] ].			browser transmit				to: #variables;				andShow: [ :composite | 					composite table						display: [ Array with: (Array with: 'self' with: #node with: self) ];						children: [ :each | self gtChildrenOf: each ];						format: [ :each | each first ];						column: 'Variable' evaluated: [ :each | each first ];						column: 'Type'							evaluated: [ :each | 							(each at: 2) = #node								ifTrue: [ each last class name ]								ifFalse: [ '' ] ]							tags: [ :each | Array with: (each at: 2) ] ] ]! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!debugMatch: aNode	| process done value match context arg |	match := SmaCCDebugMatchResult forPattern: self.	done := false.	process := [ [ value := self match: aNode inContext: Dictionary new ]		ensure: [ done := true ] ] newProcess.	[ [ done ]		whileFalse: [ context := process suspendedContext.			(context isBlockContext not and: [ context method selector = #match:inContext: ])				ifTrue: [ arg := context arguments at: 1 ].			process step: process suspendedContext.			(context isDead and: [ context isBlockContext not and: [ context method selector = #match:inContext: ] ])				ifTrue: [ match processMatchFor: context receiver and: arg result: process suspendedContext top ] ] ]		ensure: [ process terminate ].	^ match! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtAttributesIn: aComposite	<gtInspectorPresentationOrder: 35>	| tabulator |	(attributes notNil and: [ attributes notEmpty ])		ifFalse: [ ^ self ].	tabulator := aComposite tabulator.	tabulator		title: 'Attributes';		row: #attributes.	tabulator transmit		to: #attributes;		andShow: [ :pres | 			pres fastTable				display: [ attributes keys asSortedCollection ];				column: 'Name' evaluated: [ :each | each ];				column: 'Value' evaluated: [ :each | self attributeNamed: each ifAbsent: [  ] ] ].	tabulator transmit		toOutsidePort: #selection;		from: #attributes port: #selection;		transformed: [ :name | self attributeNamed: name ifAbsent: [  ] ]! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtParentsIn: aComposite	<gtInspectorPresentationOrder: 34>	parent isNil		ifTrue: [ ^ self ].	aComposite tree		title: 'Parents';		allExpanded;		display: [ Array with: self ];		format: [ :each | each class name ];		children: [ :each | 			(each notNil and: [ each parent notNil ])				ifTrue: [ Array with: each parent ] ]! !!SmaCCParseNode methodsFor: '*SmaCC_Debugging_Support'!gtInspectorSourceIn: aComposite	<gtInspectorPresentationOrder: 40>	aComposite text		title: 'Source';		withLineNumbers: true;		display: [ self topParent completeSource ];		initialize:				[ :textPresentation | textPresentation selectionInterval: self sourceInterval ]! !!SmaCCParseNode methodsFor: 'comparing'!= anObject	^ self == anObject		or:			[ self class = anObject class				and:					[ self variableSelectors						allSatisfy:							[ :symbol | 							(self perform: symbol)								allSatisfy: [ :each | (self perform: each) = (anObject perform: each) ] ] ] ]! !!SmaCCParseNode methodsFor: 'comparing'!hash	^ self variableSelectors		inject: self class hash		into:			[ :sum :symbol | 			(self perform: symbol)				inject: sum				into:					[ :hash :each | 					| newHash |					newHash := hash bitXor: (self perform: each) hash.					((newHash bitShift: 1) bitAnd: SmallInteger maxVal)						bitXor: (newHash bitShift: -29) ] ]! !!SmaCCParseNode methodsFor: '*Famix-CPP'!isStructure	^ false! !!SmaCCParseNode methodsFor: '*Famix-CPP'!additionalCyclomaticComplexityEdges	^ 0! !!SmaCCParseNode methodsFor: '*Famix-CPP'!isCPPClass	^ false! !!SmaCCParseNode methodsFor: '*Famix-CPP'!isEnum	^ false! !!SmaCCParseNode methodsFor: '*Famix-CPP'!isUnion	^ false! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!gtHasLinks	^ false! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!preprocessedStopPositionFor: anInteger	^ (self topParent attributeNamed: #preprocessedFile)		ifNotNil: [ :file | file stopPositionFor: anInteger ]		ifNil: [ anInteger ]! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!gtLinksFor: anEntity do: aBlock	! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!preprocessedStartPositionFor: anInteger	^ (self topParent attributeNamed: #preprocessedFile)		ifNotNil: [ :file | file startPositionFor: anInteger ]		ifNil: [ anInteger ]! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!preprocessedStartPosition	^ self preprocessedStartPositionFor: self startPosition! !!SmaCCParseNode methodsFor: '*GToolkit4Famix3'!preprocessedStopPosition	^ self preprocessedStopPositionFor: self stopPosition! !!SmaCCParseNode methodsFor: 'private'!calculateStartPosition	"Hackish way to get the minimum for all nodes. You might want to override to get a better implementation."	| doBlock min |	min := SmallInteger maxVal.	doBlock := [ :each | each startPosition ifNotNil: [ :pos | min := min min: pos ] ].	self nodesDo: doBlock andTokensDo: doBlock.	^ min! !!SmaCCParseNode methodsFor: 'private'!calculateStopPosition	"Hackish way to get the maximum for all nodes. You might want to override to get a better implementation."	| doBlock max |	max := 0.	doBlock := [ :each | each stopPosition ifNotNil: [ :pos | max := max max: pos ] ].	self nodesDo: doBlock andTokensDo: doBlock.	^ max! !!SmaCCParseNode methodsFor: 'private'!safePerform: aSymbol	^ (self respondsTo: aSymbol)		ifTrue: [ self perform: aSymbol ]		ifFalse: [ nil ]! !!SmaCCParseNode methodsFor: 'source'!source	^ self completeSource		ifNotNil:			[ :value | (value copyFrom: self startPosition to: self stopPosition) asString ]! !!SmaCCParseNode methodsFor: 'source'!insertSourceBefore: beginString andAfter: endString	self		insertSourceBefore: beginString;		insertSourceAfter: endString! !!SmaCCParseNode methodsFor: 'source'!completeSource: aString	^ parent isNil		ifTrue:			[ (Smalltalk at: #SmaCCString ifAbsent: [ nil ])				ifNotNil:					[ :stringClass | self attributeNamed: #source put: (stringClass on: aString) ] ]		ifFalse: [ parent completeSource: aString ]! !!SmaCCParseNode methodsFor: 'source'!completeSource	^ parent isNil		ifTrue: [ self attributeNamed: #source ]		ifFalse: [ parent completeSource ]! !!SmaCCParseNode methodsFor: 'source'!insertSourceBefore: aString	self completeSource insert: aString at: self startPosition! !!SmaCCParseNode methodsFor: 'source'!replaceWithSource: aString	^ self completeSource		replaceFrom: self startPosition		to: self stopPosition		with: aString! !!SmaCCParseNode methodsFor: 'source'!deleteToken: aSmaCCToken	self completeSource		deleteFrom: aSmaCCToken startPosition		to: aSmaCCToken stopPosition! !!SmaCCParseNode methodsFor: 'source'!deleteSource	self completeSource		deleteFrom: self startPosition		to: self stopPosition! !!SmaCCParseNode methodsFor: 'source'!insertSourceAfter: aString	self completeSource insert: aString at: self stopPosition + 1! !!SmaCCParseNode methodsFor: 'source'!replaceToken: aSmaCCToken withSource: aString	self completeSource		replaceFrom: aSmaCCToken startPosition		to: aSmaCCToken stopPosition		with: aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParseNode class	instanceVariableNames: ''!!SmaCCParseNode class methodsFor: 'accessing'!collectionVariableIn: aSmaCCParseNode collectionGetter: aSymbol variableGetter: varSymbol	(aSmaCCParseNode respondsTo: aSymbol)		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].	(aSmaCCParseNode respondsTo: varSymbol)		ifTrue: [ ^ Array with: (aSmaCCParseNode perform: varSymbol) ].	^ #()! !!SmaCCParseNode class methodsFor: 'accessing'!parserClass	"Return the parser class that likely created this node"	| possibleClasses classNames topNodeClass |	self == SmaCCParseNode		ifTrue: [ ^ nil ].	topNodeClass := self withAllSuperclasses		detect: [ :each | each superclass = SmaCCParseNode ].	classNames := (topNodeClass withAllSubclasses collect: #name) asSet.	possibleClasses := SmaCCParser withAllSubclasses		select: [ :each | 			(each class includesSelector: #symbolTypes)				and: [ each symbolTypes						anySatisfy: [ :clsName | classNames includes: clsName ] ] ].	possibleClasses size = 1		ifTrue: [ ^ possibleClasses first ].	^ nil! !!SmaCCParseNode class methodsFor: 'accessing'!variableIn: aSmaCCParseNode getter: aSymbol	(aSmaCCParseNode respondsTo: aSymbol)		ifTrue: [ ^ aSmaCCParseNode perform: aSymbol ].	^ nil! !!SmaCCParseNode class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSimple	<gtExample>	^ self new! !SmaCCParseNode subclass: #SmaCCErrorNode	instanceVariableNames: 'stackContents dismissedTokens errorToken'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCErrorNode commentStamp: '' prior: 0!SmaCCError is a special node that is used when encountering an error during parsing and the parser uses the special "error" keyword in the grammar. When an error occurs the parser searches for a location on the stack that will shift the "error". Instance Variables:	stackContents	<Array of: Object>	the objects that had to be popped off the node stack to be able to shift the error	dismissedTokens	<OrderedCollection of: Object>	the token objects that needed to be ignored to be able to resume parsing	errorToken	<SmaCCToken>	the token that started the error handling. This token may also be in the dismissedTokens or it may be used in some other node created after handling the error!!SmaCCErrorNode methodsFor: 'testing'!isErrorNode	^ true! !!SmaCCErrorNode methodsFor: 'visitor-double dispatching'!acceptVisitor: aSmaCCParseNodeVisitor	^ aSmaCCParseNodeVisitor visitSmaCCError: self! !!SmaCCErrorNode methodsFor: 'private'!errorComponentsDo: aBlock	self nodesAndTokensIn: stackContents do: aBlock.	dismissedTokens do: aBlock! !!SmaCCErrorNode methodsFor: 'private'!calculateStartPosition	| min |	min := SmallInteger maxVal.	self errorComponentsDo: [ :each | each startPosition ifNotNil: [ :pos | min := min min: pos ] ].	min = SmallInteger maxVal		ifTrue: [ min := errorToken startPosition ].	^ min! !!SmaCCErrorNode methodsFor: 'private'!calculateStopPosition	| max |	max := 0.	self errorComponentsDo: [ :each | each stopPosition ifNotNil: [ :pos | max := max max: pos ] ].	max = 0		ifTrue: [ max := errorToken startPosition ].	^ max! !!SmaCCErrorNode methodsFor: 'private'!assignParents: anObject	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ anObject parent: self ].	(anObject isKindOf: Collection)		ifTrue: [ anObject do: [ :each | self assignParents: each ] ]! !!SmaCCErrorNode methodsFor: 'private'!nodesAndTokensIn: anObject do: aBlock	anObject isCollection		ifTrue: [ anObject do: [ :each | self nodesAndTokensIn: each do: aBlock ] ]		ifFalse: [ ((anObject isKindOf: SmaCCParseNode) or: [ anObject isKindOf: SmaCCToken ])				ifTrue: [ aBlock value: anObject ] ]! !!SmaCCErrorNode methodsFor: 'iterating'!nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean	super nodesDo: nodeBlock andTokensDo: tokenBlock includeErrors: aBoolean.	aBoolean		ifFalse: [ ^ self ].	self		errorComponentsDo: [ :each | 			(nodeBlock notNil and: [ each isKindOf: SmaCCParseNode ])				ifTrue: [ nodeBlock value: each ].			(tokenBlock notNil and: [ each isKindOf: SmaCCToken ])				ifTrue: [ tokenBlock value: each ] ]! !!SmaCCErrorNode methodsFor: 'errors'!doesNotUnderstand: aMessage	"Hack to handle reduce action steps that add parens (or other items) to pulled up nodes. 	Probably should validate that we are inside a reduce action."	aMessage arguments isEmpty		ifTrue: [ ^ (self attributeNamed: #nodeProperties ifAbsentPut: [ Dictionary new ])				at: aMessage selector				ifAbsentPut: [ OrderedCollection new ] ].	super doesNotUnderstand: aMessage! !!SmaCCErrorNode methodsFor: 'accessing'!stackContents	^ stackContents! !!SmaCCErrorNode methodsFor: 'accessing'!errorToken	^ errorToken! !!SmaCCErrorNode methodsFor: 'accessing'!dismissedTokens	^ dismissedTokens! !!SmaCCErrorNode methodsFor: 'accessing'!stackContents: aCollection	stackContents := aCollection.	self assignParents: aCollection! !!SmaCCErrorNode methodsFor: 'accessing'!dismissedTokens: tokenCollection	dismissedTokens := tokenCollection! !!SmaCCErrorNode methodsFor: 'accessing'!errorToken: smaccToken	errorToken := smaccToken! !Object subclass: #SmaCCParseNodeVisitor	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCParseNodeVisitor commentStamp: '' prior: 0!SmaCCParseNodeVisitor is an abstract visitor for the SmaCC parse trees.!!SmaCCParseNodeVisitor methodsFor: 'visiting'!visitSmaCCError: aSmaCCError	^ self visitSmaCCParseNode: aSmaCCError! !!SmaCCParseNodeVisitor methodsFor: 'visiting'!accept: anObject	(anObject isKindOf: SmaCCParseNode)		ifTrue: [ ^ self acceptNode: anObject ].	(anObject isKindOf: Collection)		ifTrue: [ ^ self acceptNodes: anObject ].	^ anObject! !!SmaCCParseNodeVisitor methodsFor: 'visiting'!visitSmaCCParseNode: aSmaCCParseNode	self acceptNodes: aSmaCCParseNode sortedChildren.	^ aSmaCCParseNode! !!SmaCCParseNodeVisitor methodsFor: 'visiting'!acceptNodes: aCollection	aCollection do: [ :each | self acceptNode: each ].	^ aCollection! !!SmaCCParseNodeVisitor methodsFor: 'visiting'!acceptNode: aSmaCCParseNode	aSmaCCParseNode isNil		ifTrue: [ ^ nil ].	^ aSmaCCParseNode acceptVisitor: self! !Object subclass: #SmaCCParser	instanceVariableNames: 'scanner currentToken errorToken stateStack nodeStack errorHandler'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCParser commentStamp: '' prior: 0!SmaCCParser is an abstract class that defines most of the parsing actions. Subclasses will define methods that specify their transitions and reduction actions. These are normally defined automatically when compiling the parser.Subclasses must implement the following messages:	accessing		reduceTable		transitionTableInstance Variables:	currentToken	<SmaCCToken>	the token last returned by the scanner that has not been shifted (reduce actions leave the current token alone)	errorToken	<SmaCCToken>	the token where a parse error occurred	nodeStack	<OrderedCollection of: Object>	collection of items on stack. These items are specific to the parser and can be any object. 	scanner	<SmaCCScanner>	our scanner	stateStack	<OrderedCollection of: Integer>	the stack of states for our parser (standard LR state stack)!!SmaCCParser methodsFor: 'private-ast'!addAllFirst: origCollection to: aCollection	origCollection isNil ifTrue: [^self].	origCollection reverseDo: [:each | each notNil ifTrue: [aCollection addFirst: each]]! !!SmaCCParser methodsFor: 'private-ast'!addFirst: anObject to: aCollection	anObject isNil ifTrue: [^self].	aCollection addFirst: anObject! !!SmaCCParser methodsFor: 'private-ast'!addAll: origCollection to: aCollection	origCollection isNil		ifTrue: [ ^ self ].	origCollection		do: [ :each | 			each notNil				ifTrue: [ aCollection add: each ] ]! !!SmaCCParser methodsFor: 'private-ast'!add: anObject to: aCollection	anObject isNil		ifTrue: [ ^ self ].	aCollection add: anObject! !!SmaCCParser methodsFor: 'initialize-release'!initialize	super initialize.	nodeStack := OrderedCollection new.	errorHandler := SmaCCNoErrorHandler on: self! !!SmaCCParser methodsFor: 'initialize-release'!createDefaultErrorHandlers	(self hasStateThatShifts: self errorTokenId)		ifTrue: [ errorHandler := SmaCCSpecificErrorNodeHandler on: self ]		ifFalse: [ self hasNodeTypes				ifTrue: [ errorHandler := SmaCCDefaultErrorNodeHandler on: self ] ]! !!SmaCCParser methodsFor: 'initialize-release'!scanner: aScanner	scanner := aScanner! !!SmaCCParser methodsFor: 'initialize-release'!setDefaultStartingStateIfNone	stateStack isNil		ifTrue: [ self setStartingState: self class defaultStartingState ]! !!SmaCCParser methodsFor: 'initialize-release'!setStartingState: startingState	stateStack := OrderedCollection with: startingState! !!SmaCCParser methodsFor: 'error handling'!reportError: anInteger	self		reportErrorMessage:			(anInteger = 0				ifTrue: [ 'Token not expected' ]				ifFalse: [ self errorTable at: anInteger ])! !!SmaCCParser methodsFor: 'error handling'!dismissErrorToken	| token |	token := currentToken.	currentToken := nil.	self getNextToken.	^ token! !!SmaCCParser methodsFor: 'error handling'!reportErrorMessage: aString	self reportErrorMessage: aString resumable: false! !!SmaCCParser methodsFor: 'error handling'!errorToken: aSmaCCToken	errorToken notNil		ifTrue: [ ^ self ].	errorToken := aSmaCCToken! !!SmaCCParser methodsFor: 'error handling'!handleError: anInteger	^ errorHandler handleError: anInteger! !!SmaCCParser methodsFor: 'error handling'!reportErrorMessage: aString resumable: aBoolean	SmaCCParserError new		isResumable: aBoolean;		messageText: aString;		tag: self;		signal! !!SmaCCParser methodsFor: 'error handling'!actionsForState: stateIndex and: aSymbolIndex	^ Array with: (self actionForState: stateIndex and: aSymbolIndex)! !!SmaCCParser methodsFor: 'error handling'!checkForErrors	"If we have an error correction installed, we might have handled the errors. If we did, we may not 	want to return the result. Raise an error with the location of the initial error. If we want the result,	we can resume the exception."	errorToken isNil		ifTrue: [ ^ self ].	currentToken := errorToken.	self reportErrorMessage: 'Token not expected' resumable: true! !!SmaCCParser methodsFor: 'error handling'!dismissStackTopForErrorRecovery: anInteger	| stackContents |	stackContents := Array new: anInteger.	anInteger to: 1 by: -1 do: [ :i | 		stateStack removeLast.		stackContents at: i put: nodeStack removeLast ].	^ stackContents! !!SmaCCParser methodsFor: 'error handling'!willAccept: potentialStateStack	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last and: self emptySymbolTokenId.	action := compoundAction bitAnd: self actionMask.	action == self acceptAction		ifTrue: [ ^ true ].	action == self reduceAction		ifTrue: [ reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [ potentialStateStack removeLast ].			potentialStateStack add: ((self actionForState: potentialStateStack last and: (reduceEntry at: 1)) bitShift: -2).			^ self willAccept: potentialStateStack ].	^ false! !!SmaCCParser methodsFor: 'error handling'!willShift: potentialStateStack	| action compoundAction reduceEntry size |	compoundAction := self actionForState: potentialStateStack last and: currentToken ids first.	action := compoundAction bitAnd: self actionMask.	action == self shiftAction		ifTrue: [ ^ true ].	action == self reduceAction		ifTrue: [ reduceEntry := self reduceTable at: (compoundAction bitShift: -2).			size := reduceEntry at: 2.			size timesRepeat: [ potentialStateStack removeLast ].			potentialStateStack add: ((self actionForState: potentialStateStack last and: (reduceEntry at: 1)) bitShift: -2).			^ self willShift: potentialStateStack ].	^ false! !!SmaCCParser methodsFor: 'error handling'!errorSymbolShiftActionsForState: stateIndex	| action actions |	actions := self actionsForState: stateIndex and: self errorTokenId.	action := actions		detect: [ :act | (act bitAnd: self actionMask) = self shiftAction ]		ifNone: [ 0 ].	^ (action bitAnd: self actionMask) = self shiftAction		ifTrue: [ action bitShift: -2 ]		ifFalse: [ 0 ]! !!SmaCCParser methodsFor: 'accessing'!position: anInteger	scanner setPosition: anInteger! !!SmaCCParser methodsFor: 'accessing'!scope	^ scanner scope! !!SmaCCParser methodsFor: 'accessing'!errorTokenId	^ scanner errorTokenId! !!SmaCCParser methodsFor: 'accessing'!errorTable	^ #()! !!SmaCCParser methodsFor: 'accessing'!position	^ currentToken isNil		ifTrue: [ scanner position ]		ifFalse: [ currentToken startPosition ]! !!SmaCCParser methodsFor: 'accessing'!symbolTypes	^ self class symbolTypes! !!SmaCCParser methodsFor: 'accessing'!scanner	^ scanner! !!SmaCCParser methodsFor: 'accessing'!symbolNames	^ self class symbolNames! !!SmaCCParser methodsFor: 'accessing'!scope: aSymbol	scanner scope: aSymbol! !!SmaCCParser methodsFor: 'accessing'!emptySymbolTokenId	^ scanner emptySymbolTokenId! !!SmaCCParser methodsFor: 'accessing'!errorToken	^ errorToken! !!SmaCCParser methodsFor: 'accessing'!parse	| result |	self setDefaultStartingStateIfNone.	self performParsingLoop.	result := nodeStack last.	(result respondsTo: #comments:)		ifTrue: [ result comments: scanner comments ].	^ result! !!SmaCCParser methodsFor: 'accessing'!reduceTable	^ self class reduceTable! !!SmaCCParser methodsFor: 'accessing'!transitionTable	^ self class transitionTable! !!SmaCCParser methodsFor: 'private'!stateStack	^ stateStack! !!SmaCCParser methodsFor: 'private'!peekNextToken	| token position lookahead |	token := currentToken.	currentToken := nil.	position := scanner position.	self getNextToken.	lookahead := currentToken.	self position: position.	currentToken := token.	^ lookahead! !!SmaCCParser methodsFor: 'private'!binarySearchIn: aRow for: aSymbolIndex size: step	| start mid length high low midItem stop |	high := aSymbolIndex bitShift: -8.	low := aSymbolIndex bitAnd: 16rFF.	start := 4.	stop := aRow size - 1.	length := (stop - start) // step.	[ length > 4 ]		whileTrue:			[ length := length bitShift: -1.			mid := length * step + start.			midItem := aRow at: mid.			((midItem == high and: [ (aRow at: mid + 1) <= low ])				or: [ midItem < high ])				ifTrue: [ start := mid ]				ifFalse: [ stop := mid ] ].	[ start <= stop ]		whileTrue:			[ ((aRow at: start) == high and: [ (aRow at: start + 1) == low ])				ifTrue: [ ^ start ].			start := start + step ].	^ 0! !!SmaCCParser methodsFor: 'private'!performReduceEntry: entryArray with: items	| symbol |	symbol := entryArray at: 3.	^ symbol last == $:		ifTrue: [ self perform: symbol with: items ]		ifFalse: [ self perform: symbol ]! !!SmaCCParser methodsFor: 'private'!ambiguousTransitions	^ self class ambiguousTransitions! !!SmaCCParser methodsFor: 'private'!currentToken	^ currentToken! !!SmaCCParser methodsFor: 'private'!getNextToken	currentToken isNil		ifTrue: [ currentToken := scanner next ]! !!SmaCCParser methodsFor: 'private'!popNodeStack	^ nodeStack removeLast! !!SmaCCParser methodsFor: 'private'!currentState	^ stateStack last! !!SmaCCParser methodsFor: 'private'!dismissToken	currentToken := nil! !!SmaCCParser methodsFor: 'private'!performParsingLoop	| action |	[ self getNextToken.	action := self actionForCurrentToken.	action = self acceptAction ]		whileFalse: [ self performAction: action ].	self checkForErrors! !!SmaCCParser methodsFor: 'private'!nodeStack	^ nodeStack! !!SmaCCParser methodsFor: 'testing'!isNodeType: aSymbol	^ (Smalltalk at: aSymbol ifAbsent: [ Object ]) includesBehavior: SmaCCParseNode! !!SmaCCParser methodsFor: 'testing'!hasNodeTypes	^ self symbolTypes anySatisfy: [ :each | self isNodeType: each ]! !!SmaCCParser methodsFor: 'testing'!hasStateThatShifts: symbolIndex	1 to: self transitionTable size do: [ :i | 		((self actionsForState: i and: symbolIndex) anySatisfy: [ :action | (action bitAnd: self actionMask) = self shiftAction ])			ifTrue: [ ^ true ] ].	^ false! !!SmaCCParser methodsFor: 'testing'!isEOFToken	^ currentToken ids first = self emptySymbolTokenId! !!SmaCCParser methodsFor: 'testing'!tryAllTokens	^ false! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolForTransitionFrom: fromState to: toState	| id |	id := self symbolIdForTransitionFrom: fromState to: toState.	^ self symbolNameFor: id! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!roassalViewForStack: stack	| shape nodes es root view |	root := self graphForStack: stack.	nodes := root allNodes.	view := (Smalltalk at: #RTView) new.	shape := (Smalltalk at: #RTEllipse) new		color: Color white;		borderColor: Color black;		width: 25;		height: 25;		yourself.	view add: (shape elementOn: root).	shape := ((Smalltalk at: #RTRoundedBox) new		borderRadius: [ :n | 			('<"' includes: n name first)				ifTrue: [ 0 ]				ifFalse: [ 10 ] ];		color: Color white;		borderColor: [ :n | 			n success				ifTrue: [ Color green ]				ifFalse: [ n isFollowed						ifTrue: [ Color black ]						ifFalse: [ Color lightGray ] ] ];		yourself)		+			((Smalltalk at: #RTLabel) new				color: [ :n | 					n success						ifTrue: [ Color green ]						ifFalse: [ n isFollowed								ifTrue: [ Color black ]								ifFalse: [ Color lightGray ] ] ];				text: [ :n | n name ];				yourself).	shape allOfSameSizeWithPadding.	es := shape		elementsOn:			(nodes copy				remove: root;				yourself).	view addAll: es.	shape := (Smalltalk at: #RTMultiLine) new.	shape orthoHorizontal.	shape color: Color black.	shape attachPoint: (Smalltalk at: #RTHorizontalAttachPoint) instance.	(Smalltalk at: #RTEdgeBuilder) new		view: view;		objects: nodes;		shape: shape;		connectTo: [ :n | n followed ].	shape := (Smalltalk at: #RTMultiLine) new.	shape orthoHorizontal.	shape color: Color lightGray.	shape attachPoint: (Smalltalk at: #RTHorizontalAttachPoint) instance.	(Smalltalk at: #RTEdgeBuilder) new		view: view;		objects: nodes;		shape: shape;		connectToAll: [ :n | n directLinks ].	view elements @ ((Smalltalk at: #RTPopup) text: [ :n | n description ]).	view @ (Smalltalk at: #RTDraggableView).	self layout: view from: root position: 0 @ 0.	^ view! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!layout: aView from: aNode position: aPoint	| element bottom nextLeft horizontalGap verticalGap position |	horizontalGap := 20.	verticalGap := 3.	element := aView elementFromModel: aNode.	nextLeft := aPoint x + element width + horizontalGap.	bottom := aPoint y.	aNode followed notNil		ifTrue: [ bottom := (self layout: aView from: aNode followed position: nextLeft @ bottom) + verticalGap ].	(aNode directLinks asSortedCollection: [ :a :b | a name < b name ]) do: [ :each | bottom := (self layout: aView from: each position: nextLeft @ bottom) + verticalGap ].	bottom = aPoint y		ifTrue: [ bottom := bottom + element height + verticalGap ].	bottom := bottom - verticalGap.	bottom := bottom max: aPoint y + element height.	position := aPoint x @ ((bottom + aPoint y) / 2 - (element height / 2)).	(Smalltalk at: #RTLayoutTranslator) default translateTopLeftOf: element to: position.	^ bottom! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!isAcceptState: stateIndex	self		allActionsAndSymbolsForState: stateIndex		do: [ :action :symbol | 			action = self acceptAction				ifTrue: [ ^ true ] ].	^ false! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!graphForStack: aCollection	| id name next graphNodeStack returnTable |	graphNodeStack := OrderedCollection new.	graphNodeStack add: (SmaCCGraphNode named: '' state: aCollection first parser: self).	2 to: aCollection size do: [ :i | 		id := self symbolIdForTransitionFrom: (aCollection at: i - 1) to: (aCollection at: i).		name := self symbolNameFor: id.		next := SmaCCGraphNode named: name state: (aCollection at: i) parser: self.		graphNodeStack last followed: next.		graphNodeStack add: next ].	returnTable := self maxReturnSizeTable.	self fillInGraphFromStack: graphNodeStack returnTable: returnTable size: 0.	^ graphNodeStack first! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!fillInGraphFromStack: nodeCollection returnTable: tableArray size: sizeInteger	self		allActionsAndSymbolsForState: nodeCollection last state		do: [ :action :symbol | 			| id type next name entry top stream reduction |			id := action bitShift: -2.			type := action bitAnd: self actionMask.			type = self acceptAction				ifTrue: [ nodeCollection last success: true ].			type = self shiftAction				ifTrue: [ ((tableArray at: id) > sizeInteger or: [ self isAcceptState: id ])						ifTrue: [ name := self symbolNameFor: symbol.							next := nodeCollection last addDirectLinkToNodeNamed: name state: id.							nodeCollection add: next.							[ self fillInGraphFromStack: nodeCollection returnTable: tableArray size: sizeInteger + 1 ]								ensure: [ nodeCollection removeLast ] ] ].			type = self reduceAction				ifTrue: [ entry := self reduceTable at: id.					(entry at: 2) >= sizeInteger						ifTrue: [ name := self symbolNameFor: entry first.							stream := WriteStream on: String new.							stream								nextPutAll: name;								nextPutAll: ' :'.							nodeCollection size - (entry at: 2) + 1 to: nodeCollection size do: [ :i | 								stream									nextPut: $ ;									nextPutAll: (nodeCollection at: i) name ].							stream nextPut: $;.							reduction := stream contents.							top := nodeCollection at: nodeCollection size - (entry at: 2).							nodeCollection size - (entry at: 2) + 1 to: nodeCollection size do: [ :i | (nodeCollection at: i) addReduction: reduction ].							next := top addDirectLinkToNodeNamed: name state: ((self actionForState: top state and: entry first) bitShift: -2) ] ] ]! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!maxReturnSizeTable	| table |	table := Array new: self transitionTable size withAll: 0.	1 to: table size do: [ :i | 		self			allActionsAndSymbolsForState: i			do: [ :action :symbol | 				(action bitAnd: self actionMask) = self reduceAction					ifTrue: [ | size |						size := (self reduceTable at: (action bitShift: -2)) at: 2.						table at: i put: ((table at: i) max: size) ] ] ].	table max		timesRepeat: [ 1 to: table size do: [ :i | 				self					allActionsAndSymbolsForState: i					do: [ :action :symbol | 						(action bitAnd: self actionMask) = self shiftAction							ifTrue: [ | size |								size := (table at: (action bitShift: -2)) - 1.								table at: i put: ((table at: i) max: size) ] ] ] ].	^ table! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolIdForTransitionFrom: fromState to: toState	| toValue |	toValue := (toState bitShift: 2) bitOr: self shiftAction.	self		allActionsAndSymbolsForState: fromState		do: [ :action :symbol | 			toValue = action				ifTrue: [ ^ symbol ] ].	^ 0! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 20>	((Smalltalk includesKey: #RTView) not		or: [ ((self class class whichClassIncludesSelector: #transitionTable) >> #transitionTable) methodClass = SmaCCParser class ])		ifTrue: [ ^ nil ].	composite roassal2		title: 'Graph';		initializeView: [ self roassalView ]! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!symbolNameFor: anInteger	^ self symbolNames at: anInteger ifAbsent: [ '?' ]! !!SmaCCParser methodsFor: '*SmaCC_Debugging_Support'!roassalView	^ self roassalViewForStack: (stateStack ifNil: [ Array with: self class defaultStartingState ])! !!SmaCCParser methodsFor: 'private-actions'!actionForState: stateIndex and: aSymbolIndex	| index row |	row := self transitionTable at: stateIndex.	^ (row at: 1) == 0		ifTrue:			[ index := self binarySearchIn: row for: aSymbolIndex size: 2.			index == 0				ifTrue: [ ^ self errorAction ]				ifFalse: [ ^ ((row at: 2) bitShift: 8) + (row at: 3) ] ]		ifFalse:			[ index := self binarySearchIn: row for: aSymbolIndex size: 4.			index == 0				ifTrue: [ ^ self errorAction ]				ifFalse: [ ^ ((row at: index - 2) bitShift: 8)						+ (row at: index - 1) ] ]! !!SmaCCParser methodsFor: 'private-actions'!actionForCurrentToken	self tryAllTokens		ifTrue:			[ | ids action |			ids := currentToken ids.			1 to: ids size do:				[ :i | 				action := self actionFor: (ids at: i).				(action bitAnd: self actionMask) = self errorAction					ifFalse: [ ^ action ] ].			^ self errorAction ]		ifFalse: [ ^ self actionFor: currentToken ids first ]! !!SmaCCParser methodsFor: 'private-actions'!reduceFor: aCollection	| newCollection item |	(aCollection allSatisfy: [ :each | each class ~~ OrderedCollection ])		ifTrue: [ ^ aCollection asOrderedCollection ].	aCollection first class == OrderedCollection		ifTrue:			[ newCollection := aCollection first.			2 to: aCollection size do:				[ :i | 				item := aCollection at: i.				item class == OrderedCollection					ifTrue: [ newCollection addAll: item ]					ifFalse: [ newCollection add: item ] ].			^ newCollection ].	newCollection := OrderedCollection new.	aCollection		do:			[ :each | 			each class == OrderedCollection				ifTrue: [ newCollection addAll: each ]				ifFalse: [ newCollection add: each ] ].	^ newCollection! !!SmaCCParser methodsFor: 'private-actions'!allActionsAndSymbolsForState: stateIndex do: aBlock	self		actionsAndSymbolsForState: stateIndex		do: [ :action :symbol | 			| row |			(action bitAnd: self actionMask) = 2r11				ifTrue: [ row := self ambiguousTransitions at: (action bitShift: -2).					1 to: row size by: 2 do: [ :i | aBlock value: ((row at: i) bitShift: 8) + (row at: i + 1) value: symbol ] ]				ifFalse: [ aBlock value: action value: symbol ] ]! !!SmaCCParser methodsFor: 'private-actions'!shiftAction	^ 2r01! !!SmaCCParser methodsFor: 'private-actions'!actionMask	^ 2r11! !!SmaCCParser methodsFor: 'private-actions'!performAction: action	| value actionType |	actionType := action bitAnd: self actionMask.	value := action bitShift: -2.	actionType == self shiftAction		ifTrue: [ self shift: value ]		ifFalse:			[ actionType == self reduceAction				ifTrue: [ self reduce: value ]				ifFalse: [ self handleError: value ] ]! !!SmaCCParser methodsFor: 'private-actions'!actionFor: aSymbolIndex	^ self actionForState: self currentState and: aSymbolIndex! !!SmaCCParser methodsFor: 'private-actions'!shift: stateIndex	stateStack addLast: stateIndex.	nodeStack addLast: currentToken.	currentToken := nil! !!SmaCCParser methodsFor: 'private-actions'!actionsAndSymbolsForState: stateIndex do: aBlock	| action bytes |	bytes := self transitionTable at: stateIndex.	(bytes at: 1) = 0		ifTrue: [ action := ((bytes at: 2) bitShift: 8) + (bytes at: 3).			4 to: bytes size by: 2 do: [ :i | aBlock value: action value: ((bytes at: i) bitShift: 8) + (bytes at: i + 1) ] ]		ifFalse: [ 2 to: bytes size by: 4 do:				[ :i | aBlock value: ((bytes at: i) bitShift: 8) + (bytes at: i + 1) value: ((bytes at: i + 2) bitShift: 8) + (bytes at: i + 3) ] ]! !!SmaCCParser methodsFor: 'private-actions'!acceptAction	^ 0! !!SmaCCParser methodsFor: 'private-actions'!errorAction	^ 3! !!SmaCCParser methodsFor: 'private-actions'!reduce: anInteger	| reduceEntry items size |	reduceEntry := self reduceTable at: anInteger.	items := Array new: (size := reduceEntry at: 2).	size to: 1 by: -1 do: [ :i | 		items at: i put: self popNodeStack.		stateStack removeLast ].	nodeStack addLast: (self performReduceEntry: reduceEntry with: items).	stateStack		addLast: ((self actionFor: (reduceEntry at: 1)) bitShift: -2)! !!SmaCCParser methodsFor: 'private-actions'!reduceAction	^ 2r10! !!SmaCCParser methodsFor: 'standard reduction rules'!liftLastValue: aCollection	^ aCollection last! !!SmaCCParser methodsFor: 'standard reduction rules'!liftSecondValue: aCollection	^ aCollection at: 2! !!SmaCCParser methodsFor: 'standard reduction rules'!nil	^ nil! !!SmaCCParser methodsFor: 'standard reduction rules'!stringValue: anOrderedCollection	^ anOrderedCollection first value! !!SmaCCParser methodsFor: 'standard reduction rules'!liftFirstValue: aCollection	^ aCollection at: 1! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCParser class	instanceVariableNames: 'cacheId defaultEncoding'!!SmaCCParser class methodsFor: '*SmaCC_Development_UI'!gtGraphReferencesViewIn: composite	<gtInspectorPresentationOrder: 13>	| tree nodes |	(Smalltalk includesKey: #RTBundleBuilder)		ifFalse: [ ^ nil ].	tree := self definitionAST.	tree isNil		ifTrue: [ ^ nil ].	nodes := tree rules select: [ :each | (each isKindOf: SmaCCProductionRuleNode) or: [ each isKindOf: SmaCCTokenRuleNode ] ].	composite roassal2		title: 'References';		initializeView: [ | b view |			view := (Smalltalk at: #RTView) new.			b := (Smalltalk at: #RTBundleBuilder) new.			b view: view.			b labelShape text: #displayString.			b				explore: ''				using: [ :e | 					e == ''						ifTrue: [ nodes ]						ifFalse: [ #() ] ].			b elements do: [ :each | each attributes at: #depth put: 2 ].			b				useBezierlineWith: [ :e | 					e = ''						ifTrue: [ #() ]						ifFalse: [ e ruleReferences ] ].			b bezier color: Color blue trans.			b withoutSlider.			b build.			view ]! !!SmaCCParser class methodsFor: '*SmaCC_Development_UI'!gtDefinitionStringViewIn: composite	<gtInspectorPresentationOrder: 11>	composite text		title: 'Source';		display: [ self definitionString ]! !!SmaCCParser class methodsFor: 'parsing'!parseStream: aStream onError: aBlock	^ [ self parseStream: aStream ]		on: SmaCCParserError		do: (self errorBlock: aBlock)! !!SmaCCParser class methodsFor: 'parsing'!parse: aString startingAt: anInteger	| value |	value := self		parseStream: (ReadStream on: aString)		startingAt: anInteger.	(value isKindOf: SmaCCParseNode)		ifTrue: [ value completeSource: aString ].	^ value! !!SmaCCParser class methodsFor: 'parsing'!parse: aString startingAt: anInteger onError: aBlock	^ [ self parse: aString startingAt: anInteger ]		on: SmaCCParserError		do: (self errorBlock: aBlock)! !!SmaCCParser class methodsFor: 'parsing'!parseFile: aString encoding: encodingString	| encoding fileRef |	fileRef := aString asFileReference.	encoding := encodingString		ifNil: [ [ fileRef				binaryReadStreamDo: [ :in | (ZnCharacterEncoder detectEncoding: in upToEnd) identifier ] ]				on: ZnCharacterEncodingError				do: [ nil ] ].	^ fileRef		readStreamDo: [ :stream | 			| contents |			self setEncoding: encoding on: stream.			contents := stream contents.			(self parse: contents startingAt: self defaultStartingState)				ifNotNil: [ :each | 					(each isKindOf: SmaCCParseNode)						ifTrue: [ stream position: 0.							each completeSource: contents.							each filename: aString ] ] ]! !!SmaCCParser class methodsFor: 'parsing'!parseStream: aStream startingAt: anInteger onError: aBlock	^ [ self parseStream: aStream startingAt: anInteger ]		on: SmaCCParserError		do: (self errorBlock: aBlock)! !!SmaCCParser class methodsFor: 'parsing'!parse: aString	^ self parse: aString startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'parsing'!parseWithErrors: aString	^ self parseWithErrors: aString startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'parsing'!parse: aString onError: aBlock	^ [ self parse: aString ]		on: SmaCCParserError		do: (self errorBlock: aBlock)! !!SmaCCParser class methodsFor: 'parsing'!parseStream: aStream	^ self parseStream: aStream startingAt: self defaultStartingState! !!SmaCCParser class methodsFor: 'parsing'!parseStream: aStream startingAt: anInteger	| parser |	parser := self on: aStream.	parser setStartingState: anInteger.	^ parser parse! !!SmaCCParser class methodsFor: 'parsing'!parseWithErrors: aString startingAt: anInteger	^ [ | parser value |	parser := self on: (ReadStream on: aString).	parser setStartingState: anInteger.	parser createDefaultErrorHandlers.	value := parser parse.	(value isKindOf: SmaCCParseNode)		ifTrue: [ value completeSource: aString ].	^ value ]		on: SmaCCParserError		do: [ :ex | 			ex isResumable				ifTrue: [ ex resume ]				ifFalse: [ ex signal ] ]! !!SmaCCParser class methodsFor: 'parsing'!parseFile: aString	^ self parseFile: aString encoding: self defaultEncoding! !!SmaCCParser class methodsFor: 'accessing'!ambiguousTransitions	^ #()! !!SmaCCParser class methodsFor: 'accessing'!symbolTypes	^ #()! !!SmaCCParser class methodsFor: 'accessing'!startingStateNames	^ ((self class allSelectors		select: [ :each | each beginsWith: 'startingStateFor' ])		collect: [ :each | each asString copyFrom: 17 to: each size ])		asSortedCollection! !!SmaCCParser class methodsFor: 'accessing'!defaultEncoding: aString	defaultEncoding := aString! !!SmaCCParser class methodsFor: 'accessing'!symbolNames	^ #()! !!SmaCCParser class methodsFor: 'accessing'!defaultStartingState	^ 1! !!SmaCCParser class methodsFor: 'accessing'!defaultEncoding	^ defaultEncoding		ifNil: [ self == SmaCCParser				ifTrue: [ nil ]				ifFalse: [ superclass defaultEncoding ] ]! !!SmaCCParser class methodsFor: 'accessing'!errorBlock: aBlock	^ [ :ex | 	| returnValue |	returnValue := aBlock numArgs = 3		ifTrue:			[ aBlock value: ex tag value: ex description value: ex tag ]		ifFalse:			[ aBlock numArgs = 1				ifTrue: [ aBlock value: ex tag ]				ifFalse: [ aBlock value: ex description value: ex tag position ] ].	ex return: returnValue ]! !!SmaCCParser class methodsFor: 'accessing'!reduceTable	^ self subclassResponsibility! !!SmaCCParser class methodsFor: 'accessing'!transitionTable	^ self subclassResponsibility! !!SmaCCParser class methodsFor: 'accessing'!scannerClass	^ self subclassResponsibility! !!SmaCCParser class methodsFor: 'caching'!resetCaches	"self withAllSubclasses do: [:each | each resetCaches]"	! !!SmaCCParser class methodsFor: 'caching'!checkCaches	cacheId ~= self cacheId		ifTrue: [ self resetCaches.			self scannerClass initialize.			cacheId := self cacheId ]! !!SmaCCParser class methodsFor: 'caching'!cacheId	^ '?'! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtTestFor: aView	<gtView>	<gtClassView>	self definitionString isEmpty		ifTrue: [ ^ aView empty ].	^ aView explicit		title: 'Test';		priority: 7;		stencil: [ self gtTestElement ]! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtSourceFor: aView	<gtView>	<gtClassView>	self definitionString isEmpty		ifTrue: [ ^ aView empty ].	^ aView explicit		title: 'Source';		priority: 6;		stencil: [ GtSmaCCGrammarElement onGrammar: (GtSmaCCGrammar onParser: self) ]! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtGrammarFor: aView context: aDictionary	<gtClassView>	| coder |	self definitionString isEmpty		ifTrue: [ ^ aView empty ].	coder := aDictionary		at: #coder		ifAbsentPut: [ GtSmaCCGrammarCoder onParser: self ].	^ aView explicit		title: 'Grammar';		priority: 1;		stencil: [ coder asElement ]! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtTestElement	| element editor actionBar editorElement text |	element := BlElement new.	element layout: BlLinearLayout vertical.	element margin: (BlInsets all: 5).	element		constraintsDo: [ :c | 			c vertical matchParent.			c horizontal matchParent ].	editorElement := BrEditor new.	editorElement padding: (BlInsets all: 2).	editorElement		constraintsDo: [ :c | 			c horizontal matchParent.			c vertical matchParent ].	editor := BrTextEditor new.	text := '' asRopedText.	text attributes: GtSmaCCCoder defaultTextAttributes.	editor text: text.	self gtStyler ifNotNil: [ :styler | editor styler: styler ].	editorElement editor: editor.	actionBar := BrToolbar new		look: BrGlamorousToolbarLook new;		addItem:			(BrButton new				beSmall;				look: BrGlamorousButtonWithIconLook;				label: 'Inspect';				icon: BrGlamorousVectorIcons inspect;				action: [ :button | 					[ button phlow spawnObject: (self parse: editor text asString) ]						on: SmaCCParserError						do: [ :ex | ex gtDisplayErrorIn: editor ] ]);		addItem:			(BrButton new				beSmall;				look: BrGlamorousButtonWithIconLook;				label: 'Debug';				icon: BrGlamorousVectorIcons debug;				action: [ :button | self debug: editor text asString from: button ]).	element addChild: editorElement.	element addChild: actionBar.	^ element! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!debug: aString from: anElement	| process context debuggingSession |	context := [ self parse: aString ] asContext.	process := Process		forContext: context		priority: Processor userInterruptPriority.	debuggingSession := process		newDebugSessionNamed: 'Debug parse'		startedAt: process suspendedContext.	[ SmaCCParserDebugSession handlesContext: debuggingSession context ]		whileFalse: [ debuggingSession stepInto ].	process debug! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtGrammarFor: aView	<gtView>	^ self gtGrammarFor: aView context: Dictionary new! !!SmaCCParser class methodsFor: '*GT4SmaCC-Development-UI'!gtAnnotationsFor: aView context: aDictionary	<gtClassView>	| coder |	self definitionString isEmpty		ifTrue: [ ^ aView empty ].	coder := aDictionary		at: #coder		ifAbsentPut: [ GtSmaCCGrammarCoder onParser: self ].	^ aView explicit		title: 'Annotations';		priority: 2;		stencil: [ coder asVariableElement ]! !!SmaCCParser class methodsFor: 'instance creation'!on: aStream	| parser scanner |	self checkCaches.	scanner := self scannerClass on: aStream.	parser := self new.	parser scanner: scanner.	^ parser! !!SmaCCParser class methodsFor: 'file types'!fileExtension	^ ''! !!SmaCCParser class methodsFor: 'file types'!fileExtensionType	^ 'All files'! !!SmaCCParser class methodsFor: 'file types'!fileExtensions	^ Array with: self fileExtension! !!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!filesWithParserErrorsIn: aDirectory	^ (self sourceFilesIn: aDirectory)		select: [ :each | 			[ self parseFile: each.			false ]				on: Error				do: [ :ex | ex return: true ] ]! !!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!gtGraphInspectorViewIn: composite	<gtInspectorPresentationOrder: 14>	self new gtGraphInspectorViewIn: composite! !!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSmaCCParser	<gtExample>	<label: 'SmaCCParser'>		^ SmaCCDefinitionParser new.	! !!SmaCCParser class methodsFor: '*SmaCC_Debugging_Support'!sourceFilesIn: aDirectory	^ aDirectory asFileReference allFiles		select: [ :each | 			| extension |			extension := '.' , each extension.			self fileExtensions includes: extension ]! !!SmaCCParser class methodsFor: '*GT4SmaCC-Stylers'!gtStylers	| pragmas |	pragmas := OrderedCollection new.	Smalltalk		allClassesAndTraitsDo: [ :each | 			(Pragma allNamed: #smaccStyler:priority: in: each classSide)				do: [ :pragma | 					((self						includesBehavior: (Smalltalk at: pragma arguments first ifAbsent: [ Array ]))						and: [ pragma method numArgs = 1 ])						ifTrue: [ pragmas add: pragma ] ] ].	^ (pragmas		asSortedCollection: [ :a :b | a arguments last < b arguments last ])		collect: [ :each | 			each method methodClass instanceSide				perform: each method selector				with: self ]! !!SmaCCParser class methodsFor: '*GT4SmaCC-Stylers'!gtStyler	| stylers |	stylers := self gtStylers.	^ stylers isEmpty		ifTrue: [ nil ]		ifFalse: [ stylers first ]! !!SmaCCParser class methodsFor: '*SmaCC_Development'!removeCommentedPartOf: aString	| inStream outStream |	inStream := ReadStream on: aString.	outStream := WriteStream with: String new.	inStream upTo: $".	[ inStream atEnd ]		whileFalse: [ (inStream peekFor: $")				ifTrue: [ outStream nextPut: $" ].			outStream nextPutAll: (inStream upTo: $") ].	^ outStream contents! !!SmaCCParser class methodsFor: '*SmaCC_Development'!compileGrammar: aString	| oldCharacterSize |	(aString isNil or: [ aString isEmpty ])		ifTrue: [ ^ self ].	oldCharacterSize := SmaCCGrammar maximumCharacterValue.	[ SmaCCGrammarCompiler new		buildDefinition: aString;		compileInto: self scannerClass andParser: self ]		ensure: [ SmaCCGrammar maximumCharacterValue: oldCharacterSize ]! !!SmaCCParser class methodsFor: '*SmaCC_Development'!definitionAST	^ [ SmaCCDefinitionParser parse: self definitionString ]		on: SmaCCParserError		do: [ :ex | ex return: nil ]! !!SmaCCParser class methodsFor: '*SmaCC_Development'!recompileAll	"self recompileAll"	self withAllSubclasses		do: [ :each | each compileGrammar: each definitionString ]		displayingProgress: [ :each | 'Compiling ' , each instanceSide name ]! !!SmaCCParser class methodsFor: '*SmaCC_Development'!definitionString	| scannerClass source |	scannerClass := [ self scannerClass ]		on: Error		do: [ :ex | ex return: nil ].	(self class includesSelector: #definitionComment)		ifTrue: [ source := self removeCommentedPartOf: (self class sourceCodeAt: #definitionComment) ]		ifFalse: [ source := ''.			(self class includesSelector: #parserDefinitionComment)				ifTrue: [ source := self removeCommentedPartOf: (self class sourceCodeAt: #parserDefinitionComment) ].			(scannerClass notNil and: [ scannerClass class includesSelector: #scannerDefinitionComment ])				ifTrue:					[ source := (self removeCommentedPartOf: (scannerClass class sourceCodeAt: #scannerDefinitionComment)) , '\' withCRs , source ] ].	^ source! !!SmaCCParser class methodsFor: 'encoding'!setEncodingOn: aStream	self setEncoding: nil on: aStream! !!SmaCCParser class methodsFor: 'encoding'!setEncoding: aString on: aStream	"Handle Pharo 6/7 streaming differences"	| encoding |	encoding := aString ifNil: [ self defaultEncoding ifNil: [ 'utf-8' ] ].	aStream encoding: encoding! !Error subclass: #SmaCCParserError	instanceVariableNames: 'isResumable'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCParserError commentStamp: '' prior: 0!SmaCCParserError is the exception raised when a parsing error occurs. The description of the exception will be the error message and the parameter of the exception is the parser. With this information, you can insert a custom error message in your text view that you are parsing. For example, in VisualWorks, the following code will insert an error message into your text view:	textController insertAndSelect: ex description , ' ->' at: ex parameter position!!SmaCCParserError methodsFor: '*GT4SmaCC-Development-UI'!gtDisplayErrorIn: aBrTextEditor	| index |	index := (self tag position - 1 max: 1) min: aBrTextEditor text size.	(aBrTextEditor text from: index to: index)		attributes: { (GtSourceCoderErrorAttribute for: self description) }.	aBrTextEditor moveCursorTo: index! !!SmaCCParserError methodsFor: 'accessing'!isResumable: aBoolean	isResumable := aBoolean! !!SmaCCParserError methodsFor: 'initialize-release'!initialize	super initialize.	isResumable := false! !!SmaCCParserError methodsFor: 'testing'!isResumable	^ isResumable! !!SmaCCParserError methodsFor: '*SmaCC_Debugging_Support'!gtParserErrorInspectorViewIn: composite	<gtInspectorPresentationOrder: 1>	composite text		title: 'Error';		display: [ | source |			source := self tag scanner debugSource.			(source isEmpty and: [ self tag position > 1 ])				ifTrue: [ 'No source available' ]				ifFalse: [ (source copyFrom: 1 to: self tag position - 1) , self description , ' ->' , (source copyFrom: self tag position to: source size) ] ];		primarySelectionInterval: (self tag position to: self tag position + self description size + 2);		withLineNumbers: true! !SmaCCParseNode subclass: #SmaCCPatternNode	instanceVariableNames: 'patternToken'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCPatternNode commentStamp: '' prior: 0!SmaCCPatternNode is a parse node that matches other parse nodes when you are searching or rewriting parse trees.Instance Variables:	patternToken	<SmaCCPatternToken>	the token that holds our name and properties!!SmaCCPatternNode methodsFor: 'comparing'!= anObject	^ super = anObject and: [ self patternToken = anObject patternToken ]! !!SmaCCPatternNode methodsFor: 'comparing'!hash	^ self patternToken hash! !!SmaCCPatternNode methodsFor: 'testing'!isListMatch	^ patternToken isListMatch! !!SmaCCPatternNode methodsFor: 'matching'!copyInContext: aDictionary	^ (aDictionary at: self ifAbsent: [ nil ]) copy! !!SmaCCPatternNode methodsFor: 'matching'!match: aSmaCCParseNode inContext: aDictionary	^ (aDictionary at: self ifAbsentPut: [ aSmaCCParseNode ])		= aSmaCCParseNode		and: [ patternToken testBlock value: aSmaCCParseNode ]! !!SmaCCPatternNode methodsFor: 'accessing'!name	^ patternToken name! !!SmaCCPatternNode methodsFor: 'accessing'!patternToken	^ patternToken! !!SmaCCPatternNode methodsFor: 'accessing'!patternToken: anObject	patternToken := anObject! !!SmaCCPatternNode methodsFor: 'variables'!tokenVariables	^ #(#patternToken)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCPatternNode class	instanceVariableNames: ''!!SmaCCPatternNode class methodsFor: 'instance creation'!onToken: aSmaCCPatternToken	^ self new		patternToken: aSmaCCPatternToken;		yourself! !Object subclass: #SmaCCScanner	instanceVariableNames: 'stream start matchActions matchEnd currentCharacter outputStream lastOutputStreamMatchPosition lastMatchWasEmpty returnMatchBlock scope comments'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCScanner commentStamp: '' prior: 0!SmaCCScanner is an abstract class that represents a scanner for the parser. The scanner converts its string input into SmaCCToken objects that the parser then uses for its parsing.Subclasses must implement the following messages:	accessing		emptySymbolTokenId		errorTokenId		scanForTokenInstance Variables:	comments	<OrderedCollection>	a collection of comment intervals (array of start position & stop position)	currentCharacter	<Character>	the current character we are scanning	lastMatchWasEmpty	<Boolean>	was our last scanning match an empty string -- don't allow two empty matches in a row	lastOutputStreamMatchPosition	<Integer>	the position in the outputStream of the last match	matchActions	<Array | Symbol>	the actions for the last match (a symbol means that the action should be performed on the scanner)	matchEnd	<Integer>	the position of the last match in the stream (our input stream)	outputStream	<PositionableStream>	the matched characters go in this stream. After a match is made, we take this stream's contents and create a token object.	returnMatchBlock	<BlockClosure>	when we match a token evaluate this block with the token (hack to return from multiple levels)	start	<Integer>	the starting position of a match in the stream	state	<Symbol>	the state of the scanner	stream	<Stream>	our input!!SmaCCScanner methodsFor: 'testing'!atEnd	^ stream atEnd! !!SmaCCScanner methodsFor: 'initialize-release'!initialize	super initialize.	outputStream := WriteStream with: String new.	lastMatchWasEmpty := true.	scope := #default.	comments := OrderedCollection new! !!SmaCCScanner methodsFor: 'initialize-release'!on: aStream	stream := aStream.	start := stream position! !!SmaCCScanner methodsFor: 'default token handling'!comment	comments add: (Array with: start + 1 with: matchEnd).	^ self whitespace! !!SmaCCScanner methodsFor: 'default token handling'!patternToken	| token |	token := SmaCCPatternToken		value: outputStream contents		start: start + 1		ids: matchActions.	outputStream reset.	^ token! !!SmaCCScanner methodsFor: 'default token handling'!whitespace	"By default, eat the whitespace"	self resetScanner.	^ self scanForToken! !!SmaCCScanner methodsFor: 'private'!recordAndReportMatch: aCollection	self recordMatch: aCollection.	^ self reportLastMatch! !!SmaCCScanner methodsFor: 'private'!resetScanner	matchActions := nil.	start := stream position.	outputStream reset.	lastOutputStreamMatchPosition := 0! !!SmaCCScanner methodsFor: 'private'!step	stream atEnd		ifTrue: [ ^ returnMatchBlock value: self reportLastMatch ].	currentCharacter := stream next.	outputStream nextPut: currentCharacter! !!SmaCCScanner methodsFor: 'private'!debugStart	^ start! !!SmaCCScanner methodsFor: 'private'!scanForString: aString	^ aString		allSatisfy: [ :each | 			self step.			currentCharacter == each ]! !!SmaCCScanner methodsFor: 'private'!lastOutputStreamMatchPosition	^ lastOutputStreamMatchPosition! !!SmaCCScanner methodsFor: 'private'!tokenClass	^ SmaCCToken! !!SmaCCScanner methodsFor: 'private'!stream	^stream! !!SmaCCScanner methodsFor: 'private'!checkForKeyword: aString	| stateMap action oldActions entry |	action := matchActions isSymbol		ifTrue: [ matchActions ]		ifFalse: [ matchActions first ].	stateMap := self class keywordMap at: action ifAbsent: [ nil ].	stateMap isNil		ifTrue: [ ^ self ].	oldActions := matchActions.	entry := stateMap at: (self keywordFor: aString) ifAbsent: [ nil ].	entry isNil		ifTrue: [ ^ self ].	entry isInteger		ifTrue: [ matchActions := entry ]		ifFalse:			[ (entry last includes: scope)				ifFalse: [ ^ self ].			matchActions := entry first ].	matchActions isInteger		ifTrue: [ matchActions := (Array with: matchActions) , oldActions ]! !!SmaCCScanner methodsFor: 'private'!outputStream	^ outputStream! !!SmaCCScanner methodsFor: 'private'!scannerError	| string |	(stream atEnd and: [ start == stream position ])		ifTrue: [ string := ''.			matchActions := self eofTokenId ]		ifFalse:			[ stream position: start.			string := String with: stream next.			matchActions := #(0) ].	returnMatchBlock value: (self createTokenFor: string)! !!SmaCCScanner methodsFor: 'private'!checkForValidMatch	matchActions isNil		ifTrue: [ self scannerError ]! !!SmaCCScanner methodsFor: 'private'!recordMatch: aCollection	matchActions := aCollection.	matchEnd := stream position.	lastOutputStreamMatchPosition := outputStream position! !!SmaCCScanner methodsFor: 'private'!createTokenFor: string	| token |	token := self tokenClass		value: string		start: start + 1		ids: matchActions.	outputStream reset.	^ token! !!SmaCCScanner methodsFor: 'private'!currentCharacter	^ currentCharacter! !!SmaCCScanner methodsFor: 'private'!debugEnd	^ matchEnd! !!SmaCCScanner methodsFor: 'private'!reportLastMatch	"The scanner has found the end of a token and must report it"	| string action |	self checkForValidMatch.	self resetOutputToLastMatch.	stream position: matchEnd.	string := outputStream contents.	self checkForKeyword: string.	action := matchActions isSymbol		ifTrue:			[ matchActions ]		ifFalse: [ self tokenActions				at: matchActions first				ifAbsent: [ nil ] ].	"This is only necessary to run version 1 parsers on version 2 SmaCC"	^ action notNil		ifTrue: [ self perform: action ]		ifFalse: [ self createTokenFor: string ]! !!SmaCCScanner methodsFor: 'private'!resetOutputToLastMatch	outputStream position: lastOutputStreamMatchPosition.	lastOutputStreamMatchPosition == 0		ifTrue:			[ lastMatchWasEmpty				ifTrue: [ self scannerError ].			lastMatchWasEmpty := true ]		ifFalse: [ lastMatchWasEmpty := false ]! !!SmaCCScanner methodsFor: 'private'!matchActions	^ matchActions! !!SmaCCScanner methodsFor: 'accessing'!position: anInteger	^ stream position: anInteger! !!SmaCCScanner methodsFor: 'accessing'!scope	^ scope! !!SmaCCScanner methodsFor: 'accessing'!lineNumber	"This requires the stream to be a line number stream (see the #needsLineNumbers class method)."	^ stream lineNumber! !!SmaCCScanner methodsFor: 'accessing'!position	^ stream position! !!SmaCCScanner methodsFor: 'accessing'!errorTokenId	^ self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing'!next	self resetScanner.	returnMatchBlock := [ :match | ^ match ].	^ self scanForToken! !!SmaCCScanner methodsFor: 'accessing'!scope: aSymbol	scope := aSymbol! !!SmaCCScanner methodsFor: 'accessing'!contents	| writeStream token |	writeStream := WriteStream with: Array new.	[ self atEnd ]		whileFalse:			[ token := self next.			token notNil				ifTrue: [ writeStream nextPut: token ] ].	^ writeStream contents! !!SmaCCScanner methodsFor: 'accessing'!scanForToken	^ self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing'!emptySymbolTokenId	^ self subclassResponsibility! !!SmaCCScanner methodsFor: 'accessing'!eofTokenId	^ Array with: self emptySymbolTokenId! !!SmaCCScanner methodsFor: 'accessing'!comments	^ comments! !!SmaCCScanner methodsFor: 'accessing'!peekCharacter	^ stream peek! !!SmaCCScanner methodsFor: 'accessing'!setPosition: anInteger	^ stream position: anInteger! !!SmaCCScanner methodsFor: '*SmaCC_Debugging_Support'!debugSource	| str position |	str := self stream.	(str respondsTo: #position:)		ifFalse: [ ^ '' ].	position := str position.	^ [ str position: 0.	str contents ]		ensure: [ str position: position ]! !!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!currentState	"Return an object that can be used to restoreState: when switching between parses in a GLR parser. 	This object should implement #= in such a way that if the state is restored, then calling #next will 	always return the same token. If you add state to your scanner you may want to override this method	and #restoreState: to include that state."	^ self stateClass position: self position scope: self scope! !!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!restoreState: aSmaCCScannerState	"Restore the state using the object returned from #currentState."	self setPosition: aSmaCCScannerState position.	self scope: aSmaCCScannerState scope! !!SmaCCScanner methodsFor: '*SmaCC_GLR_Runtime'!stateClass	^ SmaCCScannerState! !!SmaCCScanner methodsFor: 'utility'!tokenActions	^ #()! !!SmaCCScanner methodsFor: 'utility'!keywordFor: aString	"Subclasses can override this to ignore case"	^ aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCScanner class	instanceVariableNames: 'keywordMap'!!SmaCCScanner class methodsFor: 'instance creation'!on: aStream	^ self new		on:			(self needsLineNumbers				ifTrue: [ SmaCCLineNumberStream on: aStream ]				ifFalse: [ aStream ]);		yourself! !!SmaCCScanner class methodsFor: 'class initialization'!initialize	self initializeKeywordMap! !!SmaCCScanner class methodsFor: 'class initialization'!initializeKeywordMap	keywordMap := Dictionary new! !!SmaCCScanner class methodsFor: 'accessing'!keywordMap	keywordMap isNil		ifTrue: [ self initializeKeywordMap ].	^ keywordMap! !!SmaCCScanner class methodsFor: 'testing'!needsLineNumbers	"Redefine to return true, if you need line number information"	^ false! !SmaCCErrorNodeHandler subclass: #SmaCCSpecificErrorNodeHandler	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCSpecificErrorNodeHandler methodsFor: 'private-error handling'!errorShiftActionsForState: stateIndex	| actions |	actions := self actionsForState: stateIndex and: self errorTokenId.	^ (actions select: [ :each | (each bitAnd: self actionMask) = self shiftAction ]) collect: [ :each | each bitShift: -2 ]! !!SmaCCSpecificErrorNodeHandler methodsFor: 'private-error handling'!performErrorReductions	| action actions |	[ actions := self actionsForState: self stateStack last and: self errorTokenId.	action := actions detect: [ :each | (each bitAnd: self actionMask) = self reduceAction ] ifNone: [ 0 ].	(action bitAnd: self actionMask) == self reduceAction ] whileTrue: [ self reduce: (action bitShift: -2) ]! !!SmaCCSpecificErrorNodeHandler methodsFor: 'private-error handling'!finishErrorParse: errorToken dismissed: dismissedTokens	| handlerStates |	handlerStates := self errorHandlerStates reverse.	(self finishErrorParse: errorToken dismissed: dismissedTokens handlerStates: handlerStates)		ifFalse: [ super finishErrorParse: errorToken dismissed: dismissedTokens ]! !Object subclass: #SmaCCToken	instanceVariableNames: 'start ids value'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCToken commentStamp: '' prior: 0!SmaCCTokens are used as the interface objects between scanner and parser. They hold the string that was scanned and its position information. Also, included in the token is its id. The id specifies what type of token it is.Instance Variables:	id	<Array of: Integer>	the list of possible token types this represents. There can be overlapping tokens, so we list all of the id here. The default parser only looks at the first id, but we can redefine this behavior in a subclass to look at all possibilities until we find a valid token.	start	<Integer>	the starting position of the token in the original input	value	<Object>	the value of our token (normally a string, but could be anything)!!SmaCCToken methodsFor: 'testing'!isPattern	^ false! !!SmaCCToken methodsFor: 'testing'!isSyntaxError	^ self ids first = 0! !!SmaCCToken methodsFor: 'testing'!isListMatch	^ false! !!SmaCCToken methodsFor: 'matching'!copyInContext: aDictionary	^ self! !!SmaCCToken methodsFor: 'matching'!match: anObject inContext: aDictionary	^ self = anObject! !!SmaCCToken methodsFor: '*SmaCC_Development'!position	^ self startPosition! !!SmaCCToken methodsFor: 'printing'!printOn: aStream	aStream		nextPut: ${;		nextPutAll: self value;		nextPut: $(;		nextPutAll: self startPosition printString;		nextPut: $,;		nextPutAll: self stopPosition printString;		nextPut: $,;		nextPutAll: self ids printString;		nextPutAll: ')}'! !!SmaCCToken methodsFor: 'initialize-release'!value: aString start: startPositionInteger ids: aCollection	value := aString.	start := startPositionInteger.	ids := aCollection! !!SmaCCToken methodsFor: '*SmaCC_Debugging_Support'!gtInspectorSourceIn: aComposite inContext: aGTInspector	<gtInspectorPresentationOrder: 40>	aComposite text		title: 'Source';		withLineNumbers: true;		when: [ (aGTInspector panes reversed				collect: [ :each | (each port: #entity) value ])				anySatisfy: [ :each | 					(each isKindOf: SmaCCParseNode)						and: [ each topParent completeSource notNil ] ] ];		display: [ ((aGTInspector panes reversed				collect: [ :each | (each port: #entity) value ])				detect: [ :each | each isKindOf: SmaCCParseNode ]) topParent				completeSource ];		initialize: [ :textPresentation | 			self startPosition				ifNotNil: [ textPresentation selectionInterval: self sourceInterval ] ]! !!SmaCCToken methodsFor: 'public'!id	^ ids! !!SmaCCToken methodsFor: 'comparing'!= aSmaCCToken	^ self class = aSmaCCToken class		and: [ self value = aSmaCCToken value ]! !!SmaCCToken methodsFor: 'comparing'!hash	^ self value hash! !!SmaCCToken methodsFor: 'accessing'!sourceInterval	^ self startPosition to: self stopPosition! !!SmaCCToken methodsFor: 'accessing'!size	^ self stopPosition - self startPosition + 1! !!SmaCCToken methodsFor: 'accessing'!startPosition	^ start! !!SmaCCToken methodsFor: 'accessing'!value	^ value! !!SmaCCToken methodsFor: 'accessing'!ids	^ ids! !!SmaCCToken methodsFor: 'accessing'!stopPosition	start isNil		ifTrue: [ ^ nil ].	^ start + value size - 1! !!SmaCCToken methodsFor: 'accessing'!ids: anArray	ids := anArray! !!SmaCCToken methodsFor: 'accessing'!source	^ value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SmaCCToken class	instanceVariableNames: ''!!SmaCCToken class methodsFor: 'public'!value: aString start: anInteger id: anObject	^ self value: aString start: anInteger ids: anObject! !!SmaCCToken class methodsFor: 'instance creation'!value: aString	^ self value: aString start: 0 ids: #()! !!SmaCCToken class methodsFor: 'instance creation'!value: aString start: anInteger ids: aCollection	^ self new		value: aString start: anInteger ids: aCollection;		yourself! !!SmaCCToken class methodsFor: '*SmaCC_Debugging_Support'!gtExampleSimple	<gtExample>	^ self value: 'simple'! !SmaCCToken subclass: #SmaCCCaseInsensitiveToken	instanceVariableNames: ''	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCCaseInsensitiveToken commentStamp: '' prior: 0!SmaCCCaseInsensitiveToken represents a case insensitive token (e.g., "IF" and "if" will compare equal).!!SmaCCCaseInsensitiveToken methodsFor: 'comparing'!= aSmaCCToken	^ self class = aSmaCCToken class		and: [ self value sameAs: aSmaCCToken value ]! !!SmaCCCaseInsensitiveToken methodsFor: 'comparing'!hash	^ self value asUppercase hash! !SmaCCToken subclass: #SmaCCPatternToken	instanceVariableNames: 'isList isToken isNode testBlock nodeClassName'	classVariableNames: ''	package: 'SmaCC_Runtime'!!SmaCCPatternToken commentStamp: '' prior: 0!SmaCCPatternToken is a token for pattern nodes.Instance Variables:	isList	<Boolean>	do we match collections or single objects	isNode	<Boolean>	can we match other parse nodes	isToken	<Boolean>	can we match other tokens	nodeClassName	<Symbol>	when matching a parse node, limit it to these types of nodes	testBlock	<BlockClosure>	after a match, run some code that tests the match!!SmaCCPatternToken methodsFor: 'comparing'!= aSmaCCToken	^ self class = aSmaCCToken class		and: [ self name = aSmaCCToken name ]! !!SmaCCPatternToken methodsFor: 'comparing'!hash	^ self class hash bitXor: self name hash! !!SmaCCPatternToken methodsFor: 'accessing'!testBlock	^ [ :node | 	(nodeClassName isNil		or:			[ node				isKindOf:					(node class environment						at: self nodeClassName						ifAbsent: [ SmaCCParseNode ]) ]) and: [ testBlock value: node ] ]! !!SmaCCPatternToken methodsFor: 'accessing'!testBlock: aBlock	testBlock := aBlock! !!SmaCCPatternToken methodsFor: 'accessing'!beTokenOrNode	isToken := true.	isNode := true! !!SmaCCPatternToken methodsFor: 'accessing'!beList	isList := true! !!SmaCCPatternToken methodsFor: 'accessing'!nodeClassName	^ nodeClassName! !!SmaCCPatternToken methodsFor: 'accessing'!name	| resultStream readStream char |	(value first isAlphaNumeric or: [ value first == $_ ])		ifTrue: [ ^ value ].	resultStream := WriteStream on: String new.	readStream := ReadStream on: value.	readStream next.	[ char := readStream next.	char isLetter or: [ char == $_ ] ] whileFalse.	[ resultStream nextPut: char.	char := readStream next.	char isAlphaNumeric or: [ char == $_ ] ] whileTrue.	^ resultStream contents! !!SmaCCPatternToken methodsFor: 'accessing'!beToken	isToken := true.	isNode := false! !!SmaCCPatternToken methodsFor: 'accessing'!nodeClassName: aString	nodeClassName := aString! !!SmaCCPatternToken methodsFor: 'accessing'!beNode	isNode := true.	isToken := false! !!SmaCCPatternToken methodsFor: 'private'!buildStructure	| index code source |	isList := isToken := false.	isNode := true.	testBlock := [ :node | true ].	index := value indexOf: ${.	index > 0		ifFalse: [ ^ self ].	code := value copyFrom: index + 1 to: (value lastIndexOf: $}) - 1.	source := 'self ' , code.	RBParser parseExpression: source onError: [ :s :p | self error: 'Invalid pattern expression' ].	self class compiler		source: source;		logged: false;		receiver: self;		evaluate! !!SmaCCPatternToken methodsFor: 'matching'!copyInContext: aDictionary	^ aDictionary at: self! !!SmaCCPatternToken methodsFor: 'matching'!match: aSmaCCToken inContext: aDictionary	^ (aSmaCCToken isKindOf: SmaCCToken)		and:			[ (aDictionary at: self ifAbsentPut: [ aSmaCCToken ]) = aSmaCCToken				and: [ self testBlock value: aSmaCCToken ] ]! !!SmaCCPatternToken methodsFor: 'initialize-release'!value: aString start: startPositionInteger ids: aCollection	super value: aString start: startPositionInteger ids: aCollection.	self buildStructure! !!SmaCCPatternToken methodsFor: 'testing'!isNode	^ isNode! !!SmaCCPatternToken methodsFor: 'testing'!isPattern	^ true! !!SmaCCPatternToken methodsFor: 'testing'!isToken	^ isToken! !!SmaCCPatternToken methodsFor: 'testing'!isListMatch	^ isList! !SmaCCScanner initialize!